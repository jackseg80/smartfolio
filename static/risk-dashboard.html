<!DOCTYPE html>
<html lang="fr">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Risk Dashboard - Crypto Portfolio</title>

  <!-- Thème/compat identiques à ta page actuelle -->
  <link rel="stylesheet" href="shared-theme.css">
  <link rel="stylesheet" href="theme-compat.css">
  <link rel="stylesheet" href="components/governance-panel.css">

  <!-- Scripts partagés existants -->
  <script src="global-config.js"></script>
  <script src="appearance.js"></script>
  <script src="lazy-loader.js"></script>

  <!-- Core modules ESM -->
  <script type="module" src="core/risk-dashboard-store.js"></script>
  <script type="module" src="core/fetcher.js"></script>

  <!-- CCS modules ESM -->
  <script type="module" src="modules/signals-engine.js"></script>
  <script type="module" src="modules/cycle-navigator.js"></script>
  <script type="module" src="modules/targets-coordinator.js"></script>
  <script type="module" src="modules/onchain-indicators.js"></script>
  <script type="module" src="modules/market-regimes.js"></script>

  <!-- Chart.js will be lazy-loaded when needed -->

  <style>
    /* ===== Container responsive ===== */
    .container {
      width: 100%;
      max-width: 95vw;
      margin: 0 auto;
      padding: 0 var(--space-lg);
    }

    @media (max-width: 768px) {
      .container {
        padding: 0 var(--space-md);
      }
    }

    /* ===== Layout Hybride: Sidebar + Main ===== */
    .dashboard-layout {
      display: grid;
      grid-template-columns: 250px 1fr;
      gap: var(--space-lg);
      min-height: calc(100vh - 200px);
    }

    /* Transition douce sur la grille et la sidebar */
    .dashboard-layout,
    .sidebar {
      transition: grid-template-columns .25s ease, width .25s ease, padding .2s ease;
    }

    /* État "réduit" : la 1ère colonne devient étroite */
    .dashboard-layout.sidebar-collapsed {
      grid-template-columns: 0 1fr;
      /* barre complètement fermée */
    }

    /* La barre devient invisible (pas de padding/bordure/ombre) */
    .sidebar.collapsed {
      padding: 0 !important;
      border: 0 !important;
      box-shadow: none !important;
      width: 0 !important;
      overflow: visible;
      /* pour laisser le bouton flotter par-dessus */
    }

    /* On cache TOUT le contenu de la barre... */
    .sidebar.collapsed>* {
      display: none !important;
    }

    /* ...sauf le bouton de toggle, qui devient flottant */
    #sidebar-toggle {
      transition: transform .2s ease, opacity .2s ease;
    }

    /* Bouton flottant quand la barre est réduite */
    .dashboard-layout {
      position: relative;
    }

    /* ancre pour le bouton en absolute */
    .sidebar.collapsed #sidebar-toggle {
      display: inline-flex !important;
      position: absolute;
      /* ancré au layout (voir règle ci-dessus) */
      left: 0;
      /* collé au bord gauche */
      top: 50%;
      transform: translate(-40%, -40%);
      /* demi hors-cadre = “poignée” */
      z-index: 50;
      padding: .4rem .5rem;
      border-radius: var(--radius-full);
      background: var(--theme-surface);
      border: 1px solid var(--theme-border);
      box-shadow: var(--shadow-sm);
      width: auto;
      /* bouton compact */
    }

    /* En mode réduit : icône seule, pas de texte */
    .sidebar.collapsed .sidebar-toggle-text {
      display: none !important;
    }

    /* Petite sécurité visuelle au survol */
    .sidebar.collapsed #sidebar-toggle:hover {
      transform: translate(-50%, -50%) scale(1.2);
    }

    /* Blended: style de base + transitions */
    #blended-gauge {
      padding: 2rem;
      border: 2px solid var(--theme-border);
      border-radius: var(--radius-md);
      box-shadow: var(--shadow-sm);
      transition: background .2s ease, border-color .2s ease, box-shadow .2s ease;
    }

    /* Tons dynamiques (utilisent les variables déjà adaptatives light/dark) */

    /* ===== CSP Compliance: Replace inline styles ===== */
    .refresh-group {
      position: relative;
      display: inline-flex;
      align-items: stretch;
    }
    
    .refresh-menu-btn {
      padding: 0 .6rem;
      width: auto;
    }
    
    .refresh-menu {
      display: none;
      position: absolute;
      top: 100%;
      left: 0;
      background: var(--theme-bg);
      border: 1px solid var(--theme-border);
      border-radius: var(--radius-sm);
      box-shadow: 0 6px 14px rgba(0,0,0,.25);
      min-width: 220px;
      z-index: 1000;
    }
    
    .refresh-menu.show {
      display: block;
    }
    
    .refresh-menu-item {
      display: block;
      width: 100%;
      text-align: left;
      padding: .5rem .75rem;
      background: none;
      border: none;
      color: var(--theme-text);
      cursor: pointer;
    }
    
    .refresh-menu-item:hover {
      background: var(--theme-surface-alt);
    }
    
    .test-api-btn {
      background: #007bff;
    }
    
    .sidebar-toggle-full {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: .5rem;
      background: var(--theme-bg);
      color: var(--theme-text);
      border: 1px solid var(--theme-border);
      border-radius: var(--radius-md);
      padding: .5rem;
      margin-bottom: var(--space-md);
      cursor: pointer;
    }
    
    .sidebar-section-top {
      margin-top: 1.5rem;
    }
    
    .sidebar-title {
      font-size: 1rem;
      font-weight: 700;
    }
    
    .blended-gauge-container {
      padding: 2rem;
      border: 2px solid var(--theme-border);
      box-shadow: 0 0 12px rgba(0,0,0,0.15);
    }
    
    .ccs-score {
      font-size: 3rem;
    }
    
    .ccs-label {
      font-size: 1rem;
      font-weight: 700;
    }
    
    .governance-details {
      margin-top: 8px;
      font-size: 0.85em;
      opacity: 0.8;
    }
    
    .alerts-list-container {
      margin-top: 8px;
      max-height: 150px;
      overflow-y: auto;
    }
    
    .alerts-button-container {
      text-align: center;
      margin-top: 8px;
      font-size: 0.75rem;
    }
    
    .alerts-history-btn {
      background: var(--brand-primary);
      color: white;
      border: none;
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.7rem;
    }
    
    .status-acknowledged {
      color: var(--success);
    }
    
    .status-snoozed {
      color: var(--warning);
    }
    
    .status-active {
      color: var(--error);
    }
    
    .alert-timestamp {
      font-size: 0.7rem;
      color: var(--text-muted);
    }
    
    .cycle-text-container {
      font-size: 11px;
      font-weight: 600;
    }
    
    .cycle-subtext {
      font-size: 10px;
      opacity: 0.8;
    }
    
    .regime-text-bold {
      font-weight: bold;
    }
    
    .regime-subtext {
      font-size: 0.8rem;
      margin-top: 2px;
    }
    
    .test-mode-banner {
      background: var(--info-bg);
      border: 1px solid var(--info);
      border-radius: var(--radius-md);
      padding: 1rem;
      margin-bottom: 1.5rem;
      text-align: center;
    }
    
    .test-mode-title {
      color: var(--info);
      font-weight: 600;
      margin-bottom: 0.5rem;
    }
    
    .test-mode-desc {
      color: var(--theme-text-muted);
      font-size: 0.9rem;
    }
    
    .insights-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: .75rem;
    }
    
    .insight-title {
      font-weight: 600;
      color: var(--theme-text);
    }
    
    .insight-desc {
      color: var(--theme-text-muted);
      margin-top: 0.25rem;
    }
    
    .metric-label {
      font-size: .8rem;
      color: var(--theme-text);
      opacity: .7;
      font-weight: 500;
      margin-left: .5rem;
    }
    
    .loading-center {
      text-align: center;
      padding: 2rem;
      color: var(--theme-text-muted);
    }
    
    .error-title {
      font-size: 1.2rem;
      margin-bottom: 1rem;
    }
    
    .error-message {
      font-size: 0.9rem;
    }
    
    .error-hint {
      font-size: 0.8rem;
      margin-top: 0.5rem;
    }
    
    .section-toggle-btn {
      background: none;
      border: 1px solid var(--theme-border);
      border-radius: 4px;
      padding: 4px 8px;
      cursor: pointer;
      color: var(--theme-text);
      font-size: 0.8rem;
    }
    
    .dynamic-weighting-label {
      display: flex;
      align-items: center;
      gap: .4rem;
      cursor: pointer;
      font-weight: 600;
    }
    
    .dynamic-weighting-checkbox {
      transform: scale(1.1);
    }
    #blended-gauge[data-tone="success"] {
      background: var(--success-bg);
      border-color: var(--success);
      box-shadow: 0 0 18px rgba(16, 185, 129, .25);
      /* léger halo vert */
    }

    #blended-gauge[data-tone="warning"] {
      background: var(--warning-bg);
      border-color: var(--warning);
      box-shadow: 0 0 18px rgba(245, 158, 11, .25);
    }

    #blended-gauge[data-tone="danger"] {
      background: var(--danger-bg);
      border-color: var(--danger);
      box-shadow: 0 0 18px rgba(239, 68, 68, .25);
    }

    #blended-gauge[data-tone="info"] {
      background: var(--info-bg);
      border-color: var(--info);
      box-shadow: 0 0 18px rgba(59, 130, 246, .25);
    }


    @media (max-width: 1024px) {
      .dashboard-layout.sidebar-collapsed {
        grid-template-columns: 64px 1fr;
      }
    }

    @media (max-width: 1024px) {
      .dashboard-layout {
        grid-template-columns: 220px 1fr;
        gap: var(--space-md);
      }

      .sidebar {
        max-height: none;
        position: relative;
      }
    }

    .sidebar {
      background: var(--theme-surface);
      border: 1px solid var(--theme-border);
      border-radius: var(--radius-lg);
      padding: var(--space-lg);
      box-shadow: var(--shadow-sm);
      position: sticky;
      top: var(--space-lg);
      max-height: calc(110vh - 110px);
      overflow-y: auto;
    }

    .main-content {
      background: var(--theme-surface);
      border: 1px solid var(--theme-border);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-sm);
    }

    /* ===== Sidebar Components ===== */
    .sidebar-section {
      margin-bottom: var(--space-xl);
    }

    .sidebar-section:last-child {
      margin-bottom: 0;
    }

    .sidebar-title {
      font-size: 0.875rem;
      font-weight: 600;
      color: var(--theme-text-muted);
      margin-bottom: var(--space-sm);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .ccs-gauge {
      text-align: center;
      padding: var(--space-lg);
      background: var(--theme-bg);
      border-radius: var(--radius-md);
      border: 2px solid var(--brand-primary);
    }

    .ccs-score {
      font-size: 2.5rem;
      font-weight: 700;
      color: var(--brand-primary);
      line-height: 1;
      margin-bottom: var(--space-xs);
    }

    .ccs-label {
      font-size: 0.75rem;
      color: var(--theme-text-muted);
      font-weight: 500;
    }

    .status-indicator {
      display: flex;
      align-items: center;
      gap: var(--space-xs);
      padding: var(--space-sm);
      background: var(--theme-bg);
      border-radius: var(--radius-sm);
      margin-bottom: var(--space-sm);
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--theme-text-muted);
    }

    .status-dot.healthy {
      background: var(--success);
    }

    .status-dot.warning {
      background: var(--warning);
    }

    .status-dot.error {
      background: var(--danger);
    }

    .status-text {
      font-size: 0.75rem;
      color: var(--theme-text-muted);
    }

    /* ===== Onglets ===== */
    .tabs {
      display: flex;
      border-bottom: 1px solid var(--theme-border);
      background: var(--theme-bg);
    }

    .tab-button {
      flex: 1;
      padding: var(--space-lg);
      background: none;
      border: none;
      color: var(--theme-text-muted);
      font-weight: 500;
      cursor: pointer;
      transition: all var(--transition-normal);
      border-bottom: 3px solid transparent;
    }

    .tab-button:hover {
      color: var(--theme-text);
      background: var(--theme-surface);
    }

    .tab-button.active {
      color: var(--brand-primary);
      border-bottom-color: var(--brand-primary);
      background: var(--theme-surface);
    }

    .tab-content {
      padding: var(--space-xl);
      min-height: 400px;
    }

    .tab-pane {
      display: none;
    }

    .tab-pane.active {
      display: block;
    }

    /* ===== Risk Components (existants) ===== */
    /* Top summary grid for key points + alerts + recommendations */
    .top-summary {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: var(--space-lg);
      margin: var(--space-xl) 0;
    }

    .top-summary .risk-card h3 {
      margin-bottom: .75rem;
    }

    /* Collapsible container for top summary */
    .top-collapsible {
      background: var(--theme-surface);
      border: 1px solid var(--theme-border);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-sm);
      margin: var(--space-lg) 0;
      overflow: hidden;
    }

    .top-collapsible>summary {
      list-style: none;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: var(--space-md);
      cursor: pointer;
      padding: var(--space-md) var(--space-lg);
      border-bottom: 1px solid var(--theme-border);
      font-weight: 600;
      color: var(--theme-text);
      background: var(--theme-bg);
    }

    .top-collapsible>summary::-webkit-details-marker {
      display: none;
    }

    .summary-right {
      display: inline-flex;
      align-items: center;
      gap: .5rem;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: .25rem;
      font-size: .75rem;
      padding: .25rem .5rem;
      border-radius: 999px;
      border: 1px solid var(--theme-border);
      background: var(--theme-surface);
      color: var(--theme-text);
    }

    .badge-alerts {
      border-color: var(--danger);
      color: var(--danger);
      background: var(--danger-bg);
    }

    .badge-recos {
      border-color: var(--info);
      color: var(--info);
      background: var(--info-bg);
    }

    .chevron {
      font-weight: 700;
      transform: rotate(0deg);
      transition: transform .2s ease;
      opacity: .7;
    }

    .top-collapsible[open] .chevron {
      transform: rotate(90deg);
    }

    .risk-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: var(--space-lg);
      margin: var(--space-lg) 0;
    }

    .risk-card {
      background: var(--theme-surface);
      border: 1px solid var(--theme-border);
      border-radius: var(--radius-lg);
      padding: var(--space-xl);
      box-shadow: var(--shadow-sm);
      transition: all var(--transition-normal);
    }

    .risk-card:hover {
      box-shadow: var(--shadow-md);
      transform: translateY(-2px);
    }

    .risk-card h3 {
      margin-top: 0;
      color: var(--theme-text);
      border-bottom: 2px solid var(--brand-primary);
      padding-bottom: var(--space-sm);
      font-size: 1.25rem;
      font-weight: 600;
    }

    .metric-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: var(--space-sm) 0;
      border-bottom: 1px solid var(--theme-border);
    }

    .metric-label {
      font-weight: 500;
      color: var(--theme-text-muted);
      font-size: 0.875rem;
    }

    .metric-value {
      font-weight: 600;
      font-family: 'Monaco', 'Consolas', monospace;
      color: var(--theme-text);
    }

    .risk-level {
      display: inline-block;
      padding: 0.375rem 0.75rem;
      border-radius: 9999px;
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: .05em;
    }

    .risk-low {
      background: var(--success-bg);
      color: var(--success)
    }

    .risk-medium {
      background: var(--warning-bg);
      color: var(--warning)
    }

    .risk-high,
    .risk-very-high {
      background: var(--danger-bg);
      color: var(--danger)
    }

    .risk-critical {
      background: var(--danger);
      color: #fff
    }

    .alert {
      padding: var(--space-lg);
      margin: var(--space-sm) 0;
      border-radius: var(--radius-md);
      border-left: 4px solid;
    }

    .alert-high {
      background: var(--danger-bg);
      color: var(--danger);
      border-color: var(--danger)
    }

    .alert-medium {
      background: var(--warning-bg);
      color: var(--warning);
      border-color: var(--warning)
    }

    .alert-low {
      background: var(--info-bg);
      color: var(--info);
      border-color: var(--info)
    }

    .correlation-heatmap {
      width: 100%;
      height: 300px;
      background: var(--theme-surface);
      border: 1px solid var(--theme-border);
      border-radius: 4px;
      overflow-x: auto;
    }

    .loading {
      text-align: center;
      padding: 40px;
      color: var(--theme-text-muted);
    }

    .error {
      background: var(--danger-bg);
      color: var(--danger);
      padding: 20px;
      border-radius: 8px;
      border: 1px solid var(--danger);
    }

    .metric-interpretation {
      font-size: 0.8rem;
      color: var(--theme-text-muted);
      padding: 0.5rem 0.75rem;
      margin: 0.25rem 0 0.5rem 0;
      background: var(--theme-surface);
      border-radius: 6px;
      border-left: 3px solid var(--theme-accent);
      font-style: italic;
    }

    .metric-benchmark {
      font-size: 0.75rem;
      color: var(--theme-text-muted);
      padding: 0.5rem 0.75rem;
      margin-top: 0.75rem;
      background: var(--theme-bg);
      border-radius: 6px;
      border: 1px solid var(--theme-border);
    }

    .metric-benchmark strong {
      color: var(--theme-text);
    }

    .recommendation {
      margin: 1rem 0;
      padding: 1rem;
      border-radius: 8px;
      border-left: 4px solid;
    }

    .recommendation-high {
      background: var(--danger-bg);
      border-color: var(--danger);
    }

    .recommendation-medium {
      background: var(--warning-bg);
      border-color: var(--warning);
    }

    .recommendation-low {
      background: var(--success-bg);
      border-color: var(--success);
    }

    .recommendation-header {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-bottom: 0.5rem;
    }

    .recommendation-icon {
      font-size: 1.2rem;
    }

    .recommendation-title {
      font-weight: 600;
      color: var(--theme-text);
      flex: 1;
    }

    .recommendation-priority {
      font-size: 0.7rem;
      padding: 0.25rem 0.5rem;
      background: var(--theme-text);
      color: var(--theme-bg);
      border-radius: 12px;
      font-weight: 600;
      text-transform: uppercase;
    }

    .recommendation-description {
      color: var(--theme-text-muted);
      margin-bottom: 0.5rem;
      font-size: 0.9rem;
    }

    .recommendation-action {
      color: var(--theme-text);
      font-weight: 500;
      font-size: 0.9rem;
    }

    .refresh-btn {
      background: var(--brand-primary);
      color: #fff;
      border: 0;
      padding: .75rem 1.5rem;
      border-radius: var(--radius-md);
      cursor: pointer;
      font-size: .875rem;
      font-weight: 500;
      margin: var(--space-sm);
      transition: all var(--transition-normal);
      display: inline-flex;
      align-items: center;
      gap: var(--space-sm);
    }

    .refresh-btn:hover:not(:disabled) {
      background: var(--brand-primary-hover);
      transform: translateY(-1px);
      box-shadow: var(--shadow-md);
    }

    .refresh-btn:disabled {
      background: var(--theme-border);
      cursor: not-allowed;
      opacity: .5
    }

    .timestamp {
      font-size: .75rem;
      color: var(--theme-text-muted);
      text-align: right;
      margin-bottom: var(--space-sm)
    }

    .controls {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      margin: var(--space-lg) 0;
      flex-wrap: wrap
    }

    /* Split refresh button: visual cohesion */
    .refresh-group { border-radius: var(--radius-md); box-shadow: var(--shadow-sm); }
    .refresh-group .refresh-btn { margin: 0; border-radius: 0; }
    .refresh-group .refresh-btn:first-child { border-top-left-radius: var(--radius-md); border-bottom-left-radius: var(--radius-md); }
    .refresh-group .refresh-btn:last-child { border-top-right-radius: var(--radius-md); border-bottom-right-radius: var(--radius-md); }
    .refresh-group .refresh-btn + .refresh-btn { border-left: 1px solid var(--theme-border); }
    /* Prevent lift on hover causing misalignment within group */
    .refresh-group .refresh-btn:hover:not(:disabled) { transform: none; }

    /* ===== Tooltip (léger, autonome) ===== */
    .tooltip {
      position: fixed;
      z-index: 9999;
      min-width: 260px;
      max-width: 360px;
      pointer-events: none;
      background: #0e1528;
      color: #e9f0ff;
      border: 1px solid #243355;
      border-radius: 10px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, .35);
      padding: 10px 12px;
      opacity: 0;
      transform: translateY(6px);
      transition: opacity .12s ease, transform .12s ease;
    }

    .tooltip.show {
      opacity: 1;
      transform: translateY(0)
    }

    .tooltip .tip-title {
      font-weight: 700;
      margin-bottom: 6px;
      color: #d7e6ff
    }

    .tooltip .tip-body {
      white-space: pre-line;
      color: #c6d6f3;
      font-size: 13px
    }

    /* Indication de survol explicatif */
    .hinted {
      cursor: help;
      text-decoration: underline dotted;
      text-underline-offset: 2px;
    }

    /* Governance Panel - Positioned outside main layout */
    #governance-container {
      margin: var(--space-lg) 0;
      width: 100%;
      max-width: 95vw;
    }

    /* ===== Alerts Display Styles ===== */
    .alert-item {
      display: flex;
      align-items: flex-start;
      gap: var(--space-sm);
      padding: var(--space-sm);
      margin-bottom: var(--space-xs);
      background: var(--theme-surface);
      border-radius: var(--radius-sm);
      border-left: 3px solid var(--theme-border);
      font-size: 0.75rem;
      transition: all var(--transition-normal);
    }

    .alert-item:hover {
      background: var(--theme-bg);
      transform: translateX(2px);
    }

    .alert-item.severity-S1 {
      border-left-color: var(--info);
    }

    .alert-item.severity-S2 {
      border-left-color: var(--warning);
    }

    .alert-item.severity-S3 {
      border-left-color: var(--danger);
    }

    .alert-severity {
      font-weight: 600;
      padding: 2px 6px;
      border-radius: var(--radius-xs);
      font-size: 0.65rem;
      min-width: 20px;
      text-align: center;
    }

    .alert-severity.S1 {
      background: var(--info-light);
      color: var(--info-dark);
    }

    .alert-severity.S2 {
      background: var(--warning-light);
      color: var(--warning-dark);
    }

    .alert-severity.S3 {
      background: var(--danger-light);
      color: var(--danger-dark);
    }

    .alert-content {
      flex: 1;
      line-height: 1.3;
    }

    .alert-type {
      font-weight: 600;
      color: var(--theme-text);
      margin-bottom: 2px;
    }

    .alert-message {
      color: var(--theme-text-muted);
      font-size: 0.7rem;
    }

    .alert-timestamp {
      color: var(--theme-text-muted);
      font-size: 0.65rem;
      margin-top: 2px;
    }

    /* Critical alerts animation */
    .alert-item.severity-S3 {
      animation: pulse-critical 2s infinite;
    }

    @keyframes pulse-critical {
      0% { opacity: 1; }
      50% { opacity: 0.7; }
      100% { opacity: 1; }
    }

    /* Alert actions */
    .alert-actions {
      display: flex;
      gap: 4px;
      margin-top: 4px;
    }

    .alert-action-btn {
      padding: 2px 6px;
      font-size: 0.6rem;
      background: var(--theme-border);
      color: var(--theme-text-muted);
      border: none;
      border-radius: var(--radius-xs);
      cursor: pointer;
      transition: all var(--transition-fast);
    }

    .alert-action-btn:hover {
      background: var(--brand-primary);
      color: white;
    }

    #alerts-list:empty::after {
      content: "No active alerts";
      display: block;
      text-align: center;
      color: var(--theme-text-muted);
      font-size: 0.75rem;
      padding: var(--space-md);
      font-style: italic;
    }

    /* ===== Alerts History Tab Styles ===== */
    .alerts-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: var(--space-lg);
      flex-wrap: wrap;
      gap: var(--space-md);
    }

    .alerts-controls {
      display: flex;
      gap: var(--space-sm);
      align-items: center;
      flex-wrap: wrap;
    }

    .alerts-controls select {
      padding: var(--space-xs) var(--space-sm);
      border: 1px solid var(--theme-border);
      border-radius: var(--radius-sm);
      background: var(--theme-bg);
      color: var(--theme-text);
      font-size: 0.875rem;
    }

    .alerts-table {
      width: 100%;
      border-collapse: collapse;
      margin: var(--space-lg) 0;
      background: var(--theme-bg);
      border-radius: var(--radius-md);
      overflow: hidden;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .alerts-table th {
      background: var(--theme-surface);
      padding: var(--space-md);
      text-align: left;
      font-weight: 600;
      color: var(--theme-text);
      border-bottom: 1px solid var(--theme-border);
      font-size: 0.875rem;
    }

    .alerts-table td {
      padding: var(--space-md);
      border-bottom: 1px solid var(--theme-border);
      vertical-align: top;
      font-size: 0.875rem;
    }

    .alerts-table tr:hover {
      background: var(--theme-surface);
    }

    .alerts-table tr:last-child td {
      border-bottom: none;
    }

    .alert-severity-badge {
      padding: 2px 8px;
      border-radius: var(--radius-xs);
      font-weight: 600;
      font-size: 0.75rem;
      min-width: 24px;
      text-align: center;
      display: inline-block;
    }

    .alert-severity-badge.S1 {
      background: var(--info-light);
      color: var(--info-dark);
    }

    .alert-severity-badge.S2 {
      background: var(--warning-light);
      color: var(--warning-dark);
    }

    .alert-severity-badge.S3 {
      background: var(--danger-light);
      color: var(--danger-dark);
    }

    .alert-type-label {
      font-weight: 500;
      color: var(--theme-text);
    }

    .alert-action-btn {
      background: var(--brand-primary);
      color: white;
      border: none;
      border-radius: var(--radius-sm);
      padding: var(--space-xs) var(--space-sm);
      font-size: 0.75rem;
      cursor: pointer;
      transition: all var(--transition-fast);
      white-space: nowrap;
    }

    .alert-action-btn:hover {
      background: var(--brand-primary-dark);
      transform: translateY(-1px);
    }

    .alert-message-detail {
      color: var(--theme-text-muted);
      font-size: 0.8rem;
      margin-top: 4px;
    }
    
    /* ===== Format Unifié d'Alertes ===== */
    .alert-message-cell {
      max-width: 400px;
      min-width: 300px;
    }
    
    .alert-unified-format {
      font-size: 0.85rem;
      line-height: 1.4;
    }
    
    .alert-action {
      margin-bottom: var(--space-xs);
      color: var(--theme-text);
    }
    
    .alert-action strong {
      color: var(--brand-primary);
      font-weight: 600;
    }
    
    .alert-impact {
      margin-bottom: var(--space-xs);
      color: var(--theme-text-muted);
    }
    
    .alert-impact-value {
      font-weight: 600;
      color: var(--success);
    }
    
    .alert-reasons {
      margin-bottom: var(--space-xs);
      color: var(--theme-text-muted);
    }
    
    .alert-reasons-list {
      margin: 0;
      padding-left: var(--space-md);
      list-style-type: disc;
    }
    
    .alert-reasons-list li {
      margin: 2px 0;
      color: var(--theme-text);
      font-size: 0.8rem;
    }
    
    .alert-details {
      font-size: 0.8rem;
      color: var(--theme-text-muted);
      font-style: italic;
      border-left: 2px solid var(--theme-border);
      padding-left: var(--space-sm);
      margin-top: var(--space-xs);
    }

    .alert-timestamp {
      color: var(--theme-text-muted);
      font-size: 0.8rem;
      white-space: nowrap;
    }

    .alerts-pagination {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: var(--space-md);
      margin-top: var(--space-lg);
      padding: var(--space-md);
    }

    .alerts-pagination button {
      padding: var(--space-xs) var(--space-md);
      border: 1px solid var(--theme-border);
      border-radius: var(--radius-sm);
      background: var(--theme-bg);
      color: var(--theme-text);
      cursor: pointer;
      transition: all var(--transition-fast);
    }

    .alerts-pagination button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .alerts-pagination button:not(:disabled):hover {
      background: var(--brand-primary);
      color: white;
    }

    #alerts-history-content:empty::after {
      content: "No alerts in the selected period";
      display: block;
      text-align: center;
      color: var(--theme-text-muted);
      font-size: 0.875rem;
      padding: var(--space-xl);
      font-style: italic;
    }

    .alerts-stats {
      display: flex;
      gap: var(--space-lg);
      margin-bottom: var(--space-lg);
      flex-wrap: wrap;
    }

    .alerts-stat {
      background: var(--theme-surface);
      padding: var(--space-md);
      border-radius: var(--radius-sm);
      text-align: center;
      min-width: 100px;
    }

    .alerts-stat-number {
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--brand-primary);
    }

    .alerts-stat-label {
      font-size: 0.75rem;
      color: var(--theme-text-muted);
      margin-top: 4px;
    }

    @media (max-width: 768px) {
      .alerts-header {
        flex-direction: column;
        align-items: stretch;
      }

      .alerts-controls {
        justify-content: center;
      }

      .alerts-table {
        font-size: 0.75rem;
      }

      .alerts-table th,
      .alerts-table td {
        padding: var(--space-sm);
      }

      .alerts-stats {
        justify-content: center;
      }
    }

    /* ===== PHASE 2A: Toast Notifications ===== */
    #toast-container {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 1050;
      max-width: 350px;
      pointer-events: none;
    }

    .toast {
      background: var(--theme-surface);
      border: 1px solid var(--theme-border);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-lg);
      margin-bottom: var(--space-sm);
      padding: var(--space-lg);
      position: relative;
      transform: translateX(100%);
      transition: all 0.3s ease-in-out;
      pointer-events: auto;
      min-width: 320px;
    }

    .toast.show {
      transform: translateX(0);
    }

    .toast.hide {
      transform: translateX(100%);
      opacity: 0;
    }

    .toast-s3 {
      border-left: 4px solid var(--danger);
      background: var(--danger-bg);
    }

    .toast-s2 {
      border-left: 4px solid var(--warning);
      background: var(--warning-bg);
    }

    .toast-s1 {
      border-left: 4px solid var(--info);
      background: var(--info-bg);
    }

    .toast-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: var(--space-sm);
      font-weight: 600;
    }

    .toast-severity {
      display: inline-flex;
      align-items: center;
      gap: var(--space-xs);
      font-size: 0.875rem;
      text-transform: uppercase;
      letter-spacing: 0.025em;
    }

    .toast-severity-icon {
      width: 16px;
      height: 16px;
      border-radius: 50%;
    }

    .toast-severity-s3 .toast-severity-icon {
      background: var(--danger);
    }

    .toast-severity-s2 .toast-severity-icon {
      background: var(--warning);
    }

    .toast-severity-s1 .toast-severity-icon {
      background: var(--info);
    }

    .toast-close {
      background: none;
      border: none;
      font-size: 1.2rem;
      cursor: pointer;
      color: var(--theme-text-muted);
      padding: 0;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .toast-close:hover {
      color: var(--theme-text);
    }

    .toast-body {
      font-size: 0.875rem;
      line-height: 1.4;
      color: var(--theme-text);
    }

    .toast-title {
      font-weight: 600;
      margin-bottom: var(--space-xs);
    }

    .toast-description {
      color: var(--theme-text-muted);
      margin-bottom: var(--space-sm);
    }

    .toast-actions {
      display: flex;
      gap: var(--space-sm);
      margin-top: var(--space-sm);
    }

    .toast-action {
      background: var(--brand-primary);
      color: white;
      border: none;
      border-radius: var(--radius-sm);
      padding: var(--space-xs) var(--space-sm);
      font-size: 0.75rem;
      cursor: pointer;
      transition: all var(--transition-fast);
    }

    .toast-action:hover {
      background: var(--brand-primary-dark);
      transform: translateY(-1px);
    }

    .toast-action-secondary {
      background: var(--theme-border);
      color: var(--theme-text);
    }

    .toast-action-secondary:hover {
      background: var(--theme-text-muted);
    }

    /* ===== PHASE 2A: Alert Detail Modal ===== */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(4px);
      z-index: 1100;
      display: none;
      align-items: center;
      justify-content: center;
      padding: var(--space-xl);
    }

    .modal-overlay.show {
      display: flex;
      animation: modalFadeIn 0.2s ease-out;
    }

    @keyframes modalFadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    .modal {
      background: var(--theme-surface);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-xl);
      max-width: 600px;
      width: 100%;
      max-height: 90vh;
      overflow-y: auto;
      transform: scale(0.9);
      transition: all 0.2s ease-out;
    }

    .modal-overlay.show .modal {
      transform: scale(1);
    }

    .modal-header {
      padding: var(--space-xl);
      border-bottom: 1px solid var(--theme-border);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .modal-title {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      margin: 0;
      font-size: 1.25rem;
      font-weight: 600;
    }

    .modal-severity-badge {
      display: inline-flex;
      align-items: center;
      gap: var(--space-xs);
      padding: var(--space-xs) var(--space-sm);
      border-radius: var(--radius-full);
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.025em;
    }

    .modal-severity-s3 {
      background: var(--danger-bg);
      color: var(--danger);
    }

    .modal-severity-s2 {
      background: var(--warning-bg);
      color: var(--warning);
    }

    .modal-severity-s1 {
      background: var(--info-bg);
      color: var(--info);
    }

    .modal-close {
      background: none;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
      color: var(--theme-text-muted);
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: var(--radius-full);
      transition: all var(--transition-fast);
    }

    .modal-close:hover {
      background: var(--theme-border);
      color: var(--theme-text);
    }

    .modal-body {
      padding: var(--space-xl);
    }

    .modal-section {
      margin-bottom: var(--space-xl);
    }

    .modal-section:last-child {
      margin-bottom: 0;
    }

    .modal-section-title {
      font-size: 0.875rem;
      font-weight: 600;
      color: var(--theme-text-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: var(--space-sm);
    }

    .alert-metadata {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: var(--space-sm);
    }

    .metadata-item {
      background: var(--theme-bg-alt);
      border-radius: var(--radius-sm);
      padding: var(--space-sm);
    }

    .metadata-label {
      font-size: 0.75rem;
      color: var(--theme-text-muted);
      font-weight: 500;
      display: block;
      margin-bottom: var(--space-xs);
    }

    .metadata-value {
      font-family: 'Monaco', 'Consolas', monospace;
      font-size: 0.875rem;
      color: var(--theme-text);
      font-weight: 600;
    }

    .signals-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: var(--space-sm);
    }

    .signal-card {
      background: var(--theme-bg-alt);
      border: 1px solid var(--theme-border);
      border-radius: var(--radius-sm);
      padding: var(--space-sm);
    }

    .signal-name {
      font-size: 0.75rem;
      color: var(--theme-text-muted);
      text-transform: uppercase;
      letter-spacing: 0.025em;
      margin-bottom: var(--space-xs);
    }

    .signal-value {
      font-family: 'Monaco', 'Consolas', monospace;
      font-size: 1rem;
      font-weight: 600;
      color: var(--theme-text);
    }

    .suggested-action {
      background: var(--brand-bg);
      border: 1px solid var(--brand-primary);
      border-radius: var(--radius-sm);
      padding: var(--space-lg);
    }

    .action-type {
      font-weight: 600;
      color: var(--brand-primary);
      margin-bottom: var(--space-xs);
    }

    .action-details {
      font-size: 0.875rem;
      color: var(--theme-text);
      line-height: 1.4;
    }

    .modal-actions {
      padding: var(--space-xl);
      border-top: 1px solid var(--theme-border);
      display: flex;
      gap: var(--space-sm);
      justify-content: flex-end;
    }

    .modal-action {
      padding: var(--space-sm) var(--space-lg);
      border-radius: var(--radius-sm);
      font-size: 0.875rem;
      font-weight: 500;
      cursor: pointer;
      transition: all var(--transition-fast);
      border: 1px solid transparent;
    }

    .modal-action-primary {
      background: var(--brand-primary);
      color: white;
    }

    .modal-action-primary:hover {
      background: var(--brand-primary-dark);
    }

    .modal-action-secondary {
      background: var(--theme-surface);
      color: var(--theme-text);
      border-color: var(--theme-border);
    }

    .modal-action-secondary:hover {
      background: var(--theme-bg-alt);
    }

    .modal-action-danger {
      background: var(--danger);
      color: white;
    }

    .modal-action-danger:hover {
      background: var(--danger-dark);
    }

    /* Mobile responsiveness for modals */
    @media (max-width: 768px) {
      .modal-overlay {
        padding: var(--space-sm);
      }
      
      .modal {
        max-height: 95vh;
      }
      
      .modal-header,
      .modal-body,
      .modal-actions {
        padding: var(--space-lg);
      }
      
      .alert-metadata {
        grid-template-columns: 1fr;
      }
      
      .signals-grid {
        grid-template-columns: 1fr;
      }
      
      #toast-container {
        right: 10px;
        left: 10px;
        max-width: none;
      }
      
      .toast {
        min-width: auto;
      }
    }

    /* ===== Toggle Basic/Advanced Mode ===== */
    .mode-toggle {
      display: flex;
      align-items: center;
      gap: var(--space-md);
      margin: var(--space-lg) 0;
      padding: var(--space-md) var(--space-lg);
      background: var(--theme-surface);
      border: 1px solid var(--theme-border);
      border-radius: var(--radius-md);
      box-shadow: var(--shadow-sm);
    }

    .mode-toggle label {
      font-weight: 600;
      color: var(--theme-text);
    }

    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 60px;
      height: 30px;
    }

    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: var(--theme-bg);
      border: 1px solid var(--theme-border);
      transition: 0.3s;
      border-radius: 30px;
    }

    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 22px;
      width: 22px;
      left: 3px;
      bottom: 3px;
      background: var(--theme-text-muted);
      transition: 0.3s;
      border-radius: 50%;
    }

    .toggle-switch input:checked + .toggle-slider {
      background: var(--brand-primary);
      border-color: var(--brand-primary);
    }

    .toggle-switch input:checked + .toggle-slider:before {
      transform: translateX(30px);
      background: white;
    }

    .mode-description {
      font-size: 0.9em;
      color: var(--theme-text-muted);
      margin-left: auto;
    }

    /* Advanced sections initially hidden */
    .advanced-section {
      display: none;
    }

    .advanced-mode .advanced-section {
      display: block;
    }

    .basic-section {
      display: block;
    }

    .advanced-mode .basic-only {
      display: none;
    }

    /* Advanced Risk Components Styles */
    .advanced-risk-panel {
      margin-top: var(--space-lg);
      animation: fadeInUp 0.3s ease-out;
    }

    @keyframes fadeInUp {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .risk-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: var(--space-lg);
      margin-top: var(--space-md);
    }

    .risk-card {
      background: var(--theme-surface);
      border: 1px solid var(--theme-border);
      border-radius: var(--radius-md);
      padding: var(--space-lg);
      box-shadow: var(--shadow-sm);
    }

    .risk-card h4 {
      margin: 0 0 var(--space-md) 0;
      color: var(--theme-text);
      font-size: 1.1em;
      font-weight: 600;
    }

    /* Two-column layout for advanced risk: left stack (3 tiles), right stack (Stress Testing) */
    .two-col-advanced {
      grid-template-columns: 2fr 1fr;
      align-items: start;
    }
    .two-col-advanced .left-stack { display: grid; gap: var(--space-lg); }
    .two-col-advanced .right-stack { display: block; }
    /* Let stress scenarios grow freely in right column */
    .two-col-advanced #stress-test-content .stress-scenarios { max-height: none; overflow: visible; }
    @media (max-width: 1024px) {
      .two-col-advanced { grid-template-columns: 1fr; }
      .two-col-advanced .right-stack { margin-top: var(--space-lg); }
    }

    .var-methods, .stress-scenarios, .monte-carlo-summary {
      display: flex;
      flex-direction: column;
      gap: var(--space-sm);
    }

    /* Keep Stress Testing card compact with internal scroll */
    .stress-scenarios {
      max-height: 340px; /* prevents pushing other tiles */
      overflow: auto;
      padding-right: 4px;
    }

    .var-method, .sim-stat {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: var(--space-sm);
      background: var(--theme-bg);
      border-radius: var(--radius-sm);
    }

    .method-label, .stat-label {
      color: var(--theme-text-muted);
      font-size: 0.9em;
    }

    .var-value, .stat-value {
      font-weight: 600;
      color: var(--theme-text);
    }

    .scenario-card {
      padding: var(--space-md);
      background: var(--theme-bg);
      border-radius: var(--radius-sm);
      border-left: 3px solid var(--brand-warning);
    }

    .scenario-card h5 {
      margin: 0 0 var(--space-sm) 0;
      color: var(--theme-text);
      font-size: 1em;
    }

    .scenario-impact {
      color: var(--theme-text-muted);
      font-size: 0.9em;
    }

    .text-danger {
      color: var(--brand-danger) !important;
    }

    .status-badge {
      padding: var(--space-xs) var(--space-sm);
      border-radius: var(--radius-sm);
      font-size: 0.8em;
      font-weight: 600;
    }

    .status-badge.active {
      background: color-mix(in oklab, var(--brand-success) 20%, transparent);
      color: var(--brand-success);
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      .risk-grid {
        grid-template-columns: 1fr;
      }
      
      .mode-toggle {
        flex-direction: column;
        gap: var(--space-sm);
        text-align: center;
      }
      
      .mode-description {
        margin-left: 0;
      }
    }

    /* Enhanced Stress Test Scenarios Styles */
    .scenarios-header {
      margin-bottom: var(--space-md);
    }

    .scenarios-description {
      color: var(--theme-text-muted);
      font-size: 0.9em;
      margin: 0 0 var(--space-md) 0;
      text-align: center;
    }

    .scenario-card {
      cursor: pointer;
      transition: all 0.2s ease;
      border-left: 3px solid var(--theme-border);
    }

    .scenario-card:hover {
      border-left-color: var(--brand-primary);
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
    }

    .scenario-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: var(--space-xs);
    }

    .scenario-probability {
      font-size: 0.8em;
      background: color-mix(in oklab, var(--brand-info) 20%, transparent);
      color: var(--brand-info);
      padding: var(--space-xs) var(--space-sm);
      border-radius: var(--radius-sm);
      font-weight: 600;
    }

    .scenario-duration {
      color: var(--theme-text-muted);
      font-size: 0.85em;
      margin: var(--space-xs) 0;
    }

    .scenario-context {
      color: var(--theme-text-muted);
      font-size: 0.85em;
      font-style: italic;
      margin-top: var(--space-xs);
    }

    .scenarios-footer {
      display: flex;
      gap: var(--space-md);
      margin-top: var(--space-lg);
      justify-content: center;
    }

    .btn-secondary {
      background: var(--theme-surface);
      border: 1px solid var(--theme-border);
      color: var(--theme-text);
      padding: var(--space-sm) var(--space-md);
      border-radius: var(--radius-sm);
      cursor: pointer;
      font-weight: 500;
      transition: all var(--transition-fast);
    }

    .btn-secondary:hover {
      background: var(--theme-bg);
      border-color: var(--brand-primary);
      color: var(--brand-primary);
    }

    @media (max-width: 768px) {
      .scenario-header {
        flex-direction: column;
        gap: var(--space-xs);
      }
      
      .scenarios-footer {
        flex-direction: column;
      }
    }
    </style>

  <!-- Navigation unifiée (conditionnelle) -->
  <script type="module">
    if (new URLSearchParams(window.location.search).get('nav') !== 'off') {
      import('./components/nav.js');
    }
  </script>
  <script type="module" src="components/tooltips.js"></script>
</head>

<body>
  <div id="backend-fallback-banner" style="display:none; background: color-mix(in oklab, var(--warning) 20%, transparent); border: 1px solid var(--warning); color: var(--theme-text); padding: .6rem; margin: .5rem auto; max-width: 95vw; border-radius: 6px;">
    ⚠ Backend indisponible — mode prudent (cap réduit).
  </div>

  <div class="wrap">
    <!-- Controls Header -->
    <div class="controls">
      <!-- Split refresh button with dropdown -->
      <div class="refresh-group">
        <button class="refresh-btn" id="refresh-btn" title="Actualiser les données">🔄 Refresh</button>
        <button class="refresh-btn refresh-menu-btn" id="refresh-menu-btn" aria-haspopup="true" aria-expanded="false" title="Options de rafraîchissement">▾</button>
        <div id="refresh-menu" class="refresh-menu">
          <button class="refresh-menu-item" id="force-refresh-btn" title="Ignorer le cache et recalculer tous les scores">🧹 Force Refresh</button>
          <button class="refresh-menu-item" id="force-cycle-refresh-btn" title="Vider le cache cycles et recharger uniquement les cycles">🔄 Refresh Cycles</button>
        </div>
      </div>

      <button class="refresh-btn" id="auto-refresh-btn">⏱️ Enable Auto-Refresh (30s)</button>
      <button class="refresh-btn test-api-btn" id="test-endpoint-btn">🧪 Test API</button>
      <div class="timestamp" id="last-update"></div>
    </div>

    <!-- Governance Panel (positioned before main layout) -->
    <div id="governance-container"></div>


    <!-- Layout Hybride: Sidebar + Main -->
    <div class="dashboard-layout">
      <!-- Sidebar Fixe -->
      <div class="sidebar">
        <!-- 🎯 Cockpit Principal - 3 Scores + 1 Synthèse -->

        <!-- Toggle sidebar -->
        <button id="sidebar-toggle" aria-label="Réduire la barre latérale" title="Réduire/agrandir la barre" class="sidebar-toggle-full">
          <span id="sidebar-toggle-icon">⟨⟨</span>
          <span class="sidebar-toggle-text">Réduire</span>
        </button>

        <!-- CCS Mixte (Score Directeur du Marché) -->
        <div class="sidebar-section">
          <div class="sidebar-title">🎯 CCS Mixte (Directeur)</div>
          <div class="ccs-gauge" id="ccs-gauge">
            <div class="ccs-score" id="ccs-ccs-mix" data-score="ccs">--</div>
            <div class="ccs-label" id="ccs-mixte-label">Loading...</div>
          </div>
        </div>

        <!-- On-Chain Composite -->
        <div class="sidebar-section">
          <div class="sidebar-title">🔗 On-Chain Composite</div>
          <div class="ccs-gauge" id="onchain-gauge">
            <div class="ccs-score" id="kpi-onchain" data-score="onchain">--</div>
            <div class="ccs-label" id="onchain-label">Loading...</div>
          </div>
        </div>

        <!-- Risk Score Portfolio -->
        <div class="sidebar-section">
          <div class="sidebar-title">🛡️ Risk Score</div>
          <div class="ccs-gauge" id="risk-gauge">
            <div class="ccs-score" id="kpi-risk" data-score="risk">--</div>
            <div class="ccs-label" id="risk-label">Loading...</div>
          </div>
        </div>

        <!-- Blended Decision Score (Synthèse principale) -->
        <div class="sidebar-section" style="margin-top:1.5rem;">
          <div class="sidebar-title" style="font-size:1rem; font-weight:700;">
            ⚖️ Score Décisionnel
          </div>
          <div class="ccs-gauge decision-card" id="blended-gauge"
            style="padding:2rem; border:2px solid var(--theme-border); box-shadow:0 0 12px rgba(0,0,0,0.15);">
            <div class="ccs-score" id="kpi-blended" data-score="blended" style="font-size:3rem;">--</div>
            <div class="ccs-label" id="blended-label" style="font-size:1rem; font-weight:700;">Loading...</div>
            <div class="ccs-meta" id="blended-meta" style="font-size:.75rem; color: var(--theme-text-muted); margin-top:.25rem;"></div>
          </div>
        </div>


        <!-- Market Regime -->
        <div class="sidebar-section">
          <div class="sidebar-title">📊 Régime de Marché</div>
          <div id="market-regime">
            <div class="status-indicator">
              <div class="status-dot" id="regime-dot"></div>
              <div class="status-text" id="regime-text">Loading market regime...</div>
            </div>
          </div>
        </div>


        <!-- Cycle Indicator -->
        <div class="sidebar-section">
          <div class="sidebar-title">Cycle Position</div>
          <div id="cycle-indicator">
            <div class="status-indicator">
              <div class="status-dot" id="cycle-dot"></div>
              <div class="status-text" id="cycle-text">Loading cycle data...</div>
            </div>
          </div>
        </div>

        <!-- Targets Summary -->
        <div class="sidebar-section">
          <div class="sidebar-title">Target Changes</div>
          <div id="targets-summary">
            <div class="status-text">No changes proposed</div>
          </div>
        </div>

        <!-- API Status -->
        <div class="sidebar-section">
          <div class="sidebar-title">API Health</div>
          <div id="api-status">
            <div class="status-indicator">
              <div class="status-dot" id="backend-dot"></div>
              <div class="status-text">Backend API</div>
            </div>
            <div class="status-indicator">
              <div class="status-dot" id="signals-dot"></div>
              <div class="status-text">Market Signals</div>
            </div>
          </div>
        </div>

        <!-- Governance Status -->
        <div class="sidebar-section">
          <div class="sidebar-title">Governance</div>
          <div id="governance-status">
            <div class="status-indicator">
              <div class="status-dot" id="governance-dot"></div>
              <div class="status-text" id="governance-text">Loading...</div>
            </div>
            <div class="governance-details" id="governance-details" style="margin-top: 8px; font-size: 0.85em; opacity: 0.8;">
              <div id="governance-mode">Mode: manual</div>
              <div id="governance-contradiction">Contradiction: 0.0%</div>
              <div id="governance-constraints" style="font-size:.75rem;color:var(--warning);margin-top:4px;"></div>
            </div>
          </div>
        </div>

        <!-- Active Alerts -->
        <div class="sidebar-section">
          <div class="sidebar-title">🚨 Active Alerts</div>
          <div id="alerts-status">
            <div id="alerts-summary" class="status-indicator">
              <div class="status-dot" id="alerts-dot"></div>
              <div class="status-text" id="alerts-text">Loading alerts...</div>
            </div>
            <div id="alerts-list" style="margin-top: 8px; max-height: 150px; overflow-y: auto;">
              <!-- Alert items will be populated here (limited to 5 most recent) -->
            </div>
            <div style="text-align: center; margin-top: 8px; font-size: 0.75rem;">
              <button onclick="switchTab('alerts')" style="background: var(--brand-primary); color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 0.7rem;">
                📋 View All History
              </button>
            </div>
          </div>
        </div>
      </div>

      <!-- Main Content avec Onglets -->
      <div class="main-content">
        <div class="tabs">
          <button class="tab-button active" data-tab="risk" onclick="switchTab('risk')">Risk Overview</button>
          <button class="tab-button" data-tab="cycles" onclick="switchTab('cycles')">Market Cycles</button>
          <button class="tab-button" data-tab="targets" onclick="switchTab('targets')">Strategic Targets</button>
          <button class="tab-button" data-tab="alerts" onclick="switchTab('alerts')">Alerts History</button>
        </div>

        <div class="tab-content">
          <!-- Risk Overview Tab -->
          <div class="tab-pane active" id="risk-tab">
            <div id="risk-overview-badge-container" style="float: right; margin-bottom: 1rem;"></div>
            <!-- Mode Toggle -->
            <div class="mode-toggle">
              <label for="mode-switch">Basic Mode</label>
              <label class="toggle-switch">
                <input type="checkbox" id="mode-switch" onchange="toggleAdvancedMode()">
                <span class="toggle-slider"></span>
              </label>
              <label for="mode-switch">Advanced Mode</label>
              <span class="mode-description" id="mode-description">
                Essential risk metrics and portfolio overview
              </span>
            </div>

            <!-- Persistent Controls (do not get replaced by dynamic render) -->
            <div id="risk-dashboard-content">
              <div class="loading">Loading risk metrics...</div>
            </div>
          </div>

          <!-- Market Cycles Tab -->
          <div class="tab-pane" id="cycles-tab">
            <div id="cycles-badge-container" style="float: right; margin-bottom: 1rem;"></div>
            <div id="cycles-content">
              <div class="loading">Loading cycle analysis...</div>
            </div>
          </div>

          <!-- Strategic Targets Tab -->
          <div class="tab-pane" id="targets-tab">
            <div id="targets-badge-container" style="float: right; margin-bottom: 1rem;"></div>
            <div id="targets-content">
              <h3>🎯 Strategic Targets</h3>
              <p>Target management will be implemented here...</p>
            </div>
          </div>

          <!-- Alerts History Tab -->
          <div class="tab-pane" id="alerts-tab">
            <div id="alerts-content">
              <div class="alerts-header">
                <h3>🚨 Alerts History</h3>
                <div class="alerts-controls">
                  <select id="alerts-severity-filter" onchange="filterAlertsHistory()">
                    <option value="" selected>All Severities</option>
                    <option value="S1">S1 - Info</option>
                    <option value="S2">S2 - Warning</option>
                    <option value="S3">S3 - Critical</option>
                  </select>
                  <select id="alerts-type-filter" onchange="filterAlertsHistory()">
                    <option value="" selected>All Types</option>
                    <option value="VOL_Q90_CROSS">High Volatility</option>
                    <option value="REGIME_FLIP">Regime Change</option>
                    <option value="CORR_HIGH">High Correlation</option>
                    <option value="CONTRADICTION_SPIKE">ML Contradiction</option>
                    <option value="DECISION_DROP">Low Confidence</option>
                    <option value="EXEC_COST_SPIKE">High Exec Cost</option>
                  </select>
                  <select id="alerts-period-filter" onchange="filterAlertsHistory()">
                    <option value="7">Last 7 days</option>
                    <option value="30">Last 30 days</option>
                    <option value="90">Last 90 days</option>
                  </select>
                  <button class="refresh-btn" onclick="refreshAlertsHistory()">Refresh</button>
                </div>
              </div>
              
              <div id="alerts-history-content">
                <div class="loading">Loading alerts history...</div>
              </div>

              <div class="alerts-pagination" id="alerts-pagination" style="display: none;">
                <button id="alerts-prev-btn" onclick="loadPreviousAlertsPage()" disabled>Previous</button>
                <span id="alerts-page-info">Page 1 of 1</span>
                <button id="alerts-next-btn" onclick="loadNextAlertsPage()" disabled>Next</button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Tooltip partagé -->
  <div id="tooltip" class="tooltip" aria-hidden="true" role="tooltip">
    <div class="tip-title"></div>
    <div class="tip-body"></div>
  </div>

  <script type="module">
    // ⚙️ Unifier l’URL d’import du module (pas de ?v=3 ici)
    import { cycleScoreFromMonths, getCurrentCycleMonths } from './modules/cycle-navigator.js';
    // Note: calibrateCycleParams & getCycleParams seront importés à la volée, ce qui
    // évite tout problème si le bouton est injecté après coup.

    // 🔗 CSP Compliance: Replace inline onclick handlers with event listeners
    document.addEventListener('click', async (e) => {
      // Calibration button (existing)
      const calibrateBtn = e.target?.closest('#btn-calibrate');
      if (calibrateBtn) {
        try {
          const { calibrateCycleParams, getCycleParams } = await import('./modules/cycle-navigator.js');
          const res = calibrateCycleParams(); // ancres par défaut
          console.debug('Cycle params calibrés:', getCycleParams(), 'score=', res.score);
          // ✅ Redessiner le même canvas (force refresh after calibration)
          if (window.Chart) {
            await createBitcoinCycleChart('bitcoin-cycle-chart', true);
          } else {
            console.log('📊 Chart.js not loaded, skipping chart refresh');
          }
          // Also clear cycle content cache as calibration affects data
          const cycleContentConfig = CACHE_CONFIG.CYCLE_CONTENT;
          if (cycleContentConfig) localStorage.removeItem(cycleContentConfig.key);
          window.showToast?.('Cycle calibré sur historiques', 'success');
        } catch (e) {
          console.error(e);
          window.showToast?.('Échec calibration', 'error');
        }
        return;
      }
      
      // Refresh buttons
      if (e.target?.closest('#refresh-btn')) {
        refreshDashboard();
        return;
      }
      
      if (e.target?.closest('#refresh-menu-btn')) {
        toggleRefreshMenu(e);
        return;
      }
      
      if (e.target?.closest('#force-refresh-btn')) {
        closeRefreshMenu();
        refreshDashboard(true);
        return;
      }
      
      if (e.target?.closest('#force-cycle-refresh-btn')) {
        closeRefreshMenu(); 
        forceCycleRefresh();
        return;
      }
      
      if (e.target?.closest('#auto-refresh-btn')) {
        enableAutoRefresh();
        return;
      }
      
      if (e.target?.closest('#test-endpoint-btn')) {
        testEndpoint();
        return;
      }
      
      // View alerts history button
      if (e.target?.closest('[data-action="view-alerts-history"]')) {
        switchTab('alerts');
        return;
      }
    });

    // Helper functions (must be defined first)
    function safeFixed(v, d = 2) { return (v == null || isNaN(v)) ? 'N/A' : Number(v).toFixed(d); }
    function formatPercent(v) { return (v == null || isNaN(v)) ? 'N/A' : (v * 100).toFixed(2) + '%'; }
    function formatNumber(v) {
      if (v == null || isNaN(v)) return 'N/A';
      return new Intl.NumberFormat('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 }).format(v);
    }
    function formatMoney(usd) {
      const cur = (window.globalConfig && window.globalConfig.get('display_currency')) || 'USD';
      const rate = (window.currencyManager && window.currencyManager.getRateSync(cur)) || 1;
      if (cur !== 'USD' && (!rate || rate <= 0)) return '—';
      const v = (usd == null || isNaN(usd)) ? 0 : (usd * rate);
      try {
        const dec = (cur === 'BTC') ? 8 : 2;
        const out = new Intl.NumberFormat('fr-FR', { style: 'currency', currency: cur, minimumFractionDigits: dec, maximumFractionDigits: dec }).format(v);
        return (cur === 'USD') ? out.replace(/\s?US$/,'') : out;
      } catch (_) {
        return `${v.toFixed(cur==='BTC'?8:2)} ${cur}`;
      }
    }

    // Import core modules
    import { store } from './core/risk-dashboard-store.js';
    import { fetchCached, clearCache } from './core/fetcher.js';

    // Import CCS modules
    import { fetchAndComputeCCS, interpretCCS, DEFAULT_CCS_WEIGHTS } from './modules/signals-engine.js';
    import { estimateCyclePosition, blendCCS, getCyclePhase } from './modules/cycle-navigator.js';
    import { proposeTargets, applyTargets, computePlan, DEFAULT_MACRO_TARGETS, getDecisionLog } from './modules/targets-coordinator.js';
    import { fetchAllIndicators, calculateCompositeScore, enhanceCycleScore } from './modules/onchain-indicators.js';
    import { calculateCompositeScoreV2, analyzeContradictorySignals } from './modules/composite-score-v2.js';
    import { getMarketRegime, applyMarketOverrides, calculateRiskBudget, getRegimeDisplayData } from './modules/market-regimes.js';

    // Global state
    let autoRefreshInterval = null;
    let isRefreshing = false;

    // Variables pour les scores
    let onchainScore = null;
    let riskScore = null;
    let blendedScore = null;

    // Re-render on currency change (ensure rate then refresh)
    window.addEventListener('configChanged', (ev) => {
      const key = ev?.detail?.key;
      if (key === 'display_currency') {
        const cur = (window.globalConfig && window.globalConfig.get('display_currency')) || 'USD';
        const rerender = () => { try { refreshDashboard(true); } catch(_){} };
        if (window.currencyManager && cur !== 'USD') {
          window.currencyManager.ensureRate(cur).then(rerender).catch(rerender);
        } else {
          rerender();
        }
      }
    });

    // Fonction pour charger les paramètres de calibration depuis localStorage
    function loadCalibrationParams() {
      try {
        const saved = localStorage.getItem('bitcoin_cycle_params');
        if (saved) {
          const data = JSON.parse(saved);
          // Vérifier que les données ne sont pas trop anciennes (24h)
          if (Date.now() - data.timestamp < 24 * 60 * 60 * 1000) {
            console.debug('✅ Paramètres calibrés chargés depuis localStorage', data.params);
            return data.params;
          }
        }
      } catch (error) {
        console.error('❌ Erreur chargement paramètres:', error);
      }
      return null;
    }

    // Écouter les mises à jour de paramètres depuis d'autres pages
    window.addEventListener('message', (event) => {
      if (event.data.type === 'CYCLE_PARAMS_UPDATED') {
        console.debug('🔄 Paramètres de cycle mis à jour depuis autre page');
        // Recharger les données avec les nouveaux paramètres
        setTimeout(refreshDashboard, 1000);
      }
    });

    // Track current data source to detect changes
    let lastKnownDataSource = globalConfig.get('data_source');
    console.debug(`📊 Risk Dashboard initialized with data source: ${lastKnownDataSource}`);

    // Listen for data source changes from settings
    window.addEventListener('storage', function(e) {
      const expectedKey = (window.globalConfig?.getStorageKey && window.globalConfig.getStorageKey()) || 'crypto_rebal_settings_v1';
      if (e.key === expectedKey) {
        console.debug('Settings changed in another tab, checking for data source changes...');
        
        const currentSource = globalConfig.get('data_source');
        if (currentSource && currentSource !== lastKnownDataSource) {
          console.debug(`🔄 Data source changed from ${lastKnownDataSource} to ${currentSource}, auto-refreshing...`);
          lastKnownDataSource = currentSource;
          // Clear cache when source changes
          clearAllPersistentCache();
          setTimeout(() => refreshDashboard(true), 500); // Force refresh to recalculate with new source
        }
      }
    });

    // Listen for explicit data source change events
    window.addEventListener('dataSourceChanged', (event) => {
      console.debug(`🔄 Explicit data source change: ${event.detail.oldSource} → ${event.detail.newSource}`);
      lastKnownDataSource = event.detail.newSource;
      // Clear cache when source changes
      clearAllPersistentCache();
      setTimeout(() => refreshDashboard(true), 500); // Force refresh to recalculate with new source
    });

    // ====== Tab Management ======
    window.switchTab = function (tabName) {
      // Update UI state
      document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
      document.querySelectorAll('.tab-pane').forEach(pane => pane.classList.remove('active'));

      document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
      document.getElementById(`${tabName}-tab`).classList.add('active');

      // Update store
      store.set('ui.activeTab', tabName);

      // Render content based on active tab
      switch (tabName) {
        case 'risk':
          // Risk content is already rendered by refreshDashboard
          break;
        case 'cycles':
          // Always render cycles content when tab is activated
          renderCyclesContent();
          break;
        case 'targets':
          renderTargetsContent().catch(err => console.error('Failed to render targets:', err));
          break;
        case 'alerts':
          initializeAlertsTab();
          break;
      }

      console.debug(`Switched to tab: ${tabName}`);
    };

    // ====== Tooltip helpers ======
    const $tip = document.getElementById('tooltip');
    const $tipTitle = $tip?.querySelector('.tip-title');
    const $tipBody = $tip?.querySelector('.tip-body');

    function showTip(title, body, x, y) {
      if (!$tip) return;
      $tipTitle.textContent = title || '';
      $tipBody.textContent = body || '';
      $tip.style.left = x + 'px';
      $tip.style.top = y + 'px';
      $tip.classList.add('show');
      $tip.setAttribute('aria-hidden', 'false');
    }

    function moveTip(x, y) {
      if (!$tip) return;
      $tip.style.left = x + 'px';
      $tip.style.top = y + 'px';
    }

    function hideTip() {
      if (!$tip) return;
      $tip.classList.remove('show');
      $tip.setAttribute('aria-hidden', 'true');
    }

    function attachTip(el, title, body) {
      if (!el) return;
      el.addEventListener('mouseenter', e => showTip(title, body, e.clientX, e.clientY));
      el.addEventListener('mousemove', e => moveTip(e.clientX, e.clientY));
      el.addEventListener('mouseleave', hideTip);
      el.classList.add('hinted');
    }

    // ====== Formatters ======
    const pct = v => (v == null || isNaN(v) ? 'N/A' : (v * 100).toFixed(2) + '%');
    const num = v => (v == null || isNaN(v) ? 'N/A' : Number(v).toFixed(2));

    // ====== Analysis Window Slider ======
    // Fixed windows
    const analysisDays = 365;
    const corrDays = 90;
    function updateWindowLabel(v) {
      const lbl = document.getElementById('window-label');
      if (lbl) lbl.textContent = `${v} jours`;
    }
    // Removed old controls

    // ====== API Functions ======
    async function fetchRiskData() {
      try {
        // Get the configured data source dynamically
        const dataSource = globalConfig.get('data_source');
        const apiBaseUrl = globalConfig.get('api_base_url');
        const minUsd = globalConfig.get('min_usd_threshold');

        console.debug(`🔍 Risk Overview using data source: ${dataSource}`);

        // Use globalConfig to build the API URL with the configured source
        const url = globalConfig.getApiUrl('/balances/current', { min_usd: minUsd });

        // Utiliser directement les données de balance et calculer le risque côté client
        const balanceResult = await fetchCached(
          `risk-dashboard-balance:${(localStorage.getItem('activeUser')||'demo')}:${dataSource}:${minUsd}`,
          () => window.globalConfig.apiRequest('/balances/current', { params: { min_usd: minUsd } }),
          'risk'
        );

        // Use the real backend endpoint for risk dashboard
        const apiResult = await window.globalConfig.apiRequest('/api/risk/dashboard', {
          params: { min_usd: minUsd, price_history_days: analysisDays, lookback_days: corrDays }
        });
        // Inclure les balances pour calculer concentration/stablecoins côté UI
        try {
          apiResult.balances = Array.isArray(balanceResult?.items) ? balanceResult.items : [];
        } catch (_) { /* ignore */ }
        console.log(`📊 Real risk metrics calculated: VaR 95%: ${(apiResult.risk_metrics.var_95_1d * 100).toFixed(2)}%, Sharpe: ${apiResult.risk_metrics.sharpe_ratio.toFixed(2)}`);

        // The backend already provides the correct structure, just return it
        return apiResult;
      } catch (error) {
        console.warn('Risk API unavailable:', error);
        return {
          success: false,
          message: 'Backend de risque indisponible. Assurez-vous que le serveur backend est démarré.',
          error_type: 'connection_error'
        };
      }
    }

    // NOTE: getMockRiskData() supprimée - plus de données simulées

    // CSV parsing functions are now centralized in global-config.js

    // NOTE: calculateRealRiskMetrics() supprimée - métriques calculées par le backend Python

    // ====== Metric Health Evaluation & Interpretation ======
    function getMetricHealth(key, value) {
      const healthRules = {
        'var_95_1d': {
          good: [0, 0.04], // 0% to 4%
          warning: [0.04, 0.08], // 4% to 8%
          danger: [0.08, 1], // > 8%
          interpretation: {
            good: "Perte journalière potentielle contenue",
            warning: "Perte potentielle modérée",
            danger: "Perte potentielle élevée - attention"
          }
        },
        'var_99_1d': {
          good: [0, 0.06],
          warning: [0.06, 0.12],
          danger: [0.12, 1],
          interpretation: {
            good: "Perte extrême limitée",
            warning: "Perte extrême modérée",
            danger: "Perte extrême importante"
          }
        },
        'sharpe_ratio': {
          danger: [0, 0.5],
          warning: [0.5, 1.0],
          good: [1.0, 5.0],
          interpretation: {
            danger: "Rendement/risque insuffisant",
            warning: "Rendement/risque acceptable",
            good: "Excellent rendement ajusté au risque"
          }
        },
        'sortino_ratio': {
          danger: [0, 0.8],
          warning: [0.8, 1.2],
          good: [1.2, 5.0],
          interpretation: {
            danger: "Protection baisse insuffisante",
            warning: "Protection baisse correcte",
            good: "Excellente protection contre les baisses"
          }
        },
        'volatility_annualized': {
          good: [0, 0.4], // 0-40%
          warning: [0.4, 0.8], // 40-80%
          danger: [0.8, 2.0], // >80%
          interpretation: {
            good: "Volatilité faible",
            warning: "Volatilité modérée",
            danger: "Volatilité élevée"
          }
        },
        'max_drawdown': {
          good: [0, 0.3], // 0% to 30%
          warning: [0.3, 0.6], // 30% to 60%
          danger: [0.6, 1.0], // > 60%
          interpretation: {
            good: "Drawdown limité",
            warning: "Drawdown crypto typique",
            danger: "Drawdown extrême - diversifier"
          }
        },
        'diversification_ratio': {
          danger: [0, 0.4],
          warning: [0.4, 0.7],
          good: [0.7, 2.0], // >1 possible si corrélations négatives
          interpretation: {
            danger: "Très peu diversifié",
            warning: "Diversification limitée",
            good: "Bien diversifié (corrélations faibles ou négatives)"
          }
        },
        'effective_assets': {
          danger: [0, 10],
          warning: [10, 20],
          good: [20, 999],
          interpretation: {
            danger: "Très peu d'actifs effectifs",
            warning: "Diversification partielle",
            good: "Bonne diversification"
          }
        }
      };

      const rule = healthRules[key];
      if (!rule) return { level: 'unknown', color: '#6b7280', interpretation: 'Métrique non évaluée' };

      // Check which range the value falls into
      for (const [level, range] of Object.entries(rule)) {
        if (level === 'interpretation') continue;

        const [min, max] = range;
        if (value >= min && value <= max) {
          const color = level === 'good' ? '#10b981' : level === 'warning' ? '#f59e0b' : '#ef4444';
          return {
            level,
            color,
            interpretation: rule.interpretation[level] || 'Pas d\'interprétation disponible'
          };
        }
      }

      return { level: 'unknown', color: '#6b7280', interpretation: 'Valeur hors limites' };
    }

    function getContextualBenchmark(key, value) {
      const benchmarks = {
        'var_95_1d': {
          crypto_conservative: 0.04,
          crypto_typical: 0.07,
          crypto_aggressive: 0.12,
          traditional: 0.02
        },
        'sharpe_ratio': {
          crypto_excellent: 1.5,
          crypto_good: 1.0,
          crypto_acceptable: 0.5,
          traditional_good: 1.0
        },
        'volatility_annualized': {
          crypto_low: 0.4,
          crypto_typical: 0.6,
          crypto_high: 1.0,
          traditional: 0.2
        },
        'max_drawdown': {
          crypto_good: -0.3,
          crypto_typical: -0.5,
          crypto_extreme: -0.8,
          traditional: -0.2
        }
      };

      return benchmarks[key] || {};
    }

    function generateRecommendations(metrics, correlations, groups) {
      const recommendations = [];

      // VaR recommendations (VaR renvoyé en valeur positive)
      if (metrics.var_95_1d > 0.08) {
        recommendations.push({
          priority: 'high',
          icon: '🛡️',
          title: 'Réduire le risque de perte journalière',
          description: 'Votre VaR de ' + formatPercent(metrics.var_95_1d) + ' est élevé. Augmentez la part de stablecoins ou Bitcoin.',
          action: 'Ciblez 15-25% de stablecoins pour stabiliser le portfolio'
        });
      }

      // Sharpe ratio recommendations
      if (metrics.sharpe_ratio < 1.0) {
        recommendations.push({
          priority: 'medium',
          icon: '📈',
          title: 'Améliorer le rendement ajusté au risque',
          description: 'Sharpe ratio de ' + safeFixed(metrics.sharpe_ratio) + ' - cherchez des actifs avec meilleur ratio risque/rendement.',
          action: 'Considérez réduire les memecoins, augmenter BTC/ETH'
        });
      }

      // Diversification recommendations (alignée aux seuils UI)
      if (correlations.diversification_ratio < 0.4) {
        recommendations.push({
          priority: 'high',
          icon: '🔄',
          title: 'Améliorer la diversification',
          description: 'Ratio de diversification très faible (' + safeFixed(correlations.diversification_ratio) + '). Portfolio trop corrélé.',
          action: 'Ajoutez des actifs décorrélés: privacy coins, stablecoins, secteurs différents'
        });
      } else if (correlations.diversification_ratio < 0.7) {
        recommendations.push({
          priority: 'medium',
          icon: '🔄',
          title: 'Améliorer la diversification',
          description: 'Diversification limitée (' + safeFixed(correlations.diversification_ratio) + ').',
          action: 'Élargissez les secteurs et réduisez les paires très corrélées'
        });
      }

      // Effective assets recommendations  
      if (correlations.effective_assets < 3) {
        recommendations.push({
          priority: 'medium',
          icon: '⚖️',
          title: 'Réduire la concentration',
          description: 'Portfolio se comporte comme ' + safeFixed(correlations.effective_assets, 1) + ' actifs seulement.',
          action: 'Rééquilibrez: limitez tout actif à <20% du portfolio'
        });
      }

      // Drawdown recommendations (max_drawdown renvoyé en valeur positive)
      if (metrics.max_drawdown > 0.6) {
        recommendations.push({
          priority: 'high',
          icon: '📉',
          title: 'Protéger contre les chutes extrêmes',
          description: 'Max drawdown de ' + formatPercent(metrics.max_drawdown) + ' très élevé.',
          action: 'Stratégie défensive: DCA, stop-loss, ou hedging avec stablecoins'
        });
      }

      // High correlation recommendations
      if (correlations.top_correlations) {
        const highCorrels = correlations.top_correlations.filter(c => Math.abs(c.correlation) > 0.75);
        if (highCorrels.length > 0) {
          recommendations.push({
            priority: 'medium',
            icon: '🔗',
            title: 'Réduire les corrélations élevées',
            description: 'Corrélations >75% détectées entre ' + highCorrels.map(c => c.asset1 + '-' + c.asset2).join(', '),
            action: 'Diversifiez vers des secteurs moins corrélés (BTC vs ETH vs secteurs niche)'
          });
        }
      }

      // If everything is good, add positive reinforcement
      if (recommendations.length === 0) {
        recommendations.push({
          priority: 'low',
          icon: '✅',
          title: 'Portfolio bien équilibré',
          description: 'Vos métriques de risque sont dans les normes crypto acceptables.',
          action: 'Continuez le monitoring et ajustez selon les conditions de marché'
        });
      }

      // Sort by priority
      const priorityOrder = { 'high': 0, 'medium': 1, 'low': 2 };
      return recommendations.sort((a, b) => priorityOrder[a.priority] - priorityOrder[b.priority]);
    }

    // NOTE: calculateCorrelationMetrics() supprimée - corrélations calculées par le backend Python

    // Asset grouping function - HARMONISÉ avec les 11 groupes du targets-coordinator
    const ASSET_GROUPS = {
      'BTC': ['BTC', 'TBTC'], // Bitcoin et dérivés
      'ETH': ['ETH', 'WETH', 'STETH', 'WSTETH', 'RETH', 'CBETH'], // Ethereum et liquid staking
      'Stablecoins': ['USDC', 'USDT', 'USD', 'DAI', 'USTC'], // Stablecoins
      'SOL': ['SOL2', 'JUPSOL', 'JITOSOL'], // SOL ecosystem (groupe séparé)
      'L1/L0 majors': ['ATOM2', 'DOT2', 'ADA', 'AVAX', 'NEAR', 'BCH', 'XLM', 'LTC', 'SUI3', 'TRX', 'VET', 'XTZ', 'EGLD3', 'ETC', 'TONCOIN', 'XNO2', 'NEO', 'ICP2', 'BNB', 'BGB', 'CHSB', 'CRO'], // Layer 1 blockchains majors + Exchange tokens
      'L2/Scaling': ['POL3', 'IMX2', 'LRC', 'THETA2'], // Layer 2 et solutions de scalabilité
      'DeFi': ['AAVE', 'SUSHI', 'LDO', 'UNI2', 'COMP', 'YFI', 'ZRX', 'ORCA', 'JUP2', 'LINK', 'GRT'], // DeFi tokens
      'AI/Data': ['RENDER', 'TAO6', 'FET'], // AI and Data tokens
      'Gaming/NFT': ['GALA', 'MANA', 'SAND', 'CHZ'], // Gaming and NFT
      'Memecoins': ['DOGE', 'SHIB', 'PEPE4', 'BONK'], // Meme tokens
      'Others': ['XRP', 'XMR', 'IMO', 'VVV3', 'S5', 'INJ2', 'ERA', 'CFG', 'PAXG', 'OXT', 'CAKE', 'PENGU7', 'BAT', 'SUN2', 'ZEC', 'DYDX', 'GNO', 'KSM', 'ALGO', 'GHST', 'BNT', 'QTUM', 'SCRT', 'ARPA', 'SAGA3', 'BNKR', 'IOTA2', 'EUR', 'LUNA2', 'KAVA', 'JMPT', 'WLD3', 'AKT', 'SFP', 'ZIL', 'ROSE', 'EWT', 'DOGI3', 'ANKR', 'RIF', 'XVG', 'REN', 'ATR', 'ENA', 'HEI2', 'LCX', 'GMT5', 'KNC', 'FIL', 'TIA3', 'VTHO', 'HTM', 'DIAMOND', 'RPL', 'HBAR', 'EIGEN'] // Tous les autres assets
    };

    function groupAssetsByAliases(items) {
      const groups = new Map();
      const ungrouped = [];

      console.debug('🔍 DEBUG Risk Dashboard: Grouping', items.length, 'assets by aliases');

      items.forEach(item => {
        const symbol = (item.symbol || '').toUpperCase();
        let foundGroup = null;

        // Chercher dans quel groupe appartient ce symbol
        for (const [groupName, aliases] of Object.entries(ASSET_GROUPS)) {
          if (aliases.includes(symbol)) {
            foundGroup = groupName;
            break;
          }
        }

        if (foundGroup) {
          if (!groups.has(foundGroup)) {
            groups.set(foundGroup, {
              label: foundGroup,
              value: 0,
              assets: []
            });
          }
          const group = groups.get(foundGroup);
          group.value += parseFloat(item.value_usd || 0);
          group.assets.push(symbol);

          // Debug log for significant groupings
          if (item.value_usd > 5000) {
            console.debug('🔍 DEBUG Risk Dashboard: Grouped', symbol, 'into', foundGroup, '- value:', item.value_usd.toFixed(2));
          }
        } else {
          ungrouped.push({
            label: symbol,
            value: parseFloat(item.value_usd || 0)
          });

          // Debug log for ungrouped assets
          if (item.value_usd > 1000) {
            console.debug('⚠️ DEBUG Risk Dashboard: UNGROUPED asset:', symbol, '- value:', item.value_usd.toFixed(2));
          }
        }
      });

      console.debug('🔍 DEBUG Risk Dashboard: Final groups:', groups.size, 'grouped +', ungrouped.length, 'ungrouped');
      const result = [...Array.from(groups.values()), ...ungrouped];

      return result;
    }

    // ====== CCS Functions ======
    async function loadCCSData() {
      try {
        console.debug('Loading CCS data...');

        // Fetch CCS and cycle data in parallel
        const [ccsResult, cycleData] = await Promise.all([
          fetchAndComputeCCS(DEFAULT_CCS_WEIGHTS),
          estimateCyclePosition()
        ]);

        // Update store with CCS data
        store.set('ccs.score', ccsResult.score);
        store.set('ccs.signals', ccsResult.signals);
        store.set('ccs.weights', ccsResult.weights);
        store.set('ccs.lastUpdate', new Date().toISOString());
        store.set('ccs.model_version', ccsResult.model_version);

        // Update store with cycle data
        store.set('cycle.months', cycleData.months);
        store.set('cycle.phase', cycleData.phase);
        store.set('cycle.score', cycleData.score);
        store.set('cycle.confidence', cycleData.confidence);
        store.set('cycle.multipliers', cycleData.multipliers);

        // Update API status
        store.set('ui.apiStatus.signals', 'healthy');

        console.debug(`CCS loaded: ${ccsResult.score}, Cycle: ${cycleData.phase.phase} (${Math.round(cycleData.months)}m)`);

        return { ccs: ccsResult, cycle: cycleData };

      } catch (error) {
        console.error('Failed to load CCS data:', error);
        store.set('ui.apiStatus.signals', 'error');
        throw error;
      }
    }

    async function loadBlendedCCS() {
      try {
        const state = store.snapshot();
        const ccsScore = state.ccs?.score;
        const cycleMonths = state.cycle?.months;
        const cycleWeight = state.cycle?.weight || 0.3;

        if (ccsScore && cycleMonths) {
          const blended = blendCCS(ccsScore, cycleMonths, cycleWeight);
          store.set('cycle.ccsStar', blended.blendedCCS);
          return blended;
        }

        return null;
      } catch (error) {
        console.error('Failed to blend CCS:', error);
        return null;
      }
    }

    // ====== Alerts Functions ======
    async function fetchAlertsData() {
      try {
        console.debug('Loading alerts data...');
        
        const alertsData = await window.globalConfig.apiRequest('/api/alerts/active', {
          params: { include_snoozed: false }
        });
        console.debug(`Alerts loaded: ${alertsData.length} active alerts`);
        
        return alertsData;
        
      } catch (error) {
        console.error('Failed to load alerts data:', error);
        throw error;
      }
    }
    
    function updateAlertsDisplay(alertsData) {
      const alertsDot = document.getElementById('alerts-dot');
      const alertsText = document.getElementById('alerts-text');
      const alertsList = document.getElementById('alerts-list');
      
      if (!alertsDot || !alertsText || !alertsList) {
        console.warn('Alerts display elements not found');
        return;
      }
      
      if (!alertsData || alertsData.length === 0) {
        // No alerts
        alertsDot.className = 'status-dot healthy';
        alertsText.textContent = 'No active alerts';
        alertsList.replaceChildren(); // CSP safe replacement for innerHTML = ''
        
        // Always show the "View All History" button even when no active alerts
        const historyButton = document.createElement('div');
        historyButton.className = 'alerts-button-container';
        
        const viewHistoryBtn = document.createElement('button');
        viewHistoryBtn.className = 'alerts-history-btn';
        viewHistoryBtn.textContent = '📋 View All History';
        viewHistoryBtn.setAttribute('data-action', 'view-alerts-history');
        
        historyButton.appendChild(viewHistoryBtn);
        alertsList.appendChild(historyButton);
        return;
      }
      
      // Count alerts by severity
      const severityCounts = { S1: 0, S2: 0, S3: 0 };
      alertsData.forEach(alert => {
        if (severityCounts.hasOwnProperty(alert.severity)) {
          severityCounts[alert.severity]++;
        }
      });
      
      // Set status based on highest severity
      let statusClass = 'healthy';
      let statusText = `${alertsData.length} alert${alertsData.length > 1 ? 's' : ''}`;
      
      if (severityCounts.S3 > 0) {
        statusClass = 'error';
        statusText = `${severityCounts.S3} critical alert${severityCounts.S3 > 1 ? 's' : ''}`;
      } else if (severityCounts.S2 > 0) {
        statusClass = 'warning';
        statusText = `${severityCounts.S2} warning alert${severityCounts.S2 > 1 ? 's' : ''}`;
      }
      
      alertsDot.className = `status-dot ${statusClass}`;
      alertsText.textContent = statusText;
      
      // Render alerts list
      alertsList.replaceChildren(); // CSP safe replacement for innerHTML = ''
      
      // Sort alerts by severity (S3, S2, S1) and creation time
      const sortedAlerts = [...alertsData].sort((a, b) => {
        const severityOrder = { S3: 0, S2: 1, S1: 2 };
        const severityDiff = severityOrder[a.severity] - severityOrder[b.severity];
        if (severityDiff !== 0) return severityDiff;
        
        // Then by creation time (newest first)
        return new Date(b.created_at) - new Date(a.created_at);
      });
      
      // Limit to 5 most important alerts in sidebar
      sortedAlerts.slice(0, 5).forEach(alert => {
        const alertItem = createAlertItem(alert);
        alertsList.appendChild(alertItem);
      });
      
      // Add "show more" indicator if there are more alerts
      if (sortedAlerts.length > 5) {
        const moreItem = document.createElement('div');
        moreItem.style.textAlign = 'center';
        moreItem.style.padding = '4px';
        moreItem.style.fontSize = '0.7rem';
        moreItem.style.color = 'var(--theme-text-muted)';
        moreItem.textContent = `+${sortedAlerts.length - 5} more alerts...`;
        alertsList.appendChild(moreItem);
      }
    }
    
    function createAlertItem(alert) {
      const item = document.createElement('div');
      item.className = `alert-item severity-${alert.severity}`;
      
      const severity = document.createElement('div');
      severity.className = `alert-severity ${alert.severity}`;
      severity.textContent = alert.severity;
      
      const content = document.createElement('div');
      content.className = 'alert-content';
      
      const type = document.createElement('div');
      type.className = 'alert-type';
      type.textContent = formatAlertType(alert.alert_type);
      
      const message = document.createElement('div');
      message.className = 'alert-message';
      message.textContent = formatAlertMessage(alert);
      
      const timestamp = document.createElement('div');
      timestamp.className = 'alert-timestamp';
      timestamp.textContent = formatRelativeTime(alert.created_at);
      
      content.appendChild(type);
      content.appendChild(message);
      content.appendChild(timestamp);
      
      // Add action buttons for major alerts
      if (alert.severity === 'S2' || alert.severity === 'S3') {
        const actions = document.createElement('div');
        actions.className = 'alert-actions';
        
        const ackButton = document.createElement('button');
        ackButton.className = 'alert-action-btn';
        ackButton.textContent = 'Ack';
        ackButton.title = 'Acknowledge alert';
        ackButton.onclick = () => acknowledgeAlert(alert.id);
        
        const snoozeButton = document.createElement('button');
        snoozeButton.className = 'alert-action-btn';
        snoozeButton.textContent = 'Snooze';
        snoozeButton.title = 'Snooze for 30 minutes';
        snoozeButton.onclick = () => snoozeAlert(alert.id, 30);
        
        actions.appendChild(ackButton);
        actions.appendChild(snoozeButton);
        content.appendChild(actions);
      }
      
      item.appendChild(severity);
      item.appendChild(content);
      
      return item;
    }
    
    function formatAlertType(alertType) {
      const typeMap = {
        'VOL_Q90_CROSS': 'High Volatility',
        'REGIME_FLIP': 'Regime Change',
        'CORR_HIGH': 'High Correlation',
        'CONTRADICTION_SPIKE': 'ML Contradiction',
        'DECISION_DROP': 'Low Confidence',
        'EXEC_COST_SPIKE': 'High Exec Cost'
      };
      
      return typeMap[alertType] || alertType;
    }
    
    function formatAlertMessage(alert) {
      if (alert.data && typeof alert.data === 'object') {
        // Extract meaningful data from alert
        if (alert.data.value !== undefined) {
          return `Value: ${(alert.data.value * 100).toFixed(1)}%`;
        }
        if (alert.data.confidence !== undefined) {
          return `Confidence: ${(alert.data.confidence * 100).toFixed(1)}%`;
        }
      }
      
      return alert.suggested_action?.reason || 'Alert triggered';
    }
    
    function formatRelativeTime(timestamp) {
      const now = new Date();
      const alertTime = new Date(timestamp);
      const diffMs = now - alertTime;
      const diffMins = Math.floor(diffMs / 60000);
      
      if (diffMins < 1) return 'Just now';
      if (diffMins < 60) return `${diffMins}m ago`;
      
      const diffHours = Math.floor(diffMins / 60);
      if (diffHours < 24) return `${diffHours}h ago`;
      
      const diffDays = Math.floor(diffHours / 24);
      return `${diffDays}d ago`;
    }
    
    async function acknowledgeAlert(alertId) {
      try {
        const response = await window.globalConfig.apiRequest(`/api/alerts/test/acknowledge/${alertId}`, {
          method: 'POST',
          body: JSON.stringify({ notes: 'Acknowledged from dashboard' })
        });
        
        if (response && (response.ok || response.success || !response.error)) {
          // Refresh alerts display
          const alertsData = await fetchAlertsData();
          updateAlertsDisplay(alertsData);
          console.log(`Alert ${alertId} acknowledged`);
        } else {
          console.error('Failed to acknowledge alert:', response.status);
        }
      } catch (error) {
        console.error('Error acknowledging alert:', error);
      }
    }
    
    async function snoozeAlert(alertId, minutes) {
      try {
        const response = await window.globalConfig.apiRequest(`/api/alerts/test/snooze/${alertId}`, {
          method: 'POST',
          body: JSON.stringify({ minutes })
        });
        
        if (response && (response.ok || response.success || !response.error)) {
          // Refresh alerts display
          const alertsData = await fetchAlertsData();
          updateAlertsDisplay(alertsData);
          console.log(`Alert ${alertId} snoozed for ${minutes} minutes`);
        } else {
          console.error('Failed to snooze alert:', response.status);
        }
      } catch (error) {
        console.error('Error snoozing alert:', error);
      }
    }

    // ====== Alerts History Functions ======
    let alertsHistoryData = [];
    let currentAlertsPage = 1;
    let totalAlertsPages = 1;
    const alertsPerPage = 10;

    async function fetchAlertsHistory(filters = {}) {
      try {
        console.debug('Loading alerts history...', filters);
        
        // Build query parameters
        const params = new URLSearchParams();
        params.append('limit', '100'); // Fetch more for client-side filtering
        params.append('offset', '0');
        params.append('include_snoozed', 'true');
        
        // Only add filters if they have values (don't filter if empty)
        if (filters.severity && filters.severity.trim() !== '') {
          params.append('severity_filter', filters.severity);
        }
        if (filters.type && filters.type.trim() !== '') {
          params.append('type_filter', filters.type);
        }
        
        // Use active endpoint with X-User header via globalConfig
        const alerts = await window.globalConfig.apiRequest('/api/alerts/active', {
          params: Object.fromEntries(params)
        });
        console.debug(`History loaded: ${alerts?.length || 0} alerts`, alerts.slice(0, 2));
        
        return alerts || [];
        
      } catch (error) {
        console.error('Failed to load alerts history:', error);
        throw error;
      }
    }

    function filterAlertsHistoryByPeriod(alerts, days) {
      const cutoffDate = new Date();
      cutoffDate.setDate(cutoffDate.getDate() - days);
      
      return alerts.filter(alert => {
        const alertDate = new Date(alert.created_at);
        return alertDate >= cutoffDate;
      });
    }

    async function loadAlertsHistory() {
      try {
        const severityFilterEl = document.getElementById('alerts-severity-filter');
        const typeFilterEl = document.getElementById('alerts-type-filter');
        const periodFilterEl = document.getElementById('alerts-period-filter');
        
        const severityFilter = severityFilterEl ? severityFilterEl.value : '';
        const typeFilter = typeFilterEl ? typeFilterEl.value : '';
        const periodDays = periodFilterEl ? parseInt(periodFilterEl.value) : 7;
        
        console.debug('Loading alerts with filters:', { severityFilter, typeFilter, periodDays });
        
        // Fetch all alerts with basic filters
        let alerts = await fetchAlertsHistory({
          severity: severityFilter,
          type: typeFilter
        });
        
        // Filter by period client-side
        alerts = filterAlertsHistoryByPeriod(alerts, periodDays);
        
        alertsHistoryData = alerts;
        
        // Store globally for modal system
        window.currentAlertsData = alerts;
        
        currentAlertsPage = 1;
        totalAlertsPages = Math.ceil(alerts.length / alertsPerPage);
        
        renderAlertsHistoryPage();
        updateAlertsStats(alerts);
        
      } catch (error) {
        console.error('Error loading alerts history:', error);
        document.getElementById('alerts-history-content').innerHTML = 
          '<div class="error">Failed to load alerts history. Please try again.</div>';
      }
    }

    function renderAlertsHistoryPage() {
      const container = document.getElementById('alerts-history-content');
      const paginationContainer = document.getElementById('alerts-pagination');
      
      if (!alertsHistoryData.length) {
        container.innerHTML = '<div class="no-data">No alerts found for the selected criteria.</div>';
        paginationContainer.style.display = 'none';
        return;
      }
      
      // Calculate pagination
      const start = (currentAlertsPage - 1) * alertsPerPage;
      const end = start + alertsPerPage;
      const pageAlerts = alertsHistoryData.slice(start, end);
      
      // Render alerts table
      const table = document.createElement('table');
      table.className = 'alerts-table';
      
      // Table header
      table.innerHTML = `
        <thead>
          <tr>
            <th>Severity</th>
            <th>Type</th>
            <th>Message</th>
            <th>Created</th>
            <th>Status</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
          ${pageAlerts.map(alert => createAlertsHistoryRow(alert)).join('')}
        </tbody>
      `;
      
      container.innerHTML = '';
      container.appendChild(table);
      
      // Update pagination
      updateAlertsPagination();
    }

    function createAlertsHistoryRow(alert) {
      const formatTime = (timestamp) => {
        if (!timestamp) return '-';
        const date = new Date(timestamp);
        return date.toLocaleString();
      };
      
      const getStatusText = (alert) => {
        if (alert.acknowledged_at) {
          return `<span style="color: var(--success)">✅ Acknowledged</span>`;
        }
        if (alert.snooze_until && new Date(alert.snooze_until) > new Date()) {
          return `<span style="color: var(--warning)">⏸️ Snoozed</span>`;
        }
        return `<span style="color: var(--error)">🚨 Active</span>`;
      };
      
      // Format unifié : Action → Impact € → 2 raisons → Détails  
      const formatUnifiedAlert = (alert) => {
        // Simuler le formatage unifié côté client
        const formatted = formatAlertClientSide(alert);
        
        return `
          <div class="alert-unified-format">
            <div class="alert-action">
              <strong>🎯 ${formatted.action}</strong>
            </div>
            <div class="alert-impact">
              💰 Impact: <span class="alert-impact-value">${formatted.impact}</span>
            </div>
            <div class="alert-reasons">
              📋 Raisons:
              <ul class="alert-reasons-list">
                ${formatted.reasons.map(reason => `<li>${reason}</li>`).join('')}
              </ul>
            </div>
            <div class="alert-details">
              ℹ️ ${formatted.details}
            </div>
          </div>
        `;
      };
      
      // Formatage unifié côté client
      const formatAlertClientSide = (alert) => {
        const alertType = alert.alert_type;
        const severity = alert.severity;
        const currentValue = alert.data?.current_value || 0;
        const portfolioValue = 100000; // €100k par défaut
        
        // Templates simplifiés
        const templates = {
          'VOL_Q90_CROSS': {
            'S1': { action: 'Surveillance volatilité', impact_base: 0.5, reasons: ['Volatilité Q90 dépassée', 'Conditions de marché agitées'] },
            'S2': { action: 'Réduction exposition (mode Slow)', impact_base: 2.0, reasons: ['Volatilité critique détectée', 'Risque de drawdown majoré'] },
            'S3': { action: 'Arrêt immédiat trading (Freeze)', impact_base: 8.0, reasons: ['Volatilité extrême mesurée', 'Protection capital prioritaire'] }
          },
          'EXEC_COST_SPIKE': {
            'S1': { action: 'Surveillance coûts exécution', impact_base: 0.2, reasons: ['Coûts trading légèrement élevés', 'Conditions liquidité moyennes'] },
            'S2': { action: 'Ralentissement trading (mode Slow)', impact_base: 1.5, reasons: ['Coûts exécution anormalement hauts', 'Liquidité marché dégradée'] },
            'S3': { action: 'Arrêt trading (mode Freeze)', impact_base: 4.0, reasons: ['Coûts exécution prohibitifs', 'Liquidité marché très dégradée'] }
          },
          'DECISION_DROP': {
            'S1': { action: 'Monitoring confiance décision', impact_base: 0.4, reasons: ['Score décision en baisse', 'Confiance allocation réduite'] },
            'S2': { action: 'Mode prudent allocation', impact_base: 2.2, reasons: ['Chute confiance décision significative', 'Qualité allocation dégradée'] },
            'S3': { action: 'Mode ultra-conservateur (Freeze)', impact_base: 9.0, reasons: ['Effondrement confiance décision', 'Allocations potentiellement erronées'] }
          }
        };
        
        const template = templates[alertType]?.[severity] || 
                        { action: `Alerte ${alertType}`, impact_base: 1.0, reasons: ['Situation détectée', 'Action recommandée'] };
        
        const impact_euro = portfolioValue * template.impact_base / 100;
        
        return {
          action: template.action,
          impact: impact_euro >= 1 ? `€${Math.round(impact_euro).toLocaleString()}` : `€${impact_euro.toFixed(2)}`,
          reasons: template.reasons,
          details: `Valeur ${currentValue} détectée - ${severity} à ${new Date(alert.created_at).toLocaleTimeString()}`
        };
      };
      
      return `
        <tr>
          <td>
            <span class="alert-severity-badge ${alert.severity}">${alert.severity}</span>
          </td>
          <td>
            <div class="alert-type-label">${formatAlertType(alert.alert_type)}</div>
          </td>
          <td class="alert-message-cell">
            ${formatUnifiedAlert(alert)}
          </td>
          <td>
            <div class="alert-timestamp">${formatTime(alert.created_at)}</div>
            <div class="alert-timestamp" style="font-size: 0.7rem; color: var(--text-muted);">${formatRelativeTime(alert.created_at)}</div>
          </td>
          <td>
            ${getStatusText(alert)}
          </td>
          <td>
            <button 
              class="alert-action-btn" 
              onclick="openAlertModal('${alert.id}')"
              title="View alert details">
              📋 Details
            </button>
          </td>
        </tr>
      `;
    }

    function updateAlertsStats(alerts) {
      console.debug('Updating alerts stats for', alerts?.length || 0, 'alerts');
      
      const stats = {
        total: alerts?.length || 0,
        S1: alerts?.filter(a => a.severity === 'S1').length || 0,
        S2: alerts?.filter(a => a.severity === 'S2').length || 0,
        S3: alerts?.filter(a => a.severity === 'S3').length || 0,
        acknowledged: alerts?.filter(a => a.acknowledged_at).length || 0
      };
      
      console.debug('Computed stats:', stats);
      
      const statsHtml = `
        <div class="alerts-stats" id="alerts-stats-display">
          <div class="alerts-stat">
            <div class="alerts-stat-number">${stats.total}</div>
            <div class="alerts-stat-label">Total</div>
          </div>
          <div class="alerts-stat">
            <div class="alerts-stat-number">${stats.S3}</div>
            <div class="alerts-stat-label">Critical</div>
          </div>
          <div class="alerts-stat">
            <div class="alerts-stat-number">${stats.S2}</div>
            <div class="alerts-stat-label">Warnings</div>
          </div>
          <div class="alerts-stat">
            <div class="alerts-stat-number">${stats.S1}</div>
            <div class="alerts-stat-label">Info</div>
          </div>
          <div class="alerts-stat">
            <div class="alerts-stat-number">${stats.acknowledged}</div>
            <div class="alerts-stat-label">Acknowledged</div>
          </div>
        </div>
      `;
      
      const container = document.getElementById('alerts-history-content');
      if (container) {
        // Remove existing stats if present
        const existingStats = document.getElementById('alerts-stats-display');
        if (existingStats) {
          existingStats.remove();
        }
        
        container.insertAdjacentHTML('afterbegin', statsHtml);
        console.debug('Stats HTML inserted into container');
      } else {
        console.warn('alerts-history-content container not found');
      }
    }

    function updateAlertsPagination() {
      const paginationContainer = document.getElementById('alerts-pagination');
      const prevBtn = document.getElementById('alerts-prev-btn');
      const nextBtn = document.getElementById('alerts-next-btn');
      const pageInfo = document.getElementById('alerts-page-info');
      
      if (totalAlertsPages <= 1) {
        paginationContainer.style.display = 'none';
        return;
      }
      
      paginationContainer.style.display = 'flex';
      prevBtn.disabled = currentAlertsPage <= 1;
      nextBtn.disabled = currentAlertsPage >= totalAlertsPages;
      pageInfo.textContent = `Page ${currentAlertsPage} of ${totalAlertsPages}`;
    }

    function loadPreviousAlertsPage() {
      if (currentAlertsPage > 1) {
        currentAlertsPage--;
        renderAlertsHistoryPage();
      }
    }

    function loadNextAlertsPage() {
      if (currentAlertsPage < totalAlertsPages) {
        currentAlertsPage++;
        renderAlertsHistoryPage();
      }
    }

    // DEFINE GLOBALLY
    window.filterAlertsHistory = function() {
      loadAlertsHistory();
    };

    function refreshAlertsHistory() {
      loadAlertsHistory();
    }

    // Load alerts history when the tab is switched to
    function initializeAlertsTab() {
      loadAlertsHistory();
    }

    // ====== Sidebar Updates ======
    function updateSidebar(state) {
      // Get all scores from state
      const ccsScore = state.ccs?.score;
      const onchainScore = state.scores?.onchain;
      const riskScore = state.scores?.risk;
      const blendedScore = state.scores?.blended;

      // Update API status
      const backendDot = document.getElementById('backend-dot');
      const signalsDot = document.getElementById('signals-dot');

      if (backendDot) {
        backendDot.className = `status-dot ${state.ui?.apiStatus?.backend || 'unknown'}`;
      }
      if (signalsDot) {
        signalsDot.className = `status-dot ${state.ui?.apiStatus?.signals || 'unknown'}`;
      }

      // Update governance status
      const governanceStatus = store.getGovernanceStatus();
      const governanceDot = document.getElementById('governance-dot');
      const governanceText = document.getElementById('governance-text');
      const governanceMode = document.getElementById('governance-mode');
      const governanceContradiction = document.getElementById('governance-contradiction');

      if (governanceDot && governanceText) {
        // Set status dot color based on state
        let dotClass = 'status-dot';
        let statusText = governanceStatus.state;
        
        if (governanceStatus.state === 'FROZEN') {
          dotClass += ' error';
          statusText = '❄️ Frozen';
        } else if (governanceStatus.needsAttention) {
          dotClass += ' warning';
          statusText = '⚠️ Needs attention';
        } else if (governanceStatus.isActive) {
          dotClass += ' success';
          statusText = '✓ Active';
        } else {
          dotClass += ' idle';
          statusText = '○ Idle';
        }
        
        governanceDot.className = dotClass;
        governanceText.textContent = statusText;
      }

      if (governanceMode && governanceContradiction) {
        governanceMode.textContent = `Mode: ${governanceStatus.mode}`;
        const contraPct = (governanceStatus.contradictionLevel * 100);
        governanceContradiction.textContent = `Contradiction: ${contraPct.toFixed(1)}%`;

        // Gate 'Aggressive' mode in UI: blended < 70 or contradiction > 40%
        try {
          const constraintsEl = document.getElementById('governance-constraints');
          const blended = state.scores?.blended || 0;
          const gated = (blended < 70) || (contraPct > 40);
          if (constraintsEl) {
            constraintsEl.textContent = gated ? 'Aggressive disabled (blended < 70 or contradiction > 40%)' : '';
          }
        } catch {}
      }

      // Update cycle indicator with enhanced info
      const cycleText = document.getElementById('cycle-text');
      const cycleDot = document.getElementById('cycle-dot');

      if (state.cycle?.months && state.cycle?.phase) {
        const months = Math.round(state.cycle.months);
        const phase = state.cycle.phase;

        cycleText.innerHTML = `
          <div style="font-size: 11px; font-weight: 600;">${phase.emoji} ${phase.phase.replace('_', ' ').toUpperCase()}</div>
          <div style="font-size: 10px; opacity: 0.8;">Month ${months} post-halving</div>
        `;

        // Color based on phase
        cycleDot.style.backgroundColor = phase.color;
        cycleDot.className = 'status-dot';
      } else {
        cycleText.textContent = 'Loading cycle data...';
        cycleDot.className = 'status-dot';
      }

      // Update CCS Mixte score (Score Directeur)
      const ccsMixEl = document.getElementById('ccs-ccs-mix');
      const ccsMixLabel = document.getElementById('ccs-mixte-label');
      console.debug('🔍 DEBUG CCS Mixte storage condition:', {
        'state.cycle?.ccsStar': state.cycle?.ccsStar,
        'ccsScore': ccsScore,
        'condition met': !!(state.cycle?.ccsStar && ccsScore)
      });
      
      if (state.cycle?.ccsStar && ccsScore) {
        ccsMixEl.textContent = Math.round(state.cycle.ccsStar);
        
        // STOCKER CCS MIXTE dans localStorage pour unified-scores.html (AU BON MOMENT)
        localStorage.setItem('risk_score_ccs_mixte', state.cycle.ccsStar.toString());
        console.debug('✅ Stored CCS Mixte in localStorage:', state.cycle.ccsStar);
        
        if (ccsMixLabel) {
          const cycleWeight = Math.round((state.cycle?.weight || 0.3) * 100);
          ccsMixLabel.textContent = `CCS + Cycle (${cycleWeight}%)`;
          // Style dynamique selon le score
          const score = state.cycle.ccsStar;
          // Harmoniser avec Score Composite V2: >70 rouge, <40 vert, sinon orange
          ccsMixEl.style.color = score > 70 ? '#ef4444' : score >= 40 ? '#f59e0b' : '#10b981';
        }
      } else {
        ccsMixEl.textContent = '--';
        if (ccsMixLabel) ccsMixLabel.textContent = 'Loading...';
      }

      // Update On-Chain score
      const onchainEl = document.getElementById('kpi-onchain');
      const onchainLabel = document.getElementById('onchain-label');
      if (onchainScore !== null && onchainScore !== undefined) {
        onchainEl.textContent = Math.round(onchainScore);
        // Harmoniser avec Score Composite V2: >70 rouge, <40 vert, sinon orange
        onchainEl.style.color = onchainScore > 70 ? '#ef4444' : onchainScore >= 40 ? '#f59e0b' : '#10b981';
        if (onchainLabel) {
          onchainLabel.textContent = `MVRV, NVT, Puell, F&G`;
        }
      } else {
        onchainEl.textContent = '--';
        if (onchainLabel) onchainLabel.textContent = 'Loading...';
      }

      // Update Risk Score
      const riskEl = document.getElementById('kpi-risk');
      const riskLabel = document.getElementById('risk-label');
      if (riskScore !== null && riskScore !== undefined) {
        riskEl.textContent = Math.round(riskScore);
        // Harmoniser: score élevé = plus risqué (rouge)
        riskEl.style.color = riskScore > 70 ? '#ef4444' : riskScore >= 40 ? '#f59e0b' : '#10b981';
        if (riskLabel) {
          const riskLevel = riskScore > 70 ? 'High Risk' : riskScore >= 40 ? 'Medium' : 'Low Risk';
          riskLabel.textContent = riskLevel;
        }
      } else {
        riskEl.textContent = '--';
        if (riskLabel) riskLabel.textContent = 'Loading...';
      }

      // Update Strategic Blended Score (synthèse de décision)
      const blendedEl = document.getElementById('kpi-blended');
      const blendedLabel = document.getElementById('blended-label');
      const blendedGauge = document.getElementById('blended-gauge');

      if (blendedScore !== null && blendedScore !== undefined) {
        const s = Math.round(blendedScore);
        blendedEl.textContent = s;

        let regime, regimeColor, tone;
        if (s >= 85) { regime = 'Distribution'; regimeColor = '#dc2626'; tone = 'danger'; }
        else if (s >= 70) { regime = 'Euphorie'; regimeColor = '#f59e0b'; tone = 'warning'; }
        else if (s >= 40) { regime = 'Expansion'; regimeColor = '#10b981'; tone = 'success'; }
        else { regime = 'Accumulation'; regimeColor = '#3b82f6'; tone = 'info'; }

        blendedEl.style.color = regimeColor;
        blendedLabel.textContent = regime;
        blendedLabel.style.color = regimeColor;

        // 👉 applique le “tone” pour que le CSS choisisse fond/bordure/ombre
        blendedGauge.setAttribute('data-tone', tone);

        // Phase 1D: Update blended meta with badges parité Analytics/Risk
        try {
          const metaEl = document.getElementById('blended-meta');
          const ml = store.get('governance.ml_signals');
          const policy = store.get('governance.active_policy');

          const source = (ml && typeof ml.decision_score === 'number') ? 'backend' : 'SMART';
          const ci = ml && typeof ml.contradiction_index === 'number' ? Math.round(ml.contradiction_index * 100) : null;
          const ts = ml && ml.timestamp ? new Date(ml.timestamp) : null;
          const hh = ts ? ts.toLocaleTimeString() : null;
          const cap = policy && typeof policy.cap_daily === 'number' ? Math.round(policy.cap_daily * 100) : null;
          const backendStatus = store.get('ui.apiStatus.backend');

          if (metaEl) {
            // Phase 1D: Format identique Analytics/Risk
            const badges = [];
            badges.push(source);
            if (hh) badges.push(`Updated ${hh}`);
            if (ci != null) badges.push(`Contrad ${ci}%`);
            if (cap != null) badges.push(`Cap ${cap}%`);

            // Overrides count (simulate for now)
            const overrides = 0; // TODO: Get from governance state
            if (overrides > 0) badges.push(`Overrides ${overrides}`);

            // Status indicators
            if (backendStatus === 'stale') badges.push('STALE');
            if (backendStatus === 'error') badges.push('ERROR');

            metaEl.textContent = badges.join(' • ');
          }
        } catch {}
      } else {
        blendedEl.textContent = '--';
        blendedLabel.textContent = 'Loading...';
        blendedLabel.style.color = '';
        blendedGauge.removeAttribute('data-tone');
        const metaEl = document.getElementById('blended-meta');
        if (metaEl) metaEl.textContent = '';
      }

      // Update targets summary placeholder
      const targetsSummary = document.getElementById('targets-summary');
      if (targetsSummary) {
        const ccsStar = state.cycle?.ccsStar;
        if (ccsStar && ccsScore) {
          targetsSummary.innerHTML = `
            <div style="font-size: 11px;">
              <div>CCS: ${Math.round(ccsScore)} → ${Math.round(ccsStar)} (blended)</div>
              <div style="font-size: 10px; opacity: 0.8; margin-top: 2px;">Final: ${blendedScore ? Math.round(blendedScore) : '--'}/100</div>
            </div>
          `;
        } else {
          targetsSummary.innerHTML = '<div class="status-text">Loading targets...</div>';
        }
      }
    }


    // Risk rating rules for different metrics
    const RISK_RULES = {
      sharpe: { good: [0.5, 999], warn: [0.2, 0.5] },
      sortino: { good: [0.5, 999], warn: [0.2, 0.5] },
      volatility: { good: [0, 0.3], warn: [0.3, 0.6] },
      max_drawdown: { good: [0, 0.2], warn: [0.2, 0.4] },
      var95_1d: { good: [0, 0.05], warn: [0.05, 0.10] },
      var99_1d: { good: [0, 0.08], warn: [0.08, 0.15] },
      cvar95_1d: { good: [0, 0.07], warn: [0.07, 0.12] },
      cvar99_1d: { good: [0, 0.10], warn: [0.10, 0.18] },
      diversification_ratio: { good: [0.7, 2.0], warn: [0.4, 0.7] },
      effective_assets: { good: [10, 999], warn: [5, 10] }
    };

    function rate(key, value) {
      const r = RISK_RULES[key];
      if (!r || value == null || isNaN(value)) return { dot: 'orange', verdict: 'Indisponible', body: 'Donnée indisponible.' };
      const signed = value;
      let v = signed;
      // Pour ces métriques, on évalue la magnitude (valeur absolue) :
      if (['volatility', 'max_drawdown', 'var95_1d', 'var99_1d', 'cvar95_1d', 'cvar99_1d'].includes(key)) v = Math.abs(signed);
      const inR = ([a, b]) => v >= a && v < b;
      let dot = 'red', verdict = 'Élevé / risqué';
      if (inR(r.good)) { dot = 'green'; verdict = 'Plutôt bas / maîtrisé'; }
      else if (inR(r.warn)) { dot = 'orange'; verdict = 'Intermédiaire / à surveiller'; }
      return { dot, verdict, body: '', label: key };
    }

    // Note: Initialization moved to the bottom of the script

    // ====== Main Functions ======
    // ====== Score Calculation Functions ======

    // Calculate On-Chain Score (V2 System with optional dynamic weighting)
    async function calculateOnChainScore() {
      try {
        const indicators = await fetchAllIndicators();
        // Aucun indicateur exploitable → retourner null (et laisser l'UI gérer)
        if (!indicators || (indicators._metadata && indicators._metadata.available_count === 0)) {
          return null;
        }

        // Check if dynamic weighting is enabled (from localStorage setting)
        const useDynamicWeighting = localStorage.getItem('enable_dynamic_weighting') === 'true';

        console.debug(`🎯 calculateOnChainScore: useDynamicWeighting = ${useDynamicWeighting} (from localStorage: ${localStorage.getItem('enable_dynamic_weighting')})`);

        const composite = calculateCompositeScoreV2(indicators, useDynamicWeighting);

        console.debug(`📊 Composite result: score=${composite.score}, version=${composite.version}, hasDynamic=${!!composite.dynamicWeighting}`);

        if (useDynamicWeighting && composite.dynamicWeighting) {
          console.debug(`🤖 Dynamic weighting applied: ${composite.dynamicWeighting.phase.name} phase`);
        }

        if (composite.score === null) {
          console.warn('⚠️ No real on-chain data available - returning null score');
          return null;
        }

        console.debug(`📊 On-Chain Score: ${composite.score} (${composite.message})`);

        // Stocker les métadonnées enrichies V2 pour utilisation par SMART
        store.set('scores.onchain_metadata', {
          categoryBreakdown: composite.categoryBreakdown,
          criticalZoneCount: composite.criticalZoneCount,
          totalIndicators: composite.totalIndicators,
          activeCategories: composite.activeCategories,
          contributors: composite.contributors.slice(0, 10), // Top 10 contributeurs
          confidence: composite.confidence,
          // V2 specific properties
          consensusSignals: composite.consensusSignals,
          correlationAnalysis: composite.correlationAnalysis,
          version: composite.version,
          improvements: composite.improvements,
          // Dynamic weighting properties (if enabled)
          dynamicWeighting: composite.dynamicWeighting
        });

        // Analyze contradictory signals V2
        const contradictions = analyzeContradictorySignals(composite.categoryBreakdown);
        if (contradictions.length > 0) {
          console.warn(`⚠️ ${contradictions.length} signaux contradictoires détectés:`, contradictions);
          store.set('scores.contradictory_signals', contradictions);
        }

        // Log des alertes critiques
        if (composite.criticalZoneCount > 0) {
          console.warn(`🚨 ${composite.criticalZoneCount} indicateur(s) en zone critique!`);

          const criticalIndicators = composite.contributors.filter(c => c.inCriticalZone);
          criticalIndicators.forEach(indicator => {
            console.warn(`  ⚠️ ${indicator.name}: ${indicator.originalValue}% (seuil: ${indicator.raw_threshold})`);
          });
        }

        // Log de la répartition par catégorie
        Object.entries(composite.categoryBreakdown).forEach(([category, data]) => {
          const emoji = category === 'onchain_fundamentals' ? '🔗' :
            category === 'cycle_technical' ? '📊' : '😨';
          console.debug(`  ${emoji} ${data.description}: ${data.score}/100 (${data.contributorsCount} indicateurs)`);
        });

        if (indicators._metadata?.missing_apis?.length > 0) {
          console.warn('⚠️ Missing APIs:', indicators._metadata.missing_apis);
        }

        return composite.score;
      } catch (error) {
        console.error('❌ Erreur calcul On-Chain Score:', error);
        return null; // Retourner null au lieu de fallback trompeur
      }
    }

    // Calculate Risk Score from portfolio metrics
    function calculateRiskScore(riskData) {
      if (!riskData?.risk_metrics) return 50;

      const metrics = riskData.risk_metrics;
      let score = 50; // Start neutral
      let factors = 0;

      // Sharpe ratio (higher is better)
      if (metrics.sharpe_ratio != null) {
        score += metrics.sharpe_ratio > 1 ? 20 : metrics.sharpe_ratio > 0.5 ? 10 : -10;
        factors++;
      }

      // Volatility (lower is better for risk score)
      if (metrics.volatility != null) {
        const vol = Math.abs(metrics.volatility);
        score += vol < 0.2 ? 15 : vol < 0.4 ? 5 : -15;
        factors++;
      }

      // Max Drawdown (lower is better)
      if (metrics.max_drawdown != null) {
        const dd = Math.abs(metrics.max_drawdown);
        score += dd < 0.1 ? 15 : dd < 0.2 ? 5 : -15;
        factors++;
      }

      // VaR 95% (lower is better)
      if (metrics.var95_1d != null) {
        const var95 = Math.abs(metrics.var95_1d);
        score += var95 < 0.05 ? 10 : var95 < 0.1 ? 0 : -10;
        factors++;
      }

      return Math.max(0, Math.min(100, factors > 0 ? score : 50));
    }

    // Calculate strategic Blended Score (nouvelle formule market-aware)
    function calculateBlendedScore(ccsMixteScore, onchainScore, riskScore) {
      // Formule stratégique : 50% CCS Mixte + 30% On-Chain + 20% (100-Risk)
      if (ccsMixteScore == null && onchainScore == null && riskScore == null) {
        return 50; // Fallback neutre
      }

      console.debug('🎯 Calcul Blended Score stratégique:', {
        ccsMixte: ccsMixteScore,
        onchain: onchainScore,
        risk: riskScore
      });

      let totalScore = 0;
      let totalWeight = 0;

      // CCS Mixte : 50% (score directeur du marché)
      if (ccsMixteScore != null) {
        totalScore += ccsMixteScore * 0.50;
        totalWeight += 0.50;
        console.debug('  → CCS Mixte contributtion:', ccsMixteScore * 0.50);
      }

      // On-Chain Composite : 30% (fondamentaux réseau)
      if (onchainScore != null) {
        totalScore += onchainScore * 0.30;
        totalWeight += 0.30;
        console.debug('  → On-Chain contribution:', onchainScore * 0.30);
      } else {
        console.warn('  ⚠️ On-Chain Score non disponible (APIs payantes requises) - poids redistribué');
      }

      // Risk adjustment : 20% (100 - Risk pour inverser le score)
      if (riskScore != null) {
        const riskAdjusted = 100 - riskScore; // Haut risque = bas score
        totalScore += riskAdjusted * 0.20;
        totalWeight += 0.20;
        console.debug('  → Risk contribution (100-risk):', riskAdjusted * 0.20);
      }

      const finalScore = totalWeight > 0 ? totalScore / totalWeight : 50;
      console.debug('🎯 Final Blended Score:', finalScore, '(weight:', totalWeight, ')');

      return Math.max(0, Math.min(100, finalScore));
    }

    // Apply UI state based on blended decision score
    function applyDecisionState(score) {
      try {
        const el = document.getElementById('blended-gauge');
        if (!el || typeof score !== 'number') return;
        el.classList.remove('decision--bullish','decision--neutral','decision--defensive');
        let state = 'neutral';
        if (score >= 70) state = 'bullish';
        else if (score < 45) state = 'defensive';
        el.classList.add(`decision--${state}`);
      } catch (e) { /* no-op */ }
    }

    // Main function to calculate all scores
    async function calculateAllScores(riskData, ccsData) {
      try {
        console.debug('🎯 Calculating all scores...');

        // Check cached scores first
        const cachedScores = getCachedData('SCORES');
        if (cachedScores && cachedScores.data) {
          const age = Math.round((Date.now() - cachedScores.timestamp) / (1000 * 60));
          console.log(`⚡ Using cached scores (${age} minutes old)`);

          const scores = cachedScores.data;
          // Hydrate store with cached scores so subscribers (updateSidebar) see values
          try {
            if (scores.onchainScore != null) store.set('scores.onchain', scores.onchainScore);
            if (scores.riskScore != null) store.set('scores.risk', scores.riskScore);
            if (scores.blendedScore != null) store.set('scores.blended', scores.blendedScore);
            if (scores.ccsScore != null) store.set('ccs.score', scores.ccsScore);
            if (scores.ccsMixteScore != null) store.set('cycle.ccsStar', scores.ccsMixteScore);
          } catch (e) {
            console.warn('Failed to hydrate store with cached scores:', e);
          }

          updateScoreDisplays(scores.onchainScore, scores.riskScore, scores.blendedScore, scores.ccsScore);
          // Ensure sidebar reflects the hydrated store
          try { updateSidebar(store.snapshot()); } catch { }
          updateMarketRegime(scores.blendedScore, scores.onchainScore, scores.riskScore);
          return scores;
        }

        console.debug('🔄 No valid cache found, calculating fresh scores...');

        // Apply calibrated parameters if available
        const calibratedParams = loadCalibrationParams();
        if (calibratedParams) {
          // Apply to cycle navigator module
          const module = await import('./modules/cycle-navigator.js');
          module.setCycleParams(calibratedParams);
          console.debug('🔄 Applied calibrated parameters');
        }

        // Get current CCS and cycle data
        const currentState = store.snapshot();
        const ccsScore = currentState.ccs?.score;
        const ccsMixteScore = currentState.cycle?.ccsStar; // CCS + Cycle blended

        // Calculate On-Chain Score
        onchainScore = await calculateOnChainScore();

        // Use Risk Score directly from backend (consistent with Risk Overview)
        riskScore = riskData?.risk_metrics?.risk_score ?? 50;
        console.debug('🛡️ Risk Score (from backend):', riskScore);

        // Calculate Strategic Blended Score (nouvelle formule)
        blendedScore = calculateBlendedScore(ccsMixteScore, onchainScore, riskScore);
        // Reflect decision state in UI card
        try { applyDecisionState(blendedScore); } catch {}

        // Store the scores in the store for use by other modules
        store.set('scores.onchain', onchainScore);
        store.set('scores.risk', riskScore);
        store.set('scores.blended', blendedScore);

        // Prefer server-side recompute of blended (source of truth)
        try { await store.recomputeGovernanceBlended(ccsMixteScore, onchainScore, riskScore); } catch {}

        // Store scores in persistent cache
        const scoreData = {
          onchainScore: onchainScore,
          riskScore: riskScore,
          blendedScore: blendedScore,
          ccsScore: ccsScore,
          ccsMixteScore: ccsMixteScore
        };
        setCachedData('SCORES', scoreData);

        // Also store scores in localStorage for cross-page access (compatibility)
        // Include data source in the score keys for proper synchronization
        const dataSource = globalConfig.get('data_source') || 'unknown';
        const __user = (localStorage.getItem('activeUser') || 'demo');
        const __prefix = (k) => `${k}:${__user}`;
        try {
          localStorage.setItem(__prefix('risk_score_onchain'), onchainScore !== null ? onchainScore.toString() : '');
          localStorage.setItem(__prefix('risk_score_risk'), riskScore !== null ? riskScore.toString() : '');
          localStorage.setItem(__prefix('risk_score_blended'), blendedScore !== null ? blendedScore.toString() : '');
          localStorage.setItem(__prefix('risk_score_ccs'), ccsScore !== null ? ccsScore.toString() : '');
          localStorage.setItem(__prefix('risk_score_timestamp'), Date.now().toString());
          localStorage.setItem(__prefix('risk_score_data_source'), dataSource);
        } catch (_) {}
        
        // STOCKER CCS MIXTE sera fait APRÈS le calcul du blending dans updateScoreDisplays

        console.debug('📊 All scores calculated:', {
          ccs: ccsScore,
          ccsMixte: ccsMixteScore,
          onchain: onchainScore,
          risk: riskScore,
          blended: blendedScore
        });

        // Calculate market regime
        updateMarketRegime(blendedScore, onchainScore, riskScore);

        // Update sidebar with fresh state
        const freshState = store.snapshot();
        updateSidebar(freshState);

      } catch (error) {
        console.error('❌ Erreur calcul des scores:', error);
      }
    }

    // ====== Market Regime Functions ======
    function updateMarketRegime(blendedScore, onchainScore, riskScore) {
      try {
        // Calculate regime data
        const regimeData = getRegimeDisplayData(blendedScore, onchainScore, riskScore);
        const regime = regimeData.regime;

        console.debug('📊 Market Regime calculated:', regime);

        // Update Market Regime display
        const regimeDot = document.getElementById('regime-dot');
        const regimeText = document.getElementById('regime-text');

        if (regimeDot && regimeText) {
          regimeDot.style.backgroundColor = regime.color;
          regimeDot.className = 'status-dot active';

          const confidenceText = `${Math.round(regime.confidence * 100)}%`;
          regimeText.innerHTML = `
            <div style="font-weight: bold; color: ${regime.color};">
              ${regime.emoji} ${regime.name}
            </div>
            <div style="font-size: 0.8rem; margin-top: 2px;">
              Score: ${regime.score.toFixed(2)} | Conf: ${confidenceText}
            </div>
          `;

          // Store regime data for other components
          store.set('market.regime', regimeData);
        }

      } catch (error) {
        console.error('❌ Error updating market regime:', error);

        const regimeText = document.getElementById('regime-text');
        if (regimeText) {
          regimeText.textContent = 'Error calculating regime';
        }
      }
    }

    // ====== Dynamic Weighting Functions ======
    // Fallback banner toggle (backend status)
    setInterval(() => {
      try {
        const status = store.get('ui.apiStatus.backend');
        const banner = document.getElementById('backend-fallback-banner');
        if (!banner) return;
        banner.style.display = (status && status !== 'healthy') ? 'block' : 'none';
      } catch {}
    }, 2000);

    window.toggleDynamicWeighting = function () {
      const toggle = document.getElementById('dynamic-weighting-toggle');
      const status = document.getElementById('dynamic-weighting-status');
      if (!toggle) return; // UI pas encore rendu
      const isEnabled = toggle.checked;
      localStorage.setItem('enable_dynamic_weighting', isEnabled.toString());

      console.debug(`🔄 Toggle changed: ${isEnabled} (localStorage now: ${localStorage.getItem('enable_dynamic_weighting')})`);

      if (status) {
        if (isEnabled) {
          status.textContent = '🤖 Pondération dynamique active';
          status.style.color = 'var(--success)';
        } else {
          status.textContent = 'Pondération statique V2';
          status.style.color = 'var(--theme-text-muted)';
        }
      }

      // Clear any cached composite score to force recalculation
      if (window.compositeScoreCache) {
        console.debug('🗑️ Clearing composite score cache');
        window.compositeScoreCache.cache.clear();
      }

      // Trigger refresh to apply new weighting
      setTimeout(refreshDashboard, 500);
    };

    // Initialize dynamic weighting state on load
    function initializeDynamicWeightingToggle() {
      const toggle = document.getElementById('dynamic-weighting-toggle');
      const status = document.getElementById('dynamic-weighting-status');
      const isEnabled = localStorage.getItem('enable_dynamic_weighting') === 'true';
      if (toggle) toggle.checked = isEnabled;
      if (status) {
        if (isEnabled) {
          status.textContent = '🤖 Pondération dynamique active';
          status.style.color = 'var(--warning)';
        } else {
          status.textContent = 'Pondération statique V2';
          status.style.color = 'var(--theme-text-muted)';
        }
      }
    }

    // ====== Section Collapse Functions ======

    // ✅ NOUVEAU: Fonction de debug pour forcer le chargement du Bitcoin Chart
    window.debugBitcoinChart = function() {
      console.log('🐛 DEBUG: Force loading Bitcoin Chart');

      const lazyElement = document.querySelector('[data-lazy-load="component"][data-lazy-component="BitcoinCycleChart"]');

      if (!lazyElement) {
        console.error('❌ Bitcoin Chart element not found');
        alert('❌ Bitcoin Chart element not found');
        return;
      }

      console.log('✅ Bitcoin Chart element found:', lazyElement);
      console.log('Lazy loader available:', !!window.lazyLoader);
      console.log('BitcoinCycleChart class available:', !!window.BitcoinCycleChart);
      console.log('Element classes:', lazyElement.className);

      if (!window.lazyLoader) {
        console.error('❌ Lazy loader not available');
        alert('❌ Lazy loader not available');
        return;
      }

      try {
        console.log('🚀 Forcing lazy load...');
        window.lazyLoader.loadVisibleElement(lazyElement);
        console.log('✅ Force load triggered');
        alert('🚀 Force load triggered - check console');
      } catch (error) {
        console.error('❌ Error during force load:', error);
        alert('❌ Error: ' + error.message);
      }
    };

    window.toggleSection = function (sectionId) {
      const content = document.getElementById(sectionId + '-content');
      const arrow = document.getElementById(sectionId + '-arrow');

      if (!content || !arrow) return;

      const isCollapsed = content.style.display === 'none';

      if (isCollapsed) {
        content.style.display = '';
        arrow.textContent = '▼';
        localStorage.setItem(`section_${sectionId}_collapsed`, 'false');

        // Observe lazy elements; only force-load if they are near viewport
        setTimeout(() => {
          const lazyElements = content.querySelectorAll('[data-lazy-load]');
          console.log(`🔍 Section ${sectionId} expanded, checking ${lazyElements.length} lazy elements`);

          const isNearViewport = (el, margin = 150) => {
            try {
              const r = el.getBoundingClientRect();
              const vh = window.innerHeight || document.documentElement.clientHeight;
              return r.top < vh + margin && r.bottom > -margin;
            } catch (_) { return false; }
          };

          lazyElements.forEach(element => {
            if (!element.classList.contains('lazy-loaded') && !element.classList.contains('lazy-error')) {
              if (isNearViewport(element)) {
                console.log(`📊 Element near viewport; loading now in section ${sectionId}`);
                window.lazyLoader?.loadVisibleElement(element);
              } else {
                console.log(`👁️ Element not near viewport; ensuring observer is attached`);
                if (window.lazyLoader?.intersectionObserver) {
                  try { window.lazyLoader.intersectionObserver.observe(element); } catch (_) {}
                }
              }
            }
          });
        }, 100);
      } else {
        content.style.display = 'none';
        arrow.textContent = '▶';
        localStorage.setItem(`section_${sectionId}_collapsed`, 'true');
      }
    }

    // Initialize section states on page load
    function initializeSectionStates() {
      const sections = ['onchain-indicators', 'bitcoin-cycle', 'dynamic-weighting-info'];

      sections.forEach(sectionId => {
        const isCollapsed = localStorage.getItem(`section_${sectionId}_collapsed`) === 'true';
        const content = document.getElementById(sectionId + '-content');
        const arrow = document.getElementById(sectionId + '-arrow');

        if (content && arrow) {
          if (isCollapsed) {
            content.style.display = 'none';
            arrow.textContent = '▶';
          } else {
            content.style.display = '';
            arrow.textContent = '▼';

            // Ensure lazy elements are observed; only force-load if near viewport
            setTimeout(() => {
              const lazyElements = content.querySelectorAll('[data-lazy-load]');
              if (lazyElements.length > 0) {
                console.log(`🔍 Section ${sectionId} is open by default, checking ${lazyElements.length} lazy elements`);

                lazyElements.forEach(element => {
                  if (!element.classList.contains('lazy-loaded') && !element.classList.contains('lazy-error')) {
                    const isNearViewport = (el, margin = 150) => {
                      try {
                        const r = el.getBoundingClientRect();
                        const vh = window.innerHeight || document.documentElement.clientHeight;
                        return r.top < vh + margin && r.bottom > -margin;
                      } catch (_) { return false; }
                    };

                    if (isNearViewport(element)) {
                      console.log(`📊 Element near viewport; loading now in open section ${sectionId}`);
                      setTimeout(() => { window.lazyLoader?.loadVisibleElement(element); }, 300);
                    } else {
                      console.log(`👁️ Element not near viewport; ensuring observer is attached`);
                      if (window.lazyLoader?.intersectionObserver) {
                        try { window.lazyLoader.intersectionObserver.observe(element); } catch (_) {}
                      }
                    }
                  }
                });
              }
            }, 100);
          }
        }
      });
    }

async function refreshDashboard(forceRefresh = false) {
  if (isRefreshing) return;
  isRefreshing = true;
  // Ensure currency rate loaded before render when not USD
  try {
    const cur = (window.globalConfig && window.globalConfig.get('display_currency')) || 'USD';
    if (window.currencyManager && cur !== 'USD') {
      await window.currencyManager.ensureRate(cur);
    }
  } catch (_) {}

      const refreshBtn = document.getElementById('refresh-btn');
      refreshBtn.disabled = true;
      // Optional: disable dropdown trigger if present
      const refreshMenuBtn = document.getElementById('refresh-menu-btn');
      if (refreshMenuBtn) refreshMenuBtn.disabled = true;
      const forceRefreshBtn = document.getElementById('force-refresh-btn');
      if (forceRefreshBtn) forceRefreshBtn.disabled = true;
      refreshBtn.textContent = forceRefresh ? '🔄 Force Refreshing…' : '🔄 Refreshing…';

      // Clear cache if force refresh is requested
      if (forceRefresh) {
        clearAllPersistentCache();
        console.log('🧹 Force refresh: all cache cleared');
      }

      // Update loading state
      store.set('ui.loading', true);
      store.set('ui.apiStatus.backend', 'unknown');

      try {
        // Fetch risk data, CCS data, and alerts in parallel
        const [riskData, ccsData, alertsData] = await Promise.all([
          fetchRiskData(),
          loadCCSData().catch(err => {
            console.warn('CCS data failed, continuing with risk only:', err);
            return null;
          }),
          fetchAlertsData().catch(err => {
            console.warn('Alerts data failed, continuing without alerts:', err);
            return null;
          })
        ]);

        if (riskData && riskData.success) {
          // Update store with risk data
          store.set('riskMetrics', riskData.risk_metrics);
          store.set('portfolioSummary', riskData.portfolio_summary);
          store.set('correlationMetrics', riskData.correlation_metrics);
          store.set('ui.apiStatus.backend', 'healthy');

          // Render risk dashboard in the active tab
          renderRiskDashboard(riskData);

          // Update timestamp
          if (riskData.timestamp && riskData.calculation_time) {
            updateTimestamp(riskData.timestamp, riskData.calculation_time);
          }

          // If CCS data loaded successfully, compute blended CCS
          if (ccsData) {
            await loadBlendedCCS();
          }

          // Calculate additional scores
          await calculateAllScores(riskData, ccsData);

          // Force sidebar update after all scores are calculated
          const finalState = store.snapshot();
          updateSidebar(finalState);

          // Update alerts display
          updateAlertsDisplay(alertsData);

          // Also update cycles content (contains composite score display) 
          if (finalState.ccs?.score && finalState.cycle?.months) {
            await renderCyclesContent();
            console.debug('🔄 Cycles content updated with latest data');
          }

          console.log('Risk dashboard refreshed successfully');

        } else {
          // Handle API error with informative message, but still compute partial scores (on-chain + defaults)
          store.set('ui.apiStatus.backend', 'error');
          const errorType = riskData?.error_type || 'unknown';
          const errorMessage = riskData?.message || 'Failed to load risk dashboard';

          if (errorType === 'connection_error') {
            renderBackendUnavailable(errorMessage);
          } else {
            renderApiError(errorMessage);
          }

          // Attempt partial scoring so sidebar is still populated
          try {
            if (ccsData) {
              await loadBlendedCCS();
            }
            await calculateAllScores(riskData, ccsData);
            updateSidebar(store.snapshot());
          } catch (e) {
            console.warn('Partial score calculation failed:', e);
          }
          return; // Don't throw, just render error state
        }

      } catch (err) {
        console.error('Dashboard error:', err);
        store.set('ui.apiStatus.backend', 'error');
        renderBackendUnavailable('Erreur de connexion au backend de risque');
      } finally {
        isRefreshing = false;
        store.set('ui.loading', false);
        refreshBtn.disabled = false;
        if (refreshMenuBtn) refreshMenuBtn.disabled = false;
        if (forceRefreshBtn) forceRefreshBtn.disabled = false;
        refreshBtn.textContent = '🔄 Refresh';
      }
    }

    // Update badges with current risk data
    function updateRiskDashboardBadges(data) {
      if (!window.riskDashboardBadges) return;

      try {
        const now = new Date();

        // Risk Overview badge
        const riskMetrics = data?.risk_metrics || {};
        const portfolioSummary = data?.portfolio_summary || {};
        const contradiction = Math.round((data?.correlation_metrics?.average_correlation || 0.3) * 100);
        const varCap = Math.round((riskMetrics.var_95_1d || 0.05) * 100);

        if (window.riskDashboardBadges.riskOverview) {
          window.riskDashboardBadges.riskOverview.updateData({
            source: 'Risk Engine',
            updated: now,
            contradiction: contradiction,
            cap: varCap,
            overrides: data?.overrides_count || 0,
            status: data ? 'ok' : 'error'
          });
        }

        // Cycles badge
        if (window.riskDashboardBadges.cycles) {
          window.riskDashboardBadges.cycles.updateData({
            source: 'Market Cycles',
            updated: now,
            contradiction: Math.round(Math.random() * 50), // Placeholder
            status: 'ok'
          });
        }

        // Targets badge
        if (window.riskDashboardBadges.targets) {
          window.riskDashboardBadges.targets.updateData({
            source: 'Targets',
            updated: now,
            contradiction: Math.round(Math.random() * 30), // Placeholder
            status: 'ok'
          });
        }

        console.log('🏷️ Risk dashboard badges updated');
      } catch (error) {
        console.warn('Risk badge update failed:', error);
      }
    }

    function renderRiskDashboard(data) {
      const container = document.getElementById('risk-dashboard-content');
      if (!data || !data.risk_metrics || !data.correlation_metrics || !data.portfolio_summary) {
        renderError('Incomplete data received from API'); return;
      }

      // Afficher un bandeau pour le mode test
      let testModeBanner = '';
      if (data.test_mode) {
        testModeBanner = `
          <div style="background: var(--info-bg); border: 1px solid var(--info); border-radius: var(--radius-md); padding: 1rem; margin-bottom: 1.5rem; text-align: center;">
            <div style="color: var(--info); font-weight: 600; margin-bottom: 0.5rem;">🧪 MODE TEST - Données Réelles</div>
            <div style="color: var(--theme-text-muted); font-size: 0.9rem;">
              Portfolio de démonstration utilisant le cache d'historique de prix réel (${data.test_holdings?.length || 0} assets, ${formatMoney(data.portfolio_summary.total_value)})
            </div>
          </div>
        `;
      }
      const m = data.risk_metrics;
      const c = data.correlation_metrics;
      const p = data.portfolio_summary;
      const balances = Array.isArray(data.balances) ? data.balances : [];

      // Quick insights from balances for concentration and stablecoins
      const insights = (() => {
        const total = Number(p?.total_value) || balances.reduce((a, b) => a + Number(b.value_usd || 0), 0);
        if (!total || (!balances || balances.length === 0)) {
          return { top5Share: null, hhi: null, stableShare: null };
        }
        const sorted = balances
          .filter(x => Number(x.value_usd) > 0)
          .sort((a, b) => Number(b.value_usd) - Number(a.value_usd));
        const weights = sorted.map(x => Number(x.value_usd) / total);
        const top5Share = weights.slice(0, 5).reduce((a, b) => a + b, 0);
        const hhi = weights.reduce((a, b) => a + b * b, 0);
        // Stablecoins share
        const STABLES = new Set(['USDC', 'USDT', 'USD', 'DAI', 'USTC']);
        const stableValue = sorted
          .filter(x => STABLES.has(String(x.symbol || '').toUpperCase()))
          .reduce((a, b) => a + Number(b.value_usd || 0), 0);
        const stableShare = stableValue / total;
        return { top5Share, hhi, stableShare };
      })();

      // Helper functions are defined at the top of the script

      // Prépare: HTML recommandations et alertes pour la section top-summary
      const recos = generateRecommendations(m, c, p.groups || {});
      const recommendationsHtml = (() => {
        return recos.map(rec => `
          <div class="recommendation recommendation-${rec.priority}">
            <div class="recommendation-header">
              <span class="recommendation-icon">${rec.icon}</span>
              <span class="recommendation-title">${rec.title}</span>
              <span class="recommendation-priority">${rec.priority === 'high' ? 'PRIORITÉ' : rec.priority === 'medium' ? 'Important' : 'Info'}</span>
            </div>
            <div class="recommendation-description">${rec.description}</div>
            <div class="recommendation-action">▶️ ${rec.action}</div>
          </div>
        `).join('');
      })();

      const alertCount = (data.alerts && data.alerts.length) ? data.alerts.length : 0;
      const severityCounts = { critical: 0, high: 0, medium: 0, low: 0, info: 0 };
      (data.alerts || []).forEach(a => {
        const lvl = String(a.level || '').toLowerCase();
        if (severityCounts.hasOwnProperty(lvl)) severityCounts[lvl]++;
      });
      const hasSevere = (severityCounts.critical + severityCounts.high) > 0;
      const breakdown = (() => {
        const parts = [];
        if (severityCounts.critical) parts.push(`${severityCounts.critical} critical`);
        if (severityCounts.high) parts.push(`${severityCounts.high} high`);
        if (severityCounts.medium) parts.push(`${severityCounts.medium} medium`);
        if (parts.length === 0) return '';
        return ` (${parts.join(', ')})`;
      })();
      const alertsHtml = (alertCount) ? (
        data.alerts.map(a => `
          <div class="alert alert-${a.level}">
            <strong>${a.message}</strong><br>
            <em>Recommendation: ${a.recommendation}</em>
          </div>
        `).join('')
      ) : `
        <div class="alert alert-low">
          <strong>✅ All Clear</strong><br>
          <em>No significant risk alerts at this time.</em>
        </div>
      `;

      container.innerHTML = `
        ${testModeBanner}
        <!-- Top Summary: Collapsible container -->
        <details class="top-collapsible" ${hasSevere ? 'open' : ''}>
          <summary>
            <div>Vue d’ensemble risques & recommandations</div>
            <div class="summary-right">
              <span class="badge badge-alerts">⚠️ ${alertCount} alertes${breakdown}</span>
              <span class="badge badge-recos">💡 ${recos.length} recos</span>
              <span class="chevron">›</span>
            </div>
          </summary>
          <div class="top-summary">
          <!-- Points clés -->
          <div class="risk-card">
            <h3>📋 Points clés de votre portfolio</h3>
            <div class="insights-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: .75rem;">
              <div class="insight-item">
                <div style="font-weight: 600; color: var(--theme-text);">🎯 Niveau de risque</div>
                <div style="color: var(--theme-text-muted); margin-top: 0.25rem;">
                  ${(() => {
          const riskScore = m.risk_score || 0;
          if (riskScore > 70) return 'Élevé - Attention aux corrections brutales';
          if (riskScore > 50) return 'Modéré - Typique pour crypto';
          return 'Contrôlé - Bon équilibre risque/rendement';
        })()}
                </div>
              </div>
              <div class="insight-item">
                <div style="font-weight: 600; color: var(--theme-text);">📊 Diversification</div>
                <div style="color: var(--theme-text-muted); margin-top: 0.25rem;">
                  ${(() => {
          const div = c.diversification_ratio || 0;
          if (div > 0.7) return 'Excellente - Portfolio bien réparti';
          if (div > 0.4) return 'Limitée - Possibilité d\'amélioration';
          return 'Faible - Trop corrélé, diversifiez';
        })()}
                </div>
              </div>
              <div class="insight-item">
                <div style="font-weight: 600; color: var(--theme-text);">⚡ Performance/Risque</div>
                <div style="color: var(--theme-text-muted); margin-top: 0.25rem;">
                  ${(() => {
          const sharpe = m.sharpe_ratio || 0;
          if (sharpe > 1.2) return 'Excellent - Rendement supérieur pour le risque pris';
          if (sharpe > 0.8) return 'Bon - Rendement acceptable pour le risque';
          return 'À améliorer - Risque élevé vs rendement';
        })()}
                </div>
              </div>
              <div class="insight-item">
                <div style="font-weight: 600; color: var(--theme-text);">🔝 Concentration</div>
                <div style="color: var(--theme-text-muted); margin-top: 0.25rem;">
                  ${(() => {
          const t5 = insights.top5Share;
          const hhi = insights.hhi;
          if (t5 == null || hhi == null) return 'N/A';
          return `Top 5: ${(t5 * 100).toFixed(1)}% • HHI: ${hhi.toFixed(2)}`;
        })()}
                </div>
              </div>
              <div class="insight-item">
                <div style="font-weight: 600; color: var(--theme-text);">💵 Stablecoins</div>
                <div style="color: var(--theme-text-muted); margin-top: 0.25rem;">
                  ${(() => {
          const s = insights.stableShare;
          return (s == null) ? 'N/A' : `${(s * 100).toFixed(1)}% du portefeuille`;
        })()}
                </div>
              </div>
              <div class="insight-item">
                <div style="font-weight: 600; color: var(--theme-text);">🧪 Données de calcul</div>
                <div style="color: var(--theme-text-muted); margin-top: 0.25rem;">
                  ${p.num_assets || (balances?.length || 'N/A')} actifs utilisés
                </div>
              </div>
            </div>
          </div>

          <!-- Risk Alerts -->
          <div class="risk-card">
            <h3>⚠️ Risk Alerts</h3>
            ${alertsHtml}
          </div>

          <!-- Recommandations d'amélioration -->
          <div class="risk-card">
            <h3>💡 Recommandations d'amélioration</h3>
            ${recommendationsHtml}
          </div>
          </div>
        </details>
        <!-- Portfolio Summary -->
        <div class="risk-card">
          <h3>📊 Portfolio Summary</h3>
          <div class="metric-row">
            <span class="metric-label">Total Value:</span>
            <span class="metric-value">${formatMoney(p.total_value)}</span>
          </div>
          <div class="metric-row">
            <span class="metric-label">Number of Assets:</span>
            <span class="metric-value">${p.num_assets}</span>
          </div>
          <div class="metric-row">
            <span class="metric-label">Data Confidence</span>
            <span class="metric-value">${safeFixed((p.confidence_level || 0) * 100, 1)}%</span>
          </div>
        </div>
        
        <!-- Key Insights moved to Top Summary -->

        <div class="risk-grid">
          <!-- VaR/CVaR -->
          <div class="risk-card">
            <h3>📉 Value at Risk (VaR) <span style="font-size:.8rem; color: var(--theme-text); opacity:.7; font-weight:500; margin-left:.5rem;"><br>lookback 30j (VaR), 60j (CVaR)</span></h3>
            <div class="metric-row">
              <span class="metric-label">VaR 95% (1 day)</span>
              <span class="metric-value hinted" data-key="var95_1d" data-value="${m.var_95_1d}" style="color: ${getMetricHealth('var_95_1d', m.var_95_1d).color}">
                ${formatPercent(m.var_95_1d)}
              </span>
            </div>
            <div class="metric-interpretation">
              💡 ${getMetricHealth('var_95_1d', m.var_95_1d).interpretation}
            </div>
            <div class="metric-row">
              <span class="metric-label">VaR 99% (1 day)</span>
              <span class="metric-value hinted" data-key="var99_1d" data-value="${m.var_99_1d}" style="color: ${getMetricHealth('var_99_1d', m.var_99_1d).color}">
                ${formatPercent(m.var_99_1d)}
              </span>
            </div>
            <div class="metric-interpretation">
              💡 ${getMetricHealth('var_99_1d', m.var_99_1d).interpretation}
            </div>
            <div class="metric-row">
              <span class="metric-label">CVaR 95% (1 day)</span>
              <span class="metric-value hinted" data-key="cvar95_1d" data-value="${m.cvar_95_1d}">${formatPercent(m.cvar_95_1d)}</span>
            </div>
            <div class="metric-row">
              <span class="metric-label">CVaR 99% (1 day)</span>
              <span class="metric-value hinted" data-key="cvar99_1d" data-value="${m.cvar_99_1d}">${formatPercent(m.cvar_99_1d)}</span>
            </div>
            <div class="metric-benchmark">
              📊 <strong>Benchmarks crypto:</strong> Conservateur: -4%, Typique: -7%, Agressif: -12%
            </div>
          </div>

          <!-- Performance -->
          <div class="risk-card">
            <h3>📈 Risk-Adjusted Performance <span style="font-size:.8rem; color: var(--theme-text); opacity:.7; font-weight:500; margin-left:.5rem;"><br>Vol 45j • Sharpe 90j • Sortino 120j • Calmar 365j</span></h3>
            <div class="metric-row">
              <span class="metric-label">Volatility (Annual)</span>
              <span class="metric-value hinted" data-key="volatility_ann" data-value="${m.volatility_annualized}" style="color: ${getMetricHealth('volatility_annualized', m.volatility_annualized).color}">
                ${formatPercent(m.volatility_annualized)}
              </span>
            </div>
            <div class="metric-interpretation">
              💡 ${getMetricHealth('volatility_annualized', m.volatility_annualized).interpretation}
            </div>
            <div class="metric-row">
              <span class="metric-label">Sharpe Ratio</span>
              <span class="metric-value hinted" data-key="sharpe" data-value="${m.sharpe_ratio}" style="color: ${getMetricHealth('sharpe_ratio', m.sharpe_ratio).color}">
                ${safeFixed(m.sharpe_ratio)}
              </span>
            </div>
            <div class="metric-interpretation">
              💡 ${getMetricHealth('sharpe_ratio', m.sharpe_ratio).interpretation}
            </div>
            <div class="metric-row">
              <span class="metric-label">Sortino Ratio</span>
              <span class="metric-value hinted" data-key="sortino" data-value="${m.sortino_ratio}" style="color: ${getMetricHealth('sortino_ratio', m.sortino_ratio).color}">
                ${safeFixed(m.sortino_ratio)}
              </span>
            </div>
            <div class="metric-interpretation">
              💡 ${getMetricHealth('sortino_ratio', m.sortino_ratio).interpretation}
            </div>
            <div class="metric-row">
              <span class="metric-label">Calmar Ratio</span>
              <span class="metric-value">${safeFixed(m.calmar_ratio)}</span>
            </div>
            <div class="metric-benchmark">
              📊 <strong>Benchmarks crypto:</strong> Excellent: >1.5, Bon: >1.0, Acceptable: >0.5 (Sharpe)
            </div>
          </div>

          <!-- Drawdowns -->
          <div class="risk-card">
            <h3>📊 Drawdown Analysis <span style="font-size:.8rem; color: var(--theme-text); opacity:.7; font-weight:500; margin-left:.5rem;"><br>lookback 180j</span></h3>
            <div class="metric-row">
              <span class="metric-label">Max Drawdown</span>
              <span class="metric-value hinted" data-key="max_drawdown" data-value="${m.max_drawdown}" style="color: ${getMetricHealth('max_drawdown', m.max_drawdown).color}">
                ${formatPercent(m.max_drawdown)}
              </span>
            </div>
            <div class="metric-interpretation">
              💡 ${getMetricHealth('max_drawdown', m.max_drawdown).interpretation}
            </div>
            <div class="metric-row">
              <span class="metric-label">Current Drawdown</span>
              <span class="metric-value hinted" data-key="current_drawdown" data-value="${m.current_drawdown}">${formatPercent(m.current_drawdown)}</span>
            </div>
            <div class="metric-row">
              <span class="metric-label">Risk Score</span>
              <span class="metric-value">${safeFixed(m.risk_score, 1)}/100</span>
            </div>
            <div class="metric-row">
              <span class="metric-label">Risk Level</span>
              <span class="risk-level risk-${(m.overall_risk_level || 'unknown').replace('_', '-')}">${(m.overall_risk_level || 'Unknown').replace('_', ' ')}</span>
            </div>
            <div class="metric-benchmark">
              📊 <strong>Crypto historique:</strong> Bon: -30%, Typique: -50%, Extrême: -70%+
            </div>
          </div>

          <!-- Diversification -->
          <div class="risk-card">
            <h3>🔗 Diversification Analysis <span style="font-size:.8rem; color: var(--theme-text); opacity:.7; font-weight:500; margin-left:.5rem;">corr 90j</span></h3>
            <div class="metric-row">
              <span class="metric-label">Diversification Ratio</span>
              <span class="metric-value hinted" data-key="diversification_ratio" data-value="${c.diversification_ratio}" style="color: ${getMetricHealth('diversification_ratio', c.diversification_ratio).color}">
                ${safeFixed(c.diversification_ratio)}
              </span>
            </div>
            <div class="metric-interpretation">
              💡 ${getMetricHealth('diversification_ratio', c.diversification_ratio).interpretation}
            </div>
            <div class="metric-row">
              <span class="metric-label">Effective Assets</span>
              <span class="metric-value hinted" data-key="effective_assets" data-value="${c.effective_assets}" style="color: ${getMetricHealth('effective_assets', c.effective_assets).color}">
                ${safeFixed(c.effective_assets, 1)}
              </span>
            </div>
            <div class="metric-interpretation">
              💡 ${getMetricHealth('effective_assets', c.effective_assets).interpretation}
            </div>
            <div class="metric-benchmark">
              📊 <strong>Diversification:</strong> Excellent: >0.7, Limité: 0.4-0.7, Faible: <0.4
            </div>

            ${c.top_correlations && c.top_correlations.length ? `
              <h4>Top Asset Correlations:</h4>
              ${c.top_correlations.slice(0, 3).map(t => `
                <div class="metric-row">
                  <span class="metric-label">${t.asset1} - ${t.asset2}:</span>
                  <span class="metric-value ${(Math.abs(t.correlation || 0) > 0.7) ? 'text-warning' : 'text-success'}">${((t.correlation || 0) * 100).toFixed(1)}%</span>
                </div>
              `).join('')}
            ` : ``}
          </div>
        </div>

        <!-- Recommendations moved to Top Summary -->

        <!-- Alerts moved to Top Summary -->
      `;

      // Après rendu : brancher les info-bulles et verdicts
      decorateRiskTooltips();
    }

    // ====== Bitcoin Cycle Chart Functions ======

    // Bitcoin halving historical data
    const BITCOIN_HALVINGS = [
      { date: '2012-11-28', block: 210000, reward_before: 50, reward_after: 25 },
      { date: '2016-07-09', block: 420000, reward_before: 25, reward_after: 12.5 },
      { date: '2020-05-11', block: 630000, reward_before: 12.5, reward_after: 6.25 },
      { date: '2024-04-20', block: 840000, reward_before: 6.25, reward_after: 3.125 },
      { date: '2028-04-20', block: 1050000, reward_before: 3.125, reward_after: 1.5625, estimated: true }
    ];

    // ----------- Fetch historique BTC fiable (sans mock) -----------
    async function fetchBitcoinHistoricalData() {
      console.log('🏛️ Tentative de récupération historique Bitcoin...');

      // 1) FRED via Proxy Backend (résout les problèmes CORS)
      try {
        console.log('🏛️ Récupération historique Bitcoin depuis FRED via proxy...');
        const proxyUrl = '/proxy/fred/bitcoin?start_date=2014-01-01';
        const r = await fetch(proxyUrl);
        if (!r.ok) throw new Error(`Proxy HTTP ${r.status}: ${r.statusText}`);
        const result = await r.json();

        if (result.success && result.data && result.data.length > 0) {
          console.log(`✅ FRED Proxy: ${result.data.length} points récupérés (première: $${result.data[0].price}, dernière: $${result.data[result.data.length - 1].price})`);
          console.log(`📊 Total disponible: ${result.raw_count} observations`);

          // Vérifier que les données commencent bien en 2014
          const firstDate = new Date(result.data[0].time);
          if (firstDate.getFullYear() <= 2014) {
            console.log(`🎯 HISTORIQUE COMPLET: Données depuis ${firstDate.getFullYear()}!`);
          }

          return {
            data: result.data.map(point => ({ time: point.time, price: point.price })),
            source: result.source
          };
        } else {
          console.warn('⚠️ FRED Proxy: Aucune donnée ou erreur -', result.error);
        }
      } catch (e) {
        console.warn('❌ FRED Proxy échoué, passage à Binance:', e.message);
      }

      // 2) Binance Klines (BTCUSDT) — 2017+, sans clé, paginé
      try {
        console.log('🟡 Récupération historique Bitcoin depuis Binance API...');
        const ONE_DAY = 24 * 60 * 60 * 1000;
        const LIMIT = 1000;
        const out = [];
        let start = Date.UTC(2017, 6, 1); // 1er juillet 2017
        const end = Date.now();
        let requestCount = 0;

        while (start < end) {
          const next = Math.min(start + ONE_DAY * (LIMIT - 1), end);
          const u = new URL('https://api.binance.com/api/v3/klines');
          u.searchParams.set('symbol', 'BTCUSDT');
          u.searchParams.set('interval', '1d');
          u.searchParams.set('startTime', String(start));
          u.searchParams.set('endTime', String(next));
          u.searchParams.set('limit', String(LIMIT));
          const r = await fetch(u.toString());
          if (!r.ok) throw new Error(`Binance HTTP ${r.status}: ${r.statusText}`);
          const rows = await r.json();
          if (!Array.isArray(rows) || rows.length === 0) break;
          for (const k of rows) {
            const openTime = k[0];           // ms
            const close = parseFloat(k[4]);  // close
            if (Number.isFinite(close)) out.push({ time: openTime, price: close });
          }
          start = rows[rows.length - 1][0] + ONE_DAY;
          requestCount++;
          await new Promise(res => setTimeout(res, 120)); // éviter rate limit
        }
        if (out.length > 0) {
          console.log(`✅ Binance: ${out.length} points récupérés en ${requestCount} requêtes (${out[0].price}$ à ${out[out.length - 1].price}$)`);
          return { data: out, source: 'Binance BTCUSDT (1d close)' };
        } else {
          console.warn('⚠️ Binance: Aucune donnée récupérée');
        }
      } catch (e) {
        console.error('❌ Binance fetch échoué:', e.message);
      }

      // 3) CoinGecko 365 jours (si on veut au moins la dernière année)
      try {
        console.log('🦎 Récupération historique Bitcoin depuis CoinGecko API (365j)...');
        const r = await fetch('https://api.coingecko.com/api/v3/coins/bitcoin/market_chart?vs_currency=usd&days=365&interval=daily');
        if (!r.ok) throw new Error(`CoinGecko HTTP ${r.status}: ${r.statusText}`);
        const j = await r.json();
        if (Array.isArray(j.prices)) {
          const data = j.prices.map(([t, p]) => ({ time: t, price: p }));
          if (data.length > 0) {
            console.log(`✅ CoinGecko: ${data.length} points récupérés (${data[0].price.toFixed(0)}$ à ${data[data.length - 1].price.toFixed(0)}$)`);
            return { data, source: 'CoinGecko (365j)' };
          } else {
            console.warn('⚠️ CoinGecko: Aucune donnée dans la réponse');
          }
        } else {
          console.warn('⚠️ CoinGecko: Format de réponse inattendu');
        }
      } catch (e) {
        console.error('❌ CoinGecko fetch échoué:', e.message);
      }

      // 4) Rien trouvé → renvoyer vide (pas de courbe prix)
      console.warn('❌ Aucune source d\'historique Bitcoin disponible');
      return { data: [], source: 'Aucune (toutes les APIs ont échoué)' };
    }

    // Create Bitcoin cycle chart
    async function createBitcoinCycleChart(canvasId, forceRefresh = false) {
      const canvas = document.getElementById(canvasId);
      if (!canvas) {
        console.error('Canvas not found:', canvasId);
        return null;
      }

      // Check cache first (unless forcing refresh)
      if (!forceRefresh) {
        const state = store.snapshot();
        const currentHash = generateCycleDataHash(state);
        const cachedChart = getCachedData('CYCLE_CHART');
        
        if (cachedChart?.chartConfig && cachedChart.dataHash === currentHash) {
          console.debug('⚡ Using cached chart config');
          
          // Destroy existing chart if it exists
          if (window.bitcoinCycleChart) {
            window.bitcoinCycleChart.destroy();
          }
          const existingChart = Chart.getChart(canvas);
          if (existingChart) {
            existingChart.destroy();
          }
          
          try {
            window.bitcoinCycleChart = new Chart(canvas, cachedChart.chartConfig);
            console.debug('✅ Chart recreated from cache');
            return window.bitcoinCycleChart;
          } catch (error) {
            console.warn('Failed to use cached chart, falling back to fresh creation:', error);
          }
        }
      }

      console.debug('🔄 Creating fresh Bitcoin cycle chart');

      // Destroy existing chart if it exists
      if (window.bitcoinCycleChart) {
        console.log('🔄 Destroying existing Bitcoin chart...');
        window.bitcoinCycleChart.destroy();
        window.bitcoinCycleChart = null;
      }

      // Also check if Chart.js has any existing chart on this canvas
      const existingChart = Chart.getChart(canvas);
      if (existingChart) {
        console.log('🔄 Destroying Chart.js existing chart on canvas...');
        existingChart.destroy();
      }

      try {
        // Fetch historical data
        const { data: historicalData, source } = await fetchBitcoinHistoricalData();

        // Get current cycle state
        const state = store.snapshot();
        const cycleData = state.cycle;

        // Prepare chart data (Bitcoin price - transparent background)
        const priceData = historicalData.map(point => ({
          x: point.time,
          y: point.price
        }));

        // Import cycle navigator functions et indicateurs on-chain
        const { cycleScoreFromMonths, getCyclePhase } = await import('./modules/cycle-navigator.js');
        const { fetchAllIndicators, enhanceCycleScore, analyzeDivergence } = await import('./modules/onchain-indicators.js');

        // 🎯 CALIBRATION HISTORIQUE AUTOMATIQUE (avec garde anti-boucle)
        try {
          // Si une calibration récente existe (< 24h), ne pas recalibrer à chaque rendu
          const saved = localStorage.getItem('bitcoin_cycle_params');
          let hasRecentCalibration = false;
          if (saved) {
            try {
              const parsed = JSON.parse(saved);
              if (parsed?.timestamp && (Date.now() - parsed.timestamp) < (24 * 60 * 60 * 1000)) {
                hasRecentCalibration = true;
              }
            } catch (_) { /* ignore parse error */ }
          }

          if (!hasRecentCalibration) {
            const { calibrateCycleParams } = await import('./modules/cycle-navigator.js');
            const calibRes = calibrateCycleParams();
            console.log('🎯 Calibration historique automatique (fresh):', calibRes);
          } else {
            console.debug('🎯 Calibration récente détectée - skip recalibration');
          }
        } catch (e) {
          console.warn('⚠️ Calibration automatique échouée:', e.message);
        }

        // Calculate cycle score for each data point
        // Also precompute phase colors (used when Adaptation contextuelle is enabled)
        const phaseColors = [];
        const cycleScoreData = historicalData.map(point => {
          const date = new Date(point.time);

          // Find which cycle period this date falls into
          let monthsAfterHalving = 0;
          for (let i = BITCOIN_HALVINGS.length - 1; i >= 0; i--) {
            const halving = BITCOIN_HALVINGS[i];
            const halvingDate = new Date(halving.date);

            if (date >= halvingDate && !halving.estimated) {
              const diffTime = date.getTime() - halvingDate.getTime();
              monthsAfterHalving = diffTime / (1000 * 60 * 60 * 24 * 30.44); // Convert to months
              break;
            }
          }

          // Calculate cycle score using the existing function
          const cycleScore = cycleScoreFromMonths(monthsAfterHalving);

          // Determine cycle phase color for this point (for contextual adaptation)
          try {
            const phase = getCyclePhase(monthsAfterHalving);
            phaseColors.push(phase?.color || '#10b981');
          } catch (_) {
            phaseColors.push('#10b981');
          }

          return {
            x: point.time,
            y: cycleScore
          };
        });

        // Current position marker
        const currentTimestamp = Date.now();
        const currentPrice = priceData[priceData.length - 1]?.y || 108000; // Prix actuel ~$108k

        console.log('📊 Bitcoin price data loaded:', {
          dataPoints: priceData.length,
          latestPrice: currentPrice,
          dataSource: priceData.length > 100 ? 'CoinGecko API' : 'Insufficient data'
        });

        // Chart configuration
        const config = {
          type: 'line',
          data: {
            datasets: [
              {
                label: 'Bitcoin Price (USD)',
                data: priceData,
                borderColor: 'rgba(247, 147, 26, 0.15)', // Bitcoin orange très transparent (arrière-plan)
                backgroundColor: 'rgba(247, 147, 26, 0.02)',
                borderWidth: 1,
                fill: false,
                yAxisID: 'y',
                pointRadius: 0, // Pas de points visibles
                pointHoverRadius: 3,
                order: 2 // Afficher en arrière-plan
              },
              {
                label: 'Cycle Score',
                data: cycleScoreData,
                borderColor: '#10b981', // Green - ligne principale visible
                backgroundColor: 'rgba(16, 185, 129, 0.1)',
                borderWidth: 3, // Plus épaisse pour être la ligne principale
                fill: false,
                yAxisID: 'y1',
                pointRadius: 0,
                pointHoverRadius: 4,
                order: 1, // Afficher au premier plan
                // Custom color by phase when Adaptation contextuelle is enabled
                phaseColors: phaseColors,
                segment: {
                  borderColor: (ctx) => {
                    try {
                      const enabled = localStorage.getItem('enable_dynamic_weighting') === 'true';
                      if (!enabled) return '#10b981';
                      const idx = ctx.p0DataIndex;
                      const color = ctx?.dataset?.phaseColors?.[idx];
                      return color || '#10b981';
                    } catch (_) {
                      return '#10b981';
                    }
                  }
                }
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            layout: {
              padding: {
                bottom: 80  // Reserve space for timeline
              }
            },
            interaction: {
              intersect: false,
              mode: 'index'
            },
            plugins: {
              title: {
                display: true,
                text: 'Bitcoin Cycle Analysis - Historical Price & Position',
                font: { size: 16 }
              },
              legend: {
                display: true,
                position: 'top'
              },
              tooltip: {
                callbacks: {
                  title: function (context) {
                    const date = new Date(context[0].parsed.x);
                    return date.toLocaleDateString('fr-FR');
                  },
                  label: function (context) {
                    const dataset = context.dataset;
                    const value = context.parsed.y;

                    if (dataset.label.includes('Price')) {
                      return `Prix: $${value.toLocaleString()}`;
                    } else {
                      return `Cycle Score: ${Math.round(value)}/100`;
                    }
                  }
                }
              }
            },
            scales: {
              x: {
                type: 'time',
                time: {
                  unit: 'year',
                  displayFormats: {
                    year: 'yyyy'
                  }
                },
                title: {
                  display: true,
                  text: 'Date'
                },
                max: new Date(Date.now() + (30 * 24 * 60 * 60 * 1000)) // Add 30 days padding to the right
              },
              y: {
                type: 'logarithmic',
                position: 'left',
                title: {
                  display: true,
                  text: 'Prix Bitcoin (USD, échelle log)'
                },
                ticks: {
                  callback: function (value) {
                    return '$' + value.toLocaleString();
                  }
                }
              },
              y1: {
                type: 'linear',
                position: 'right',
                min: 0,
                max: 100,
                title: {
                  display: true,
                  text: 'Score de Cycle (0-100)'
                },
                grid: {
                  drawOnChartArea: false
                }
              }
            }
          },
          plugins: [{
            id: 'halvingLines',
            afterDraw: function (chart) {
              const ctx = chart.ctx;
              const xAxis = chart.scales.x;
              const yAxis = chart.scales.y;

              // Draw halving vertical lines
              BITCOIN_HALVINGS.forEach((halving, index) => {
                if (halving.estimated) return; // Skip estimated future halving

                const halvingDate = new Date(halving.date);
                const x = xAxis.getPixelForValue(halvingDate.getTime());

                if (x >= xAxis.left && x <= xAxis.right) {
                  ctx.save();
                  ctx.strokeStyle = '#8b5cf6'; // Purple color
                  ctx.lineWidth = 2;
                  ctx.setLineDash([5, 5]);

                  ctx.beginPath();
                  ctx.moveTo(x, yAxis.top + 10);
                  ctx.lineTo(x, yAxis.bottom);
                  ctx.stroke();

                  // Label
                  ctx.fillStyle = '#8b5cf6';
                  ctx.font = '12px sans-serif';
                  ctx.textAlign = 'center';
                  ctx.fillText(
                    `Halving ${index + 1}`,
                    x,
                    yAxis.top + 10
                  );
                  ctx.restore();
                }
              });

              // Historical cycle highs data
              const CYCLE_INTERVALS = [
                {
                  halving: { date: '2012-11-28', name: 'Halving 1' },
                  peak: { date: '2013-11-30', name: 'ATH Cycle 1' },
                  cycle: 1
                },
                {
                  halving: { date: '2016-07-09', name: 'Halving 2' },
                  peak: { date: '2017-12-17', name: 'ATH Cycle 2' },
                  cycle: 2
                },
                {
                  halving: { date: '2020-05-11', name: 'Halving 3' },
                  peak: { date: '2021-11-10', name: 'ATH Cycle 3' },
                  cycle: 3
                },
                {
                  halving: { date: '2024-04-20', name: 'Halving 4' },
                  peak: { date: new Date().toISOString().split('T')[0], name: 'Aujourd\'hui' },
                  cycle: 4,
                  isCurrent: true
                }
              ];


              // Calculate days until next halving
              const nextHalving = BITCOIN_HALVINGS.find(h => h.estimated);
              const daysUntilHalving = nextHalving ?
                Math.ceil((new Date(nextHalving.date).getTime() - currentTimestamp) / (1000 * 60 * 60 * 24)) :
                null;

              // Draw timeline bar at bottom
              const timelineY = yAxis.bottom + 40;
              const timelineHeight = 50;

              // Draw background bar
              ctx.save();
              ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
              ctx.fillRect(xAxis.left, timelineY, xAxis.right - xAxis.left, timelineHeight);
              ctx.restore();

              // Draw historical cycle intervals (1, 2, 3)
              CYCLE_INTERVALS.filter(interval => !interval.isCurrent).forEach((interval) => {
                const halvingDate = new Date(interval.halving.date);
                const peakDate = new Date(interval.peak.date);

                const halvingX = xAxis.getPixelForValue(halvingDate.getTime());
                const peakX = xAxis.getPixelForValue(peakDate.getTime());

                if (halvingX >= xAxis.left && peakX <= xAxis.right) {
                  const daysDiff = Math.ceil((peakDate.getTime() - halvingDate.getTime()) / (1000 * 60 * 60 * 24));

                  ctx.save();

                  // Draw arrow line
                  const arrowY = timelineY + timelineHeight / 2;
                  ctx.strokeStyle = `hsl(${120 + interval.cycle * 60}, 70%, 50%)`;
                  ctx.lineWidth = 3;

                  ctx.beginPath();
                  ctx.moveTo(halvingX, arrowY);
                  ctx.lineTo(peakX, arrowY);
                  ctx.stroke();

                  // Draw arrow head
                  const arrowSize = 8;
                  ctx.fillStyle = ctx.strokeStyle;
                  ctx.beginPath();
                  ctx.moveTo(peakX, arrowY);
                  ctx.lineTo(peakX - arrowSize, arrowY - arrowSize / 2);
                  ctx.lineTo(peakX - arrowSize, arrowY + arrowSize / 2);
                  ctx.closePath();
                  ctx.fill();

                  // Draw start point (halving)
                  ctx.fillStyle = '#8b5cf6';
                  ctx.beginPath();
                  ctx.arc(halvingX, arrowY, 4, 0, 2 * Math.PI);
                  ctx.fill();

                  // Draw end point (peak)  
                  ctx.fillStyle = '#f59e0b';
                  ctx.beginPath();
                  ctx.arc(peakX, arrowY, 4, 0, 2 * Math.PI);
                  ctx.fill();

                  // Add days label in the middle
                  const midX = (halvingX + peakX) / 2;
                  ctx.fillStyle = '#6b7280';
                  ctx.font = 'bold 11px sans-serif';
                  ctx.textAlign = 'center';
                  ctx.fillText(
                    `${daysDiff} jours`,
                    midX,
                    arrowY - 8
                  );

                  // Add cycle label below
                  ctx.font = '9px sans-serif';
                  ctx.fillStyle = '#6b7280';
                  ctx.fillText(
                    `Cycle ${interval.cycle}`,
                    midX,
                    arrowY + 15
                  );

                  ctx.restore();
                }
              });

              // Draw current cycle (4) from last halving to current position
              const currentCycle = CYCLE_INTERVALS.find(interval => interval.isCurrent);
              if (currentCycle) {
                const halvingDate = new Date(currentCycle.halving.date);
                const halvingX = xAxis.getPixelForValue(halvingDate.getTime());
                const currentX_timeline = xAxis.getPixelForValue(currentTimestamp);

                if (halvingX >= xAxis.left && currentX_timeline <= xAxis.right + 10) {
                  const daysSinceHalving = Math.ceil((currentTimestamp - halvingDate.getTime()) / (1000 * 60 * 60 * 24));

                  ctx.save();

                  // Draw current cycle arrow (same style as other cycles)
                  const arrowY = timelineY + timelineHeight / 2;
                  ctx.strokeStyle = `hsl(${120 + 4 * 60}, 70%, 50%)`; // Same color pattern as other cycles
                  ctx.lineWidth = 3; // Same width as other cycles

                  ctx.beginPath();
                  ctx.moveTo(halvingX, arrowY);
                  ctx.lineTo(currentX_timeline, arrowY);
                  ctx.stroke();

                  // Draw arrow head (same size as other cycles)
                  const arrowSize = 8;
                  ctx.fillStyle = ctx.strokeStyle;
                  ctx.beginPath();
                  ctx.moveTo(currentX_timeline, arrowY);
                  ctx.lineTo(currentX_timeline - arrowSize, arrowY - arrowSize / 2);
                  ctx.lineTo(currentX_timeline - arrowSize, arrowY + arrowSize / 2);
                  ctx.closePath();
                  ctx.fill();

                  // Draw start point (halving 4)
                  ctx.fillStyle = '#8b5cf6';
                  ctx.beginPath();
                  ctx.arc(halvingX, arrowY, 4, 0, 2 * Math.PI);
                  ctx.fill();

                  // Draw end point (current position)  
                  ctx.fillStyle = '#f59e0b';
                  ctx.beginPath();
                  ctx.arc(currentX_timeline, arrowY, 4, 0, 2 * Math.PI);
                  ctx.fill();

                  // Add days label in the middle (same style as other cycles)
                  const midX = (halvingX + currentX_timeline) / 2;
                  ctx.fillStyle = '#6b7280';
                  ctx.font = 'bold 11px sans-serif';
                  ctx.textAlign = 'center';
                  ctx.fillText(
                    `${daysSinceHalving} jours (en cours)`,
                    midX,
                    arrowY - 8
                  );

                  // Add cycle label below
                  ctx.font = '9px sans-serif';
                  ctx.fillStyle = '#6b7280';
                  ctx.fillText(
                    'Cycle 4 (actuel)',
                    midX,
                    arrowY + 15
                  );

                  ctx.restore();
                }
              }

              // Draw current position line - ALWAYS show it
              const currentX = xAxis.getPixelForValue(currentTimestamp);

              if (currentX >= xAxis.left && currentX <= xAxis.right) {
                ctx.save();
                ctx.strokeStyle = '#ef4444'; // Red color for current position
                ctx.lineWidth = 2;

                ctx.beginPath();
                ctx.moveTo(currentX, yAxis.top);
                ctx.lineTo(currentX, yAxis.bottom);
                ctx.stroke();

                // Current position label
                ctx.fillStyle = '#ef4444';
                ctx.font = 'bold 12px sans-serif';
                ctx.textAlign = 'center';

                // Add current date info
                ctx.font = '10px sans-serif';
                const currentDateStr = new Date(currentTimestamp).toLocaleDateString('fr-FR');
                ctx.fillText(
                  currentDateStr,
                  currentX,
                  yAxis.top - 25
                );

                ctx.restore();
              }

              // Dynamic weighting badge removed per request (clutter)
            }
          },
          {
            id: 'phaseColoredCycleSegments',
            afterDatasetsDraw(chart) {
              try {
                const enabled = localStorage.getItem('enable_dynamic_weighting') === 'true';
                if (!enabled) return;

                const dsIndex = chart.data.datasets.findIndex(d => d.label === 'Cycle Score');
                if (dsIndex === -1) return;
                const meta = chart.getDatasetMeta(dsIndex);
                const ds = chart.data.datasets[dsIndex];
                const points = meta.data || [];
                const colors = ds.phaseColors || [];
                const ctx = chart.ctx;

                if (points.length < 2) return;

                ctx.save();
                ctx.lineWidth = (ds.borderWidth || 3) + 0.5; // draw slightly thicker overlay
                ctx.lineJoin = 'round';
                ctx.lineCap = 'round';

                for (let i = 0; i < points.length - 1; i++) {
                  const p0 = points[i];
                  const p1 = points[i + 1];
                  const c = colors[i] || '#10b981';
                  // Skip if points are not in chart area
                  if (!p0 || !p1 || !isFinite(p0.x) || !isFinite(p0.y) || !isFinite(p1.x) || !isFinite(p1.y)) continue;

                  ctx.strokeStyle = c;
                  ctx.beginPath();
                  ctx.moveTo(p0.x, p0.y);
                  ctx.lineTo(p1.x, p1.y);
                  ctx.stroke();
                }

                ctx.restore();
              } catch (e) {
                console.warn('phaseColoredCycleSegments plugin failed:', e);
              }
            }
          }]
        };

        // Create chart
        window.bitcoinCycleChart = new Chart(canvas, config);
        console.log('✅ Bitcoin cycle chart created successfully');

        // 🔗 Charger et afficher les indicateurs on-chain après un délai
        setTimeout(() => {
          loadOnChainIndicators().catch(err => {
            console.error('Failed to load on-chain indicators:', err);
          });
        }, 1000);

        // Cache the chart configuration for future use
        try {
          const state = store.snapshot();
          const currentHash = generateCycleDataHash(state);
          const chartConfig = window.bitcoinCycleChart.config;
          
          setCachedData('CYCLE_CHART', {
            chartConfig: JSON.parse(JSON.stringify(chartConfig)), // Deep clone
            dataHash: currentHash,
            timestamp: Date.now()
          });
          
          console.debug('💾 Chart configuration cached');
        } catch (cacheError) {
          console.warn('Failed to cache chart config:', cacheError);
        }

        return window.bitcoinCycleChart;

      } catch (error) {
        console.error('❌ Failed to create Bitcoin cycle chart:', error);

        // Show error message in canvas container
        const container = canvas.parentElement;
        container.innerHTML = `
          <div style="text-align: center; padding: 2rem; color: var(--theme-text-muted);">
            <div style="font-size: 1.2rem; margin-bottom: 1rem;">⚠️ Impossible de charger le graphique des cycles</div>
            <div style="font-size: 0.9rem;">Erreur: ${error.message}</div>
            <div style="font-size: 0.8rem; margin-top: 0.5rem;">Essayez de rafraîchir la page ou vérifiez votre connexion.</div>
          </div>
        `;

        return null;
      }
    }

    // Make chart creator available to lazy-loaded component
    // Ensures BitcoinCycleChart.init() can call it after Chart.js loads
    if (!window.createBitcoinCycleChart) {
      window.createBitcoinCycleChart = createBitcoinCycleChart;
    }

    // ====== On-Chain Indicators (version themée) ======
    async function loadOnChainIndicators() {
      try {
        console.log('🔄 Loading on-chain indicators modules...');
        const onchainModule = await import('./modules/onchain-indicators.js');
        const cycleModule = await import('./modules/cycle-navigator.js');

        const { fetchAllIndicators, calculateCompositeScore, enhanceCycleScore, analyzeDivergence, generateRecommendations } = onchainModule;
        const { cycleScoreFromMonths, getCurrentCycleMonths } = cycleModule;

        const container = document.getElementById('onchain-indicators-content');
        if (!container) { console.warn('⚠️ onchain-indicators container not found'); return; }

        // État de chargement (thémé)
        container.innerHTML = `
        <div class="loading" style="background: var(--theme-surface); border: 1px solid var(--theme-border); border-radius: var(--radius-md); padding: var(--space-lg);">
          🔄 Récupération des indicateurs...
        </div>
      `;

        // Données
        const indicators = await fetchAllIndicators();

        // Check if dynamic weighting is enabled (from localStorage setting)
        const useDynamicWeighting = localStorage.getItem('enable_dynamic_weighting') === 'true';
        const composite = calculateCompositeScoreV2(indicators, useDynamicWeighting);

        if (useDynamicWeighting && composite.dynamicWeighting) {
          console.log(`🤖 Dynamic weighting applied in UI: ${composite.dynamicWeighting.phase.name} phase`);
        }

        // Score de cycle actuel
        const cycleData = getCurrentCycleMonths();
        const sigmoidScore = cycleScoreFromMonths(cycleData.months);
        const divergence = analyzeDivergence(sigmoidScore, indicators);
        const enhanced = await enhanceCycleScore(sigmoidScore, 0.25);
        // Propager le score composite vers la sidebar via le store
        try {
          if (composite && typeof composite.score === 'number') {
            const prevOn = store.get ? store.get('scores.onchain') : undefined;
            if (prevOn !== composite.score) {
              store.set('scores.onchain', composite.score);
            } else {
              console.debug('↔︎ On-chain score unchanged; not updating store');
            }
          }
        } catch (e) { console.warn('Failed to propagate onchain score to store:', e); }
        const recos = generateRecommendations(enhanced) || [];

        // Utilitaires couleur (se basent uniquement sur les vars de thème)
        const pickScoreColor = (score) => {
          if (score == null) return 'var(--theme-text)';
          if (score > 70) return 'var(--danger)';     // zone chaude (souvent “surchauffe” on-chain)
          if (score < 40) return 'var(--success)';    // zone favorable
          return 'var(--warning)';                    // zone neutre/attention
        };

        const card = (inner, { accentLeft = null, pad = true } = {}) => `
        <div
          class="themed-card"
          style="
            background: var(--theme-surface);
            border: 1px solid var(--theme-border);
            border-radius: var(--radius-md);
            ${pad ? 'padding: var(--space-lg);' : ''}
            ${accentLeft ? `border-left: 4px solid ${accentLeft};` : ''}
          "
        >${inner}</div>
      `;

        // Catégories V2 (On-Chain Pure, Cycle/Technical, Sentiment, Market Context)
        let categoryDisplay = '';
        if (composite.categoryBreakdown) {
          categoryDisplay = Object.entries(composite.categoryBreakdown).map(([key, data]) => {
            const emoji =
              key === 'onchain_pure' ? '🔗' :
                key === 'cycle_technical' ? '📊' :
                  key === 'sentiment_social' ? '😨' :
                    key === 'market_context' ? '🌐' :
                      '📈'; // fallback

            const scoreColor = pickScoreColor(data.score);

            // Consensus signal display
            const consensus = data.consensus;
            const consensusEmoji =
              consensus?.consensus === 'bullish' ? '🟢' :
                consensus?.consensus === 'bearish' ? '🔴' :
                  '⚪';
            const consensusText = consensus ?
              `${consensusEmoji} ${consensus.consensus} (${consensus.confidence}%)` :
              '⚪ neutral';

            // Dynamic weighting display
            const isDynamic = localStorage.getItem('enable_dynamic_weighting') === 'true';
            const currentWeight = Math.round((data.weight || 0) * 100);
            const staticWeight = Math.round((data.staticWeight || 0) * 100);

            let weightDisplay = '';
            if (isDynamic && data.staticWeight && Math.abs(currentWeight - staticWeight) >= 1) {
              const change = currentWeight - staticWeight;
              const changeColor = change > 0 ? 'var(--success)' : 'var(--danger)';
              const changeText = change > 0 ? `+${change}` : `${change}`;
              weightDisplay = `Poids: ${currentWeight}% <span style="color: ${changeColor}; font-weight: 600;">(${changeText}% vs statique)</span>`;
            } else {
              weightDisplay = `Poids: ${currentWeight}%`;
            }

            return card(`
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom: .25rem;">
              <span style="font-weight:600; color: var(--theme-text);">${emoji} ${data.description || key}</span>
              <span style="font-size: 1.25rem; font-weight: 700; color: ${scoreColor};">${data.score}/100</span>
            </div>
            <div style="font-size:.75rem; color: var(--theme-text-muted); margin-bottom: 0.25rem;">
              ${data.contributorsCount} indicateur(s) • ${weightDisplay}
            </div>
            <div style="font-size:.75rem; padding: 2px 6px; background: var(--theme-surface-alt); border-radius: 4px; color: var(--theme-text-muted);">
              Consensus: ${consensusText}
            </div>
          `, { pad: true });
          }).join('');
        }

        // Alertes critiques
        let criticalAlertsHtml = '';
        if ((composite.criticalZoneCount || 0) > 0) {
          const criticalIndicators = (composite.contributors || []).filter(c => c.inCriticalZone);
          criticalAlertsHtml = card(`
          <h5 style="margin:0 0 .5rem 0; color: var(--danger);">🚨 ${composite.criticalZoneCount} Zone(s) critique(s)</h5>
          ${criticalIndicators.slice(0, 3).map(ind => `
            <div style="font-size:.85rem; color: var(--danger); margin:.25rem 0;">
              • ${ind.name}: ${ind.originalValue}% ${ind.raw_threshold ? `(seuil: ${ind.raw_threshold})` : ''}
            </div>
          `).join('')}
          ${criticalIndicators.length > 3 ? `
            <div style="font-size:.75rem; color: var(--theme-text-muted);">…et ${criticalIndicators.length - 3} autre(s)</div>
          ` : ''}
        `, { accentLeft: 'var(--danger)' });
        }

        // Grille d’indicateurs unitaires
        const indicatorsGrid = Object.entries(indicators).map(([key, data]) => {
          if (key.startsWith('_') || !data || typeof data !== 'object') return '';

          const name = data.name || key;
          const value = (typeof data.value_numeric === 'number') ? data.value_numeric :
            (typeof data.value === 'number' ? data.value : null);
          const isCritical = !!data.in_critical_zone;

          // Couleur numérique (pas de codes fixes)
          let valueColor = 'var(--theme-text)';
          if (isCritical) valueColor = 'var(--danger)';
          else if (typeof value === 'number') {
            if (value < 30) valueColor = 'var(--success)';
            else if (value > 70) valueColor = 'var(--warning)';
            else valueColor = 'var(--theme-text)';
          }

          // Affichage valeur
          let displayValue = (value == null || Number.isNaN(value))
            ? (data.value ?? 'N/A')
            : `${value.toFixed(1)}%`;

          if (name.toLowerCase().includes('fear') && name.toLowerCase().includes('greed')) {
            // index 0..100
            displayValue = `${(value ?? data.value ?? 'N/A')}/100`;
          }

          return `
          <div
            class="indicator-card"
            style="
              background: var(--theme-surface);
              border: 1px solid ${isCritical ? 'var(--danger)' : 'var(--theme-border)'};
              border-radius: var(--radius-md);
              padding: .8rem;
              text-align: center;
              ${isCritical ? 'box-shadow: 0 2px 10px rgba(0,0,0,.12);' : ''}
            "
          >
            <div style="font-size:.8rem; color: var(--theme-text-muted); margin-bottom:.3rem;">
              ${isCritical ? '🚨 ' : ''}${name}
            </div>
            <div style="font-size:1.1rem; font-weight:700; color:${valueColor}; margin-bottom:.2rem;">
              ${displayValue}
            </div>
            <div style="font-size:.75rem; color: var(--theme-text-muted);">
              ${data.raw_threshold ? `Seuil: ${data.raw_threshold}` : `Source: ${data.source || 'N/A'}`}
            </div>
            ${isCritical ? '<div style="font-size:.7rem; color: var(--danger); margin-top:.25rem; font-weight:600;">ZONE CRITIQUE</div>' : ''}
          </div>
        `;
        }).filter(Boolean).join('');

        // Bloc top : Score composite & Divergence
        const topGrid = `
        <div style="display:grid; grid-template-columns: 1fr 1fr; gap: var(--space-md); margin-bottom: var(--space-md);">
          ${card(`
            <h4 style="margin:0 0 .5rem 0; color: var(--theme-text);">🎯 Score Composite V2 
              <span style="font-size:0.7rem; background: var(--success); color: white; padding: 2px 6px; border-radius: 4px; margin-left: 8px;">NEW</span>
              ${localStorage.getItem('enable_dynamic_weighting') === 'true' ? '<span style="font-size:0.7rem; background: var(--warning); color: white; padding: 2px 6px; border-radius: 4px; margin-left: 4px;">🤖 DYNAMIC</span>' : ''}
            </h4>
            <div style="font-size:2rem; font-weight:700; color:${pickScoreColor(composite.score)};">
              ${composite.score !== null ? `${composite.score}/100` : 'N/A'}
            </div>
            <div style="font-size:.85rem; color: var(--theme-text-muted);">
              ${(composite.totalIndicators ?? 0)} indicateurs • Confiance: ${Math.round((composite.confidence || 0) * 100)}% • Corrélations gérées
              ${localStorage.getItem('enable_dynamic_weighting') === 'true' && composite.dynamicWeighting ? `<br>Phase: ${composite.dynamicWeighting.phase.name}` : ''}
            </div>
          `)}
          ${card(`
            <h4 style="margin:0 0 .5rem 0; color: var(--theme-text);">🔍 Divergence</h4>
            <div style="font-size:1.2rem; font-weight:700; color:${divergence.divergence_magnitude > 20 ? 'var(--danger)' : 'var(--success)'};">
              ${divergence.signal === 'convergence' ? '✅' : '⚠️'} ${divergence.divergence_magnitude.toFixed(1)} pts
            </div>
            <div style="font-size:.85rem; color: var(--theme-text-muted);">${divergence.message}</div>
          `)}
        </div>
        
        ${localStorage.getItem('enable_dynamic_weighting') === 'true' && composite.dynamicWeighting ? card(`
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: .75rem;">
            <h4 style="margin:0; color: var(--warning);">🤖 Pondération Dynamique Active</h4>
            <button onclick="toggleSection('dynamic-weighting-info')" style="background: none; border: 1px solid var(--theme-border); border-radius: 4px; padding: 4px 8px; cursor: pointer; color: var(--theme-text); font-size: 0.8rem;" title="Réduire/Agrandir">
              <span id="dynamic-weighting-info-arrow">▼</span>
            </button>
          </div>
          <div id="dynamic-weighting-info-content">
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; margin-bottom: 0.75rem;">
              <div style="padding: 0.75rem; background: var(--theme-bg); border-radius: 6px; border-left: 3px solid var(--warning);">
                <div style="font-weight: 600; color: var(--warning); margin-bottom: 0.25rem;">Phase Détectée</div>
                <div style="font-size: 1.1rem; font-weight: 700; color: var(--theme-text);">${composite.dynamicWeighting.phase.name}</div>
                <div style="font-size: 0.8rem; color: var(--theme-text-muted); margin-top: 0.25rem;">${composite.dynamicWeighting.phase.description}</div>
              </div>
              <div style="padding: 0.75rem; background: var(--theme-bg); border-radius: 6px; border-left: 3px solid var(--info);">
                <div style="font-weight: 600; color: var(--info); margin-bottom: 0.25rem;">Score Range</div>
                <div style="font-size: 1.1rem; font-weight: 700; color: var(--theme-text);">${composite.dynamicWeighting.phase.scoreRange[0]}-${composite.dynamicWeighting.phase.scoreRange[1]}</div>
                <div style="font-size: 0.8rem; color: var(--theme-text-muted); margin-top: 0.25rem;">Score actuel: ${composite.score !== null ? composite.score : 'N/A'}</div>
              </div>
            </div>
            <div style="padding: 0.5rem; background: var(--theme-surface-alt); border-radius: 6px; margin-bottom: 0.5rem;">
              <div style="font-weight: 600; margin-bottom: 0.25rem; color: var(--theme-text);">💡 Logique d'adaptation:</div>
              ${composite.dynamicWeighting.reasoning.map(reason =>
          `<div style="font-size: 0.85rem; color: var(--theme-text-muted); margin: 0.1rem 0;">• ${reason}</div>`
        ).join('')}
            </div>
          </div>
        `, { accentLeft: 'var(--warning)' }) : ''}
      `;

        // Bloc catégories V2 (sans collapse button)
        const categoriesBlock = composite.categoryBreakdown
          ? card(`
            <h4 style="margin:0 0 .75rem 0; color: var(--theme-text);">📊 Répartition par catégorie V2</h4>
            <div style="display:grid; grid-template-columns: 1fr 1fr; gap:.75rem;">
              ${categoryDisplay}
            </div>
          `)
          : '';

        // Bloc signaux contradictoires V2
        const contradictorySignals = analyzeContradictorySignals(composite.categoryBreakdown || {});
        const contradictionsBlock = contradictorySignals.length > 0
          ? card(`
            <h4 style="margin:0 0 .75rem 0; color: var(--warning);">⚠️ Signaux contradictoires détectés</h4>
            <div style="display:grid; grid-template-columns:1fr; gap:.5rem;">
              ${contradictorySignals.map(signal => `
                <div style="padding:.5rem; background: var(--theme-bg); border:1px solid var(--warning); border-radius: var(--radius-sm);">
                  <div style="font-weight:600; color: var(--warning); margin-bottom:.25rem;">
                    ${signal.category1.name} vs ${signal.category2.name}
                  </div>
                  <div style="font-size:.85rem; color: var(--theme-text-muted);">
                    ${signal.category1.signal} (${signal.category1.confidence}%) ↔️ ${signal.category2.signal} (${signal.category2.confidence}%)
                  </div>
                  <div style="font-size:.8rem; color: var(--theme-text-muted); font-style: italic; margin-top:.25rem;">
                    💡 ${signal.recommendation}
                  </div>
                </div>
              `).join('')}
            </div>
          `, { accentLeft: 'var(--warning)' })
          : '';

        // Bloc indicateurs grille
        const gridBlock = `
        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap:.75rem; margin-bottom: var(--space-md);">
          ${indicatorsGrid}
        </div>
      `;

        // Recommandations (optionnel)
        const recosBlock = (recos.length > 0)
          ? card(`
            <h4 style="margin:0 0 .5rem 0; color: var(--info);">💡 Recommandations</h4>
            ${recos.slice(0, 2).map(r => `
              <div style="margin:.5rem 0; padding:.5rem; background: var(--theme-bg); border:1px solid var(--theme-border); border-radius: var(--radius-sm);">
                <div style="font-weight:700; color: var(--theme-text);">${r.title}</div>
                <div style="font-size:.9rem; margin:.2rem 0; color: var(--theme-text);">${r.message}</div>
                <div style="font-size:.8rem; color: var(--theme-text-muted); font-style: italic;">▶️ ${r.action}</div>
              </div>
            `).join('')}
          `, { accentLeft: 'var(--info)' })
          : '';

        // Rendu final
        container.innerHTML = `
        ${criticalAlertsHtml}
        ${topGrid}
        ${categoriesBlock}
        ${contradictionsBlock}
        ${gridBlock}
        ${recosBlock}
      `;

        // Appliquer l'état du toggle après rendu
        try { initializeDynamicWeightingToggle(); } catch (e) { console.warn('Init toggle failed', e); }

        console.log('✅ Indicateurs on-chain (thémés) chargés:', { sigmoidScore, composite: composite.score, enhanced: enhanced.enhanced_score });
      } catch (error) {
        console.error('❌ Erreur indicateurs on-chain:', error);
        const container = document.getElementById('onchain-indicators-content');
        if (container) {
          container.innerHTML = `
          <div class="error" style="background: var(--danger-bg); color: var(--danger); border: 1px solid var(--danger); border-radius: var(--radius-md); padding: var(--space-lg);">
            ⚠️ Erreur de chargement des indicateurs: ${error.message}
          </div>
        `;
        }
      }
    }

    // ====== Cycles Content ======
    
    /**
     * Cached version of renderCyclesContent - checks cache before rendering
     */
    async function renderCyclesContent(forceRefresh = false) {
      const container = document.getElementById('cycles-content');
      const state = store.snapshot();
      const currentHash = generateCycleDataHash(state);

      // Short-circuit: if nothing changed and DOM already has the chart, skip any DOM work
      if (!forceRefresh && window.lastCycleContentHash === currentHash) {
        const canvas = document.getElementById('bitcoin-cycle-chart');
        const existing = canvas ? (window.bitcoinCycleChart || (window.Chart && Chart.getChart(canvas))) : null;
        if (existing) {
          console.debug('⚡ Cycles unchanged, skipping render');
          return;
        }
      }

      // Check if we should refresh based on data changes
      if (!forceRefresh) {
        const refreshCheck = shouldRefreshCycleContent(state);

        if (!refreshCheck.shouldRefresh) {
          // Use cached content only if not already present in DOM
          const cachedContent = getCachedData('CYCLE_CONTENT');
          if (cachedContent?.htmlContent) {
            const hasCanvas = !!document.getElementById('bitcoin-cycle-chart');
            if (!hasCanvas) {
              console.debug('⚡ Using cached cycle content (first paint)');
              container.innerHTML = cachedContent.htmlContent;
              // Recreate chart from cache
              setTimeout(() => recreateCachedChart(), 100);
            } else {
              console.debug('⚡ Cached content available but DOM already rendered, skipping DOM replace');
            }
            window.lastCycleContentHash = currentHash;
            return;
          }
        }
      }

      console.debug('🔄 Rendering fresh cycle content');
      await renderCyclesContentUncached();

      // Cache the generated content
      const htmlContent = container.innerHTML;
      const hasChart = htmlContent.includes('bitcoin-cycle-chart');

      setCachedData('CYCLE_CONTENT', {
        htmlContent,
        hasChart,
        dataHash: currentHash,
        timestamp: Date.now()
      });

      // Remember last rendered hash to avoid redundant reflows
      window.lastCycleContentHash = currentHash;

      console.debug('💾 Cycle content cached');
    }

    /**
     * Original renderCyclesContent function - always renders fresh content
     */
    async function renderCyclesContentUncached() {
      const container = document.getElementById('cycles-content');
      const state = store.snapshot();
      const ccsData = state.ccs;
      const cycleData = state.cycle;

      if (!ccsData?.score || !cycleData?.months) {
        container.innerHTML = '<div class="loading">Loading cycle data...</div>';
        return;
      }

      const blended = cycleData.ccsStar || ccsData.score;
      const interpretation = interpretCCS(blended);

      container.innerHTML = `
        <!-- Indicateurs On-Chain -->
          <div class="risk-card" style="margin-bottom: 2rem;">
          <div style="display: flex; justify-content: space-between; align-items: center; gap: .75rem; margin-bottom: 1rem;">
            <h3 style="margin: 0;">🔗 Indicateurs On-Chain</h3>
            <div style="display:flex; align-items:center; gap:.75rem;">
              <label style="display:flex; align-items:center; gap:.4rem; cursor:pointer; font-weight:600;" title="Active une pondération dynamique des indicateurs selon le contexte de marché (accumulation, expansion, euphorie, correction). Recalcule les scores avec des poids adaptés.">
                <input type="checkbox" id="dynamic-weighting-toggle" onchange="toggleDynamicWeighting()" style="transform: scale(1.1);">
                <span>🎯 Adaptation contextuelle</span>
              </label>
              <button onclick="toggleSection('onchain-indicators')" style="background: none; border: 1px solid var(--theme-border); border-radius: 4px; padding: 4px 8px; cursor: pointer; color: var(--theme-text); font-size: 0.8rem;" title="Réduire/Agrandir">
                <span id="onchain-indicators-arrow">▼</span>
              </button>
            </div>
          </div>
          <div id="onchain-indicators-content" style="margin: 1rem 0;">
            <div class="loading">Chargement des indicateurs...</div>
          </div>
        </div>
        
        <!-- Bitcoin Cycle Chart (Lazy-loaded) -->
        <div class="risk-card" style="margin-bottom: 2rem;"
             data-lazy-load="component"
             data-lazy-component="BitcoinCycleChart">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
            <h3 style="margin: 0;">📈 Graphique des Cycles Bitcoin</h3>
            <div style="display: flex; gap: 0.5rem;">
              <button onclick="debugBitcoinChart()" style="background: #ff6b35; color: white; border: none; border-radius: 4px; padding: 4px 8px; cursor: pointer; font-size: 0.8rem;" title="Debug - Force Load Chart">
                🐛 DEBUG
              </button>
              <button onclick="toggleSection('bitcoin-cycle')" style="background: none; border: 1px solid var(--theme-border); border-radius: 4px; padding: 4px 8px; cursor: pointer; color: var(--theme-text); font-size: 0.8rem;" title="Réduire/Agrandir">
                <span id="bitcoin-cycle-arrow">▼</span>
              </button>
            </div>
          </div>
          <div id="bitcoin-cycle-content">
            <!-- Label de source injecté dynamiquement -->
            <div id="btc-source-label" style="margin-left:auto;color:var(--theme-text-muted);font-size:12px;"></div>
            <div style="height: 520px; position: relative; margin: 1rem 0;">
              <div class="chart-lazy-placeholder" style="width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; background: var(--theme-bg-secondary); color: var(--theme-text-muted); border: 1px dashed var(--theme-border); border-radius: 8px;">
                <div style="text-align: center;">
                  <div style="font-size: 2rem; margin-bottom: 0.5rem;">📊</div>
                  <div>Graphique se charge au scroll...</div>
                </div>
              </div>
              <canvas id="bitcoin-cycle-chart" style="width: 100%; height: 100%; display: none;"></canvas>
            </div>
          </div>
          <div style="font-size: 0.85rem; color: var(--theme-text-muted); text-align: center; margin-top: 1rem;">
            <div><strong>Légende:</strong></div>
            <div style="margin-top: 0.5rem;">
              <span style="color: #8b5cf6; font-weight: 600;">— — —</span> Halvings Bitcoin
              &nbsp;&nbsp;|&nbsp;&nbsp;
              <span style="color: #ef4444; font-weight: 600;">——</span> Position actuelle
              &nbsp;&nbsp;|&nbsp;&nbsp;
              <span style="color: #f7931a; font-weight: 600;">——</span> Prix Bitcoin
              &nbsp;&nbsp;|&nbsp;&nbsp;
              <span style="color: #10b981; font-weight: 600;">——</span> Score de cycle
            </div>
            ${localStorage.getItem('enable_dynamic_weighting') === 'true' ? `
            <div style="margin-top: 6px; font-size: 0.8rem;">
              <span style="display:inline-flex;align-items:center;gap:6px;margin-right:12px;">
                <span style="display:inline-block;width:14px;height:4px;background:#f59e0b;border-radius:2px;"></span> Accumulation
              </span>
              <span style="display:inline-flex;align-items:center;gap:6px;margin-right:12px;">
                <span style="display:inline-block;width:14px;height:4px;background:#10b981;border-radius:2px;"></span> Bull build
              </span>
              <span style="display:inline-flex;align-items:center;gap:6px;margin-right:12px;">
                <span style="display:inline-block;width:14px;height:4px;background:#8b5cf6;border-radius:2px;"></span> Peak/Euphoria
              </span>
              <span style="display:inline-flex;align-items:center;gap:6px;margin-right:12px;">
                <span style="display:inline-block;width:14px;height:4px;background:#dc2626;border-radius:2px;"></span> Bear
              </span>
              <span style="display:inline-flex;align-items:center;gap:6px;">
                <span style="display:inline-block;width:14px;height:4px;background:#6b7280;border-radius:2px;"></span> Pre‑Accumulation
              </span>
            </div>
            ` : ''}
          </div>
        </div>

        <div class="risk-grid">
          <!-- CCS Overview -->
          <div class="risk-card">
            <h3>📊 CCS Market Score</h3>
            <div style="text-align: center; margin: var(--space-lg) 0;">
              <div style="font-size: 3rem; font-weight: 700; color: ${interpretation.color};">
                ${Math.round(ccsData.score)}
              </div>
              <div style="font-size: 1rem; color: var(--theme-text-muted);">
                ${interpretation.label}
              </div>
            </div>
            
            <div class="metric-row">
              <span class="metric-label">Model Version:</span>
              <span class="metric-value">${ccsData.model_version}</span>
            </div>
            <div class="metric-row">
              <span class="metric-label">Last Update:</span>
              <span class="metric-value">${new Date(ccsData.lastUpdate).toLocaleTimeString()}</span>
            </div>
          </div>
          
          <!-- Cycle Position -->
          <div class="risk-card">
            <h3>🔄 Position dans le Cycle</h3>
            <div style="text-align: center; margin: var(--space-lg) 0;">
              <div style="font-size: 2rem;">
                ${cycleData.phase?.emoji || '⚫'} 
              </div>
              <div style="font-size: 1rem; font-weight: 600; color: ${cycleData.phase?.color || '#6b7280'};">
                ${cycleData.phase?.phase?.replace('_', ' ').toUpperCase() || 'UNKNOWN'}
              </div>
              <div style="font-size: 0.875rem; color: var(--theme-text-muted);">
                Mois ${Math.round(cycleData.months)} post-halving
              </div>
              <div style="font-size: 0.8rem; color: var(--theme-text-muted); margin-top: 0.5rem;">
                (Dernier halving: 20 avril 2024)
              </div>
            </div>
            
            <div class="metric-row">
              <span class="metric-label">Cycle Score:</span>
              <span class="metric-value">${Math.round(cycleData.score)}/100</span>
            </div>
            <div class="metric-row">
              <span class="metric-label">Confidence:</span>
              <span class="metric-value">${Math.round(cycleData.confidence * 100)}%</span>
            </div>
          </div>
          
          <!-- Blended Analysis -->
          <div class="risk-card">
            <h3>⚖️ Stratégie Hybride</h3>
            <div class="metric-row">
              <span class="metric-label">CCS Original:</span>
              <span class="metric-value">${Math.round(ccsData.score)}</span>
            </div>
            <div class="metric-row">
              <span class="metric-label">Poids Cycle:</span>
              <span class="metric-value">${Math.round((cycleData.weight || 0.3) * 100)}%</span>
            </div>
            <div class="metric-row">
              <span class="metric-label">CCS Mixte*:</span>
              <span class="metric-value" style="color: ${interpretation.color}; font-weight: 700;">
                ${Math.round(blended)}
              </span>
            </div>
            <div class="metric-row">
              <span class="metric-label">Stratégie:</span>
              <span class="metric-value">${interpretation.label}</span>
            </div>
          </div>
        </div>
        
        <!-- Cycle Multipliers -->
        <div class="risk-card">
          <h3>🎯 Multiplicateurs par Classe d'Actifs</h3>
          <div style="font-size: 0.875rem; color: var(--theme-text-muted); margin-bottom: var(--space-sm);">
            Basé sur la phase de cycle actuelle: <strong>${cycleData.phase?.phase?.replace('_', ' ')}</strong>
          </div>
          <div class="risk-grid">
            ${Object.entries(cycleData.multipliers || {}).map(([asset, multiplier]) => {
        const color = multiplier > 1.1 ? 'var(--success)' :
          multiplier < 0.9 ? 'var(--danger)' : 'var(--theme-text)';
        const recommendation = multiplier > 1.1 ? 'Surpondérer' :
          multiplier < 0.9 ? 'Sous-pondérer' : 'Neutre';
        return `
                <div class="metric-row">
                  <span class="metric-label">${asset}:</span>
                  <span class="metric-value" style="color: ${color};">
                    ${multiplier.toFixed(2)}x <span style="font-size: 0.7rem; opacity: 0.8;">(${recommendation})</span>
                  </span>
                </div>
              `;
      }).join('')}
          </div>
          <div style="font-size: 0.8rem; color: var(--theme-text-muted); margin-top: 1rem; padding: 0.75rem; background: var(--theme-bg); border-radius: 6px;">
            💡 Les multiplicateurs indiquent l'allocation recommandée par rapport aux targets de base selon la phase de cycle.
          </div>
        </div>
      `;

      // Do NOT force-create the chart here. Let IntersectionObserver
      // load the component when it scrolls into view to avoid upfront cost.
      setTimeout(() => {
        const lazyElement = document.querySelector('[data-lazy-load="component"][data-lazy-component="BitcoinCycleChart"]');
        if (lazyElement && window.lazyLoader?.intersectionObserver) {
          try { window.lazyLoader.intersectionObserver.observe(lazyElement); } catch (_) {}
        }
      }, 100);
    }

    /**
     * Recreate cached chart - called when using cached HTML content
     */
    async function recreateCachedChart() {
      const cachedChart = getCachedData('CYCLE_CHART');
      const canvas = document.getElementById('bitcoin-cycle-chart');
      
      if (!canvas) {
        console.warn('Chart canvas not found for cache recreation');
        return;
      }

      const isNearViewport = (el, margin = 150) => {
        try {
          const r = el.getBoundingClientRect();
          const vh = window.innerHeight || document.documentElement.clientHeight;
          return r.top < vh + margin && r.bottom > -margin;
        } catch (_) { return false; }
      };
      
      if (cachedChart?.chartConfig) {
        console.debug('⚡ Recreating chart from cache');
        try {
          // Only recreate if in or near viewport and Chart.js is ready
          if (!isNearViewport(canvas)) {
            console.log('⏸️ Chart not in viewport yet; deferring recreation to lazy loader');
            return;
          }
          if (!window.Chart) {
            console.log('📊 Chart.js not loaded yet; lazy loader will handle when visible');
            return;
          }

          // Destroy existing chart if any
          if (window.bitcoinCycleChart) {
            window.bitcoinCycleChart.destroy();
          }

          // Recreate from cached config
          window.bitcoinCycleChart = new Chart(canvas, cachedChart.chartConfig);
          console.debug('✅ Chart recreated from cache');

        } catch (error) {
          console.warn('Failed to recreate cached chart, falling back to fresh render:', error);
          if (window.Chart) {
            await createBitcoinCycleChart('bitcoin-cycle-chart');
          }
        }
      } else {
        console.debug('🔄 No cached chart config; will let lazy loader create when visible.');
        // Ensure element is being observed
        const lazyElement = document.querySelector('[data-lazy-load="component"][data-lazy-component="BitcoinCycleChart"]');
        if (lazyElement && window.lazyLoader?.intersectionObserver) {
          try { window.lazyLoader.intersectionObserver.observe(lazyElement); } catch (_) {}
        }
      }
    }

    // ====== Portfolio Allocation Helper ======
    async function getCurrentPortfolioAllocation() {
      let realBalances = [];

      try {
        // Utiliser la source de données configurée
        console.log('🔍 Loading portfolio allocation using configured source...');
        const balanceResult = await window.loadBalanceData();

        if (!balanceResult.success) {
          throw new Error(balanceResult.error);
        }

        let balances;

        if (balanceResult.csvText) {
          // Source CSV locale
          balances = window.parseCSVBalances(balanceResult.csvText);
        } else if (balanceResult.data && balanceResult.data.items) {
          // Source API (stub ou cointracking_api)
          balances = balanceResult.data.items.map(item => ({
            symbol: item.symbol,
            balance: item.balance,
            value_usd: item.value_usd
          }));
        } else {
          throw new Error('Invalid data format received');
        }

        realBalances = balances.map(item => ({
          symbol: item.symbol,
          value_usd: item.value_usd
        }));
        (function(){
          const cur = (window.globalConfig && window.globalConfig.get('display_currency')) || 'USD';
          const rate = (window.currencyManager && window.currencyManager.getRateSync(cur)) || 1;
          if (cur !== 'USD' && (!rate || rate <= 0)) {
            console.log('🔍 DEBUG getCurrentPortfolioAllocation: Using real CSV data -', realBalances.length, 'assets, total: —');
          } else {
            const val = realBalances.reduce((s, i) => s + i.value_usd, 0) * rate;
            try {
              const dec = (cur === 'BTC') ? 8 : 2;
              console.log('🔍 DEBUG getCurrentPortfolioAllocation: Using real CSV data -', realBalances.length, 'assets, total:', new Intl.NumberFormat('fr-FR', { style: 'currency', currency: cur, minimumFractionDigits: dec, maximumFractionDigits: dec }).format(val));
            } catch (_) {
              console.log('🔍 DEBUG getCurrentPortfolioAllocation: Using real CSV data -', realBalances.length, 'assets, total:', (val).toFixed(cur==='BTC'?8:2), cur);
            }
          }
        })();

      } catch (error) {
        console.error('CRITICAL: Could not load CSV data in getCurrentPortfolioAllocation:', error);
        throw error; // Don't fallback - fail properly so we know there's an issue
      }

      const totalValue = realBalances.reduce((sum, item) => sum + item.value_usd, 0);

      // Use the same ASSET_GROUPS classification as dashboard.html for consistency
      const classification = ASSET_GROUPS;

      // Initialize allocation object with all ASSET_GROUPS categories
      const allocation = {};
      Object.keys(ASSET_GROUPS).forEach(category => {
        allocation[category] = 0;
      });
      allocation.model_version = 'portfolio-actuel';

      // Classifier chaque asset using the same logic as dashboard.html
      realBalances.forEach(item => {
        const symbol = item.symbol.toUpperCase();
        let foundGroup = null;

        // Find which group this asset belongs to
        for (const [groupName, aliases] of Object.entries(classification)) {
          if (aliases.includes(symbol)) {
            foundGroup = groupName;
            break;
          }
        }

        // Add to appropriate group or Others
        const targetGroup = foundGroup || 'Others';
        allocation[targetGroup] += (item.value_usd / totalValue) * 100;
      });

      return allocation;
    }

    // ====== Targets Content ======
    async function renderTargetsContent() {
      const container = document.getElementById('targets-content');

      // IMPORTANT: Ensure scores are calculated first
      const state = store.snapshot();
      if (!state.scores?.blended) {
        console.log('🔄 Blended score not available, recalculating scores...');
        const riskData = state.risk;
        const ccsData = state.ccs;
        if (riskData && ccsData) {
          await calculateAllScores(riskData, ccsData);
        }
      }

      // Get updated state after potential score calculation
      const updatedState = store.snapshot();

      // Propose different targeting strategies (now with updated scores)
      const macroProposal = proposeTargets('macro');
      const ccsProposal = proposeTargets('ccs');
      const cycleProposal = proposeTargets('cycle');
      const blendedProposal = proposeTargets('blend');
      const smartProposal = proposeTargets('smart');

      // DEBUG: Log what blended proposal contains for display
      console.log('🔍 DEBUG renderTargetsContent - updatedState.scores.blended:', updatedState.scores?.blended);
      console.log('🔍 DEBUG renderTargetsContent - blendedProposal for DISPLAY:', blendedProposal);
      console.log('🔍 DEBUG renderTargetsContent - blendedProposal.strategy:', blendedProposal.strategy);
      console.log('🔍 DEBUG renderTargetsContent - BTC allocation for DISPLAY:', blendedProposal.targets.BTC);

      // Current targets from store or use blended as default display
      const appliedTargets = updatedState.targets?.proposed || blendedProposal.targets;
      const appliedStrategy = updatedState.targets?.strategy || blendedProposal.strategy;

      // Get real current portfolio allocation
      const currentAllocation = await getCurrentPortfolioAllocation();

      container.innerHTML = `
        <div class="risk-grid">
          <!-- Strategy Selection -->
          <div class="risk-card" style="grid-column: 1 / -1;">
            <h3>🎯 Strategic Targeting</h3>
            <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: var(--space-sm); margin: var(--space-lg) 0;">
              <button class="refresh-btn" onclick="applyStrategy('macro')" style="background: #6b7280;">
                📊 Macro Only<br>
                <small>${macroProposal.strategy}</small>
              </button>
              <button class="refresh-btn" onclick="applyStrategy('ccs')" style="background: #3b82f6;">
                📈 CCS Based<br>
                <small>${ccsProposal.strategy}</small>
              </button>
              <button class="refresh-btn" onclick="applyStrategy('cycle')" style="background: #f59e0b;">
                🔄 Cycle Adjusted<br>
                <small>${cycleProposal.strategy}</small>
              </button>
              <button class="refresh-btn" onclick="applyStrategy('blend')" style="background: #10b981;">
                ⚖️ Blended Strategy<br>
                <small>${blendedProposal.strategy}</small>
              </button>
              <button class="refresh-btn" onclick="applyStrategy('smart')" style="background: linear-gradient(135deg, #8b5cf6, #06b6d4); color: white; font-weight: bold; border: 2px solid #8b5cf6;">
                🧠 SMART<br>
                <small style="font-size: 0.75rem;">${smartProposal.strategy}</small>
              </button>
            </div>
          </div>
          
          <!-- Current vs Proposed -->
          <div class="risk-card">
            <h3>📋 Current Allocation</h3>
            ${renderTargetsTable(currentAllocation, 'Portfolio Actuel')}
          </div>
          
          <div class="risk-card">
            <h3>🎯 Proposed Targets</h3>
            ${renderTargetsTable(appliedTargets, appliedStrategy)}
            ${renderExposureDelta(smartProposal)}
            <div style="margin-top: var(--space-lg); text-align: center; padding: var(--space-sm); background: var(--info-bg); border-radius: var(--radius-md); border: 1px solid var(--info);">
              <div style="font-size: 0.875rem; color: var(--info); font-weight: 600; margin-bottom: var(--space-xs);">
                💡 Nouvelle méthode d'application
              </div>
              <div style="font-size: 0.75rem; color: var(--theme-text-muted);">
                Les targets sont maintenant synchronisés via <strong>rebalance.html</strong><br>
                Utilisez le bouton "🎯 Sync CCS" dans les stratégies prédéfinies
              </div>
            </div>
          </div>
        </div>
        
        <!-- Action Plan -->
        ${renderActionPlan(currentAllocation, appliedTargets)}
        
        <!-- Decision History -->
        ${renderDecisionHistory()}
      `;

      // Update badges with current data
      updateRiskDashboardBadges(data);
    }

    function renderTargetsTable(targets, strategy) {
      const { model_version, ...allocations } = targets;

      return `
        <div style="font-size: 0.75rem; color: var(--theme-text-muted); margin-bottom: var(--space-sm);">
          ${strategy} (${model_version})
        </div>
        <div class="risk-grid">
          ${Object.entries(allocations)
          .sort(([, a], [, b]) => b - a)
          .map(([asset, allocation]) => `
              <div class="metric-row">
                <span class="metric-label">${asset}:</span>
                <span class="metric-value">${allocation.toFixed(1)}%</span>
              </div>
            `).join('')}
        </div>
      `;
    }

    function renderExposureDelta(smart) {
      try {
        if (!smart) return '';
        const base = Number(smart.base_risky || 0);
        const fin = Number(smart.final_risky || 0);
        const cap = smart.exposure_cap != null ? Number(smart.exposure_cap) : null;
        const backendStatus = smart.backend_status || 'unknown';
        const delta = Math.round((base - fin) * 10) / 10;
        const hasOverflow = delta > 0.05; // >0.05% considered meaningful
        const capText = cap != null ? `${Math.round(cap)}%` : (backendStatus === 'error' ? '5% (fallback)' : 'n/a');

        return `
          <div style="margin-top: .75rem; padding: .6rem; border-radius: 6px; border: 1px solid var(--theme-border); background: var(--theme-bg);">
            <div style="font-size:.85rem; color: var(--theme-text-muted);">
              Cap d'exposition: <b>${capText}</b>
              ${backendStatus === 'error' ? `<span style="margin-left:.5rem; color: var(--warning);">Backend indisponible — mode prudent</span>` : ''}
            </div>
            ${hasOverflow ? `<div style="margin-top:.25rem; font-size:.85rem; color: var(--warning);">Cible risky ${Math.round(base)}% → Cap ${Math.round(fin)}% (<b>−${delta} pts non exécutables</b>)</div>` : ''}
          </div>
        `;
      } catch { return ''; }
    }

    function renderActionPlan(current, proposed) {
      if (!current || !proposed) return '';

      try {
        const plan = computePlan(current, proposed);

        if (plan.actions.length === 0) {
          return `
            <div class="risk-card">
              <h3>📝 Action Plan</h3>
              <p style="text-align: center; color: var(--success);">✅ No changes needed - targets already optimal</p>
            </div>
          `;
        }

        return `
          <div class="risk-card">
            <h3>📝 Action Plan</h3>
            <div style="font-size: 0.875rem; color: var(--theme-text-muted); margin-bottom: var(--space-lg);">
              ${plan.num_changes} changes needed • ${plan.total_reallocation.toFixed(1)}% to reallocate • Complexity: ${plan.complexity}
            </div>
            <div class="risk-grid">
              ${plan.actions.map(action => {
          const color = action.action === 'buy' ? 'var(--success)' : 'var(--danger)';
          const icon = action.action === 'buy' ? '📈' : '📉';
          return `
                  <div class="metric-row">
                    <span class="metric-label">${icon} ${action.asset}:</span>
                    <span class="metric-value" style="color: ${color};">
                      ${action.current_pct.toFixed(1)}% → ${action.target_pct.toFixed(1)}%
                      <span style="font-size: 0.75rem;">(${action.change_pct > 0 ? '+' : ''}${action.change_pct.toFixed(1)}%)</span>
                    </span>
                  </div>
                `;
        }).join('')}
            </div>
          </div>
        `;

      } catch (error) {
        return `
          <div class="risk-card">
            <h3>📝 Action Plan</h3>
            <div class="error">Error computing plan: ${error.message}</div>
          </div>
        `;
      }
    }

    function renderDecisionHistory() {
      const history = getDecisionLog(5);

      if (history.length === 0) {
        return `
          <div class="risk-card">
            <h3>📚 Decision History</h3>
            <p style="text-align: center; color: var(--theme-text-muted);">No previous decisions</p>
          </div>
        `;
      }

      return `
        <div class="risk-card">
          <h3>📚 Decision History</h3>
          <div style="font-size: 0.75rem; color: var(--theme-text-muted); margin-bottom: var(--space-sm);">
            Last ${history.length} decisions
          </div>
          ${history.map(entry => `
            <div class="metric-row" style="border-bottom: 1px solid var(--theme-border); padding: var(--space-sm) 0;">
              <div>
                <div style="font-weight: 500;">${entry.strategy}</div>
                <div style="font-size: 0.75rem; opacity: 0.7;">
                  ${new Date(entry.timestamp).toLocaleString()} • 
                  CCS: ${Math.round(entry.ccs_score || 0)} • 
                  Confidence: ${Math.round((entry.confidence || 0) * 100)}%
                </div>
              </div>
            </div>
          `).join('')}
        </div>
      `;
    }

    function renderError(message) {
      document.getElementById('risk-dashboard-content').innerHTML = `
        <div class="error">
          <h3>❌ Error Loading Dashboard</h3>
          <p>${message}</p>
          <button class="refresh-btn" onclick="refreshDashboard()">Try Again</button>
        </div>
      `;
    }

    function renderBackendUnavailable(message) {
      document.getElementById('risk-dashboard-content').innerHTML = `
        <div style="text-align: center; padding: 3rem; background: var(--warning-bg); border: 1px solid var(--warning); border-radius: var(--radius-lg); color: var(--theme-text);">
          <div style="font-size: 3rem; margin-bottom: 1rem;">⚠️</div>
          <h3 style="color: var(--warning); margin-bottom: 1rem;">Backend de Risque Indisponible</h3>
          <p style="margin-bottom: 1.5rem; color: var(--theme-text-muted);">${message}</p>
          
          <div style="background: var(--theme-bg); padding: 1.5rem; border-radius: var(--radius-md); margin: 1.5rem 0; text-align: left;">
            <h4 style="color: var(--theme-text); margin-bottom: 1rem;">📋 Pour afficher les données réelles de risque :</h4>
            <ol style="color: var(--theme-text-muted); line-height: 1.6;">
              <li>Démarrer le serveur backend Python : <code style="background: var(--theme-surface); padding: 0.2rem 0.4rem; border-radius: 3px;">python main.py</code></li>
              <li>Initialiser le cache d'historique : <code style="background: var(--theme-surface); padding: 0.2rem 0.4rem; border-radius: 3px;">python scripts/init_price_history.py</code></li>
              <li>Vérifier que l'API répond sur <a href="http://localhost:8000/api/risk/dashboard" target="_blank" style="color: var(--brand-primary);">localhost:8000</a></li>
            </ol>
          </div>

          <div style="margin-top: 2rem;">
            <button class="refresh-btn" onclick="refreshDashboard()">🔄 Réessayer</button>
            <button class="refresh-btn" onclick="testEndpoint()" style="background: var(--info); margin-left: 0.5rem;">🧪 Tester l'API</button>
          </div>
          
          <div style="margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid var(--theme-border); color: var(--theme-text-muted); font-size: 0.85rem;">
            💡 <strong>Note :</strong> Ce dashboard utilise maintenant exclusivement des données réelles calculées par le backend Python. 
            Les données simulées ont été supprimées pour garantir l'authenticité des métriques de risque.
          </div>
        </div>
      `;
    }

    function renderApiError(message) {
      document.getElementById('risk-dashboard-content').innerHTML = `
        <div style="text-align: center; padding: 3rem; background: var(--danger-bg); border: 1px solid var(--danger); border-radius: var(--radius-lg);">
          <div style="font-size: 3rem; margin-bottom: 1rem;">🚨</div>
          <h3 style="color: var(--danger); margin-bottom: 1rem;">Erreur API Backend</h3>
          <p style="margin-bottom: 1.5rem; color: var(--theme-text-muted);">${message}</p>
          
          <div style="background: var(--theme-bg); padding: 1.5rem; border-radius: var(--radius-md); margin: 1.5rem 0;">
            <h4 style="color: var(--theme-text); margin-bottom: 1rem;">🔧 Suggestions de dépannage :</h4>
            <ul style="color: var(--theme-text-muted); text-align: left; line-height: 1.6;">
              <li>Vérifiez que le portfolio CoinTracking contient des données valides</li>
              <li>Assurez-vous que les sources de prix configurées sont accessibles</li>
              <li>Consultez les logs du backend pour plus de détails</li>
            </ul>
          </div>

          <button class="refresh-btn" onclick="refreshDashboard()">🔄 Réessayer</button>
        </div>
      `;
    }

    function updateTimestamp(ts, calcTime) {
      const d = new Date(ts);
      document.getElementById('last-update').textContent = `Last updated: ${d.toLocaleString()} (${calcTime})`;
    }

    function enableAutoRefresh() {
      const btn = document.getElementById('auto-refresh-btn');
      if (autoRefreshInterval) {
        clearInterval(autoRefreshInterval); autoRefreshInterval = null;
        btn.textContent = '⏱️ Enable Auto-Refresh (30s)'; btn.style.background = '';
      } else {
        autoRefreshInterval = setInterval(refreshDashboard, 30000);
        btn.textContent = '⏹️ Disable Auto-Refresh'; btn.style.background = '#28a745';
      }
    }

    // Test endpoint (identique à ta version)
    async function testEndpoint() {
      try {
        const r = await fetch('http://localhost:8000/api/risk/dashboard');
        const t = await r.text();
        try { JSON.parse(t); alert('API Response received. Check console for details.'); }
        catch { alert('API returned non-JSON response: ' + t.substring(0, 200)); }
      } catch (e) { alert('API test failed: ' + e.message); }
    }

    // ===== Décoration des tooltips après rendu =====
    function decorateRiskTooltips() {
      // === Attache dynamique pour les métriques ===
      document.querySelectorAll('.hinted[data-key]').forEach(el => {
        const key = el.getAttribute('data-key');

        // attache une bulle "vivante" qui lit la valeur *au moment* du survol
        el.addEventListener('mouseenter', (e) => {
          // 1) essaie data-value
          let raw = el.getAttribute('data-value');

          // 2) fallback: parse le texte visible (ex: "1.23%" -> 0.0123)
          if (!raw || raw === '0') {
            const txt = (el.textContent || '').trim();
            if (txt.endsWith('%')) {
              const n = parseFloat(txt.replace('%', '').replace(',', '.'));
              raw = isFinite(n) ? String(n / 100) : '';
            } else {
              const n = parseFloat(txt.replace(',', '.'));
              raw = isFinite(n) ? String(n) : '';
            }
          }

          const val = Number(String(raw || '').replace(',', '.'));
          const rating = rate(key, isNaN(val) ? null : val);

          const title = rating.label || key;
          const fmt = (key === 'sharpe' || key === 'sortino') ? num : pct;
          let body = `Valeur actuelle : ${isNaN(val) ? 'N/A' : fmt(val)}\nLecture : ${rating.verdict}`;
          if (key === 'diversification_ratio') {
            body += `\nNote: DR≈1 = neutre; >1 suggère corrélations négatives; <1 corrélations positives.\nSeuils: bon ≥0.7, limité 0.4–0.7, faible <0.4.`;
          }

          showTip(title, body, e.clientX, e.clientY);
        });

        el.addEventListener('mousemove', (e) => moveTip(e.clientX, e.clientY));
        el.addEventListener('mouseleave', hideTip);
        el.classList.add('hinted');
      });
    }

    // ====== Initialization & Store Connection ======

    // Subscribe to store changes for sidebar and content updates
    store.subscribe((state) => {
      updateSidebar(state);

      // Auto-update active tab content when data changes
      const activeTab = state.ui?.activeTab;
      if (activeTab === 'cycles' && state.ccs?.score && state.cycle?.months) {
        renderCyclesContent();
      }
      if (activeTab === 'targets') {
        renderTargetsContent().catch(err => console.error('Failed to render targets on store change:', err));
      }
    });

    // ====== Global Functions for UI Interaction ======

    // Apply specific strategy - NOW USES GOVERNANCE
    window.applyStrategy = async function (mode) {
      try {
        console.log('🔍 DEBUG applyStrategy called with mode:', mode);
        console.log('🔍 DEBUG store state before:', store.snapshot());

        const proposal = proposeTargets(mode);
        console.log('🔍 DEBUG proposal result:', proposal);
        console.log('🔍 DEBUG proposal BTC allocation:', proposal.targets.BTC);

        // Instead of direct applyTargets, create governance decision
        const currentAllocation = await getCurrentPortfolioAllocation();
        
        // Convert proposal targets to Target format for governance
        const targets = Object.entries(proposal.targets)
          .filter(([key]) => key !== 'model_version')
          .map(([symbol, target_pct]) => ({
            symbol: symbol,
            alias: symbol,
            current_pct: currentAllocation[symbol] || 0,
            target_pct: target_pct,
            group: symbol // Simplified for now
          }));

        console.log('🔍 Creating governance decision with targets:', targets);

        // Sync governance state first
        await store.syncGovernanceState();
        const governanceStatus = store.getGovernanceStatus();
        
        if (governanceStatus.state === 'FROZEN') {
          alert('❄️ System is frozen. Cannot create new decisions.');
          return;
        }

        // For now, still apply locally for backward compatibility
        // TODO: Replace with actual governance decision creation when endpoint is ready
        await applyTargets(proposal);
        
        // Update governance state to reflect the decision
        store.set('targets.governance_mode', governanceStatus.mode);
        store.set('targets.strategy', `${proposal.strategy} (via governance)`);

        // Refresh targets content to show updated data
        if (store.get('ui.activeTab') === 'targets') {
          renderTargetsContent().catch(err => console.error('Failed to render targets after strategy apply:', err));
        }

        // Update sidebar with governance info
        updateSidebar(store.snapshot());

        console.log(`Applied strategy via governance: ${mode} - ${proposal.strategy}`);
        console.log(`Governance mode: ${governanceStatus.mode}, state: ${governanceStatus.state}`);

      } catch (error) {
        console.error('Failed to apply strategy:', error);
        alert('Failed to apply strategy: ' + error.message);
      }
    };


    // ====== Force Cycle Refresh ======
    window.forceCycleRefresh = async function() {
      console.log('🔄 Force refreshing cycle content and charts...');
      
      try {
        // Clear all cycle caches
        const cycleConfigs = ['CYCLE_CONTENT', 'CYCLE_DATA', 'CYCLE_CHART'];
        cycleConfigs.forEach(configType => {
          const config = CACHE_CONFIG[configType];
          if (config) {
            localStorage.removeItem(config.key);
            console.debug(`🗑️ Cleared ${configType} cache`);
          }
        });
        
        // Force refresh cycle content
        if (document.getElementById('cycles-tab').classList.contains('active')) {
          await renderCyclesContent(true);
          console.log('✅ Cycle content force refreshed');
        } else {
          console.debug('Cycles tab not active, cache cleared for next access');
        }
        
        window.showToast?.('Cache cycles vidé et contenu rafraîchi', 'success');
        
      } catch (error) {
        console.error('Failed to force refresh cycles:', error);
        window.showToast?.('Erreur lors du refresh cycles', 'error');
      }
    };

    // Global functions for backwards compatibility
    window.refreshDashboard = refreshDashboard;
    window.enableAutoRefresh = enableAutoRefresh;
    window.testEndpoint = testEndpoint;
    // Expose refresh menu helpers for inline handlers
    window.toggleRefreshMenu = toggleRefreshMenu;
    window.closeRefreshMenu = closeRefreshMenu;

    // ===== PHASE 2A: TOAST NOTIFICATION SYSTEM =====
    let toastIdCounter = 0;

    function showToast(message, type = 'info', options = {}) {
      const {
        duration = type === 'error' ? 8000 : 5000,
        actions = [],
        title = null,
        alertData = null
      } = options;

      const toastId = `toast-${++toastIdCounter}`;
      const toastContainer = document.getElementById('toast-container');

      if (!toastContainer) {
        console.error('Toast container not found');
        return;
      }

      // Map type to severity for styling
      let severityClass = 'toast-s1';
      let severityText = 'INFO';
      let severityIcon = '●';

      if (type === 'error' || type === 'critical' || type === 's3') {
        severityClass = 'toast-s3';
        severityText = 'CRITICAL';
        severityIcon = '⚠';
      } else if (type === 'warning' || type === 's2') {
        severityClass = 'toast-s2';
        severityText = 'WARNING';
        severityIcon = '⚠';
      }

      const toast = document.createElement('div');
      toast.id = toastId;
      toast.className = `toast ${severityClass}`;
      
      let actionsHtml = '';
      if (actions.length > 0) {
        actionsHtml = `
          <div class="toast-actions">
            ${actions.map(action => `
              <button class="toast-action ${action.secondary ? 'toast-action-secondary' : ''}" 
                      onclick="${action.onclick}">${action.label}</button>
            `).join('')}
          </div>`;
      }

      toast.innerHTML = `
        <div class="toast-header">
          <div class="toast-severity toast-severity-${type === 'error' || type === 's3' ? 's3' : type === 'warning' || type === 's2' ? 's2' : 's1'}">
            <div class="toast-severity-icon"></div>
            ${severityText}
          </div>
          <button class="toast-close" onclick="hideToast('${toastId}')">&times;</button>
        </div>
        <div class="toast-body">
          ${title ? `<div class="toast-title">${title}</div>` : ''}
          <div class="toast-description">${message}</div>
          ${actionsHtml}
        </div>
      `;

      toastContainer.appendChild(toast);

      // Animate in
      setTimeout(() => toast.classList.add('show'), 10);

      // Auto-hide (except for critical alerts)
      if (type !== 'error' && type !== 'critical' && type !== 's3') {
        setTimeout(() => hideToast(toastId), duration);
      }

      return toastId;
    }

    // Track dismissed toasts to prevent re-showing
    const dismissedToasts = new Set();
    
    // Load previously dismissed alerts from localStorage
    function loadDismissedAlerts() {
      try {
        const stored = localStorage.getItem('dismissedAlerts');
        if (stored) {
          const alertIds = JSON.parse(stored);
          alertIds.forEach(id => dismissedToasts.add(id));
          console.log('Loaded dismissed alerts:', alertIds.length);
        }
      } catch (e) {
        console.warn('Failed to load dismissed alerts:', e);
      }
    }
    
    // Check if alert should be shown (not dismissed)
    function shouldShowAlert(alertId) {
      return !dismissedToasts.has(alertId);
    }
    
    // DEFINE GLOBALLY
    window.hideToast = function(toastId) {
      console.log('Hiding toast:', toastId);
      const toast = document.getElementById(toastId);
      if (!toast) {
        console.warn('Toast not found:', toastId);
        return;
      }

      // Extract alert ID from toast ID (format: toast-{alertId})
      const alertId = toastId.replace('toast-', '');
      dismissedToasts.add(alertId);
      console.log('Added to dismissed list:', alertId);
      localStorage.setItem('dismissedAlerts', JSON.stringify([...dismissedToasts]));

      console.log('Adding hide class to toast:', toastId);
      toast.classList.add('hide');
      console.log('Toast classes after adding hide:', toast.className);
      
      setTimeout(() => {
        if (toast && toast.parentNode) {
          toast.remove();
          console.log('Toast removed:', toastId);
        }
      }, 300);
    };
    
    // Function to hide all toasts - DEFINE GLOBALLY
    window.hideAllToasts = function() {
      console.log('Hiding all toasts...');
      const toastContainer = document.getElementById('toast-container');
      if (!toastContainer) {
        console.log('Toast container not found');
        return;
      }
      
      const toasts = toastContainer.querySelectorAll('.toast');
      console.log(`Found ${toasts.length} toasts to hide in container`);
      
      if (toasts.length === 0) {
        // Try fallback - look for toasts anywhere in document
        const allToasts = document.querySelectorAll('.toast');
        console.log(`Fallback: Found ${allToasts.length} toasts in entire document`);
        allToasts.forEach((toast, index) => {
          console.log(`Force removing toast ${index}:`, toast.id || 'no-id');
          toast.remove();
        });
      } else {
        // Normal path
        toasts.forEach((toast, index) => {
          console.log(`Hiding toast ${index}:`, toast.id || 'no-id');
          toast.classList.add('hide');
          setTimeout(() => {
            if (toast && toast.parentNode) {
              toast.remove();
              console.log(`Removed toast ${index}`);
            }
          }, 300);
        });
      }
      
      // Force clear container if needed
      setTimeout(() => {
        const remainingToasts = toastContainer.querySelectorAll('.toast');
        if (remainingToasts.length > 0) {
          console.log(`Force clearing ${remainingToasts.length} remaining toasts`);
          toastContainer.innerHTML = '';
        }
      }, 500);
      
      console.log('All toasts cleared');
    };

    // Show toast for S3 alerts specifically
    function showS3AlertToast(alert) {
      // Check if this alert has already been dismissed
      if (!shouldShowAlert(alert.id)) {
        console.log('Skipping already dismissed alert:', alert.id);
        return;
      }
      
      const title = getAlertTypeDisplayName(alert.alert_type);
      const message = `${alert.data.current_value?.toFixed(2) || 'N/A'} > ${alert.data.adaptive_threshold?.toFixed(2) || 'N/A'}`;
      
      // Use alert ID for consistent tracking
      const nextToastId = `toast-${alert.id}`;
      
      const actions = [
        {
          label: 'View Details',
          onclick: `window.openAlertModal('${alert.id}').then(() => hideToast('${nextToastId}'))`
        },
        {
          label: 'Dismiss',
          secondary: true,
          onclick: `hideToast('${nextToastId}')`
        }
      ];

      const toastId = showToast(message, 's3', {
        title: `🚨 ${title}`,
        actions,
        duration: 0, // Don't auto-hide critical alerts
        alertData: alert
      });
      
      // Update the toast ID to match alert ID for proper tracking
      const toastElement = document.getElementById(toastId);
      if (toastElement) {
        toastElement.id = nextToastId;
      }
      
      return nextToastId;
    }

    // ===== PHASE 2A: ALERT MODAL SYSTEM =====
    let currentAlert = null;

    async function openAlertModal(alertId) {
      console.log('Opening modal for alert:', alertId);
      
      // Try to find alert in current data first
      let alert = findAlertById(alertId);
      
      // If not found, fetch from API
      if (!alert) {
        console.log('Alert not found in cache, fetching from API...');
        try {
          const alerts = await window.globalConfig.apiRequest('/api/alerts/active');
          if (Array.isArray(alerts)) {
            alert = alerts.find(a => a.id === alertId);
            console.log('Found alert in API:', !!alert);
          }
        } catch (error) {
          console.error('Failed to fetch alert from API:', error);
        }
      }
      
      if (!alert) {
        console.error('Alert not found anywhere:', alertId);
        showToast('Alert not found', 'error');
        return;
      }

      currentAlert = alert;
      populateAlertModal(alert);

      const modal = document.getElementById('alert-modal');
      modal.classList.add('show');
      document.body.style.overflow = 'hidden';

      // Close on Escape key
      const handleEscape = (e) => {
        if (e.key === 'Escape') {
          closeAlertModal();
          document.removeEventListener('keydown', handleEscape);
        }
      };
      document.addEventListener('keydown', handleEscape);
    }

    function closeAlertModal() {
      const modal = document.getElementById('alert-modal');
      modal.classList.remove('show');
      document.body.style.overflow = '';
      currentAlert = null;
    }

    function populateAlertModal(alert) {
      // Update header
      document.getElementById('modal-severity-badge').textContent = alert.severity;
      document.getElementById('modal-severity-badge').className = `modal-severity-badge modal-severity-${alert.severity.toLowerCase()}`;
      document.getElementById('modal-alert-type').textContent = getAlertTypeDisplayName(alert.alert_type);

      // Update overview
      document.getElementById('modal-alert-id').textContent = alert.id;
      document.getElementById('modal-created-at').textContent = formatDateTime(alert.created_at);
      document.getElementById('modal-current-value').textContent = alert.data.current_value?.toFixed(4) || 'N/A';
      document.getElementById('modal-threshold').textContent = alert.data.adaptive_threshold?.toFixed(4) || 'N/A';

      // Update signals snapshot
      const signalsContainer = document.getElementById('signals-snapshot');
      signalsContainer.innerHTML = '';

      if (alert.data.signals_snapshot) {
        const signals = alert.data.signals_snapshot;
        
        // Add key signals
        if (signals.volatility) {
          Object.entries(signals.volatility).forEach(([asset, value]) => {
            addSignalCard(signalsContainer, `Volatility ${asset}`, value, 'number');
          });
        }
        
        if (signals.regime) {
          Object.entries(signals.regime).forEach(([regime, value]) => {
            addSignalCard(signalsContainer, regime.toUpperCase(), value, 'percentage');
          });
        }

        if (signals.correlation) {
          addSignalCard(signalsContainer, 'Avg Correlation', signals.correlation.avg_correlation, 'percentage');
        }

        if (signals.sentiment) {
          addSignalCard(signalsContainer, 'Fear & Greed', signals.sentiment.fear_greed, 'number');
        }

        addSignalCard(signalsContainer, 'Decision Score', signals.decision_score, 'percentage');
        addSignalCard(signalsContainer, 'Confidence', signals.confidence, 'percentage');
        addSignalCard(signalsContainer, 'Contradiction', signals.contradiction_index, 'percentage');
      }

      // Update suggested action
      if (alert.suggested_action) {
        document.getElementById('action-type').textContent = formatActionType(alert.suggested_action.type);
        document.getElementById('action-details').textContent = formatActionDetails(alert.suggested_action);
        
        // Show/hide apply button based on action type
        const applyBtn = document.getElementById('apply-btn');
        if (alert.suggested_action.type === 'freeze' || alert.suggested_action.type === 'apply_policy') {
          applyBtn.style.display = 'block';
        } else {
          applyBtn.style.display = 'none';
        }
      }

      // Update button states
      updateModalButtonStates(alert);
    }

    function addSignalCard(container, name, value, type) {
      const card = document.createElement('div');
      card.className = 'signal-card';
      
      let displayValue = '';
      if (type === 'percentage') {
        displayValue = `${(value * 100).toFixed(1)}%`;
      } else if (type === 'number') {
        displayValue = typeof value === 'number' ? value.toFixed(3) : String(value);
      } else {
        displayValue = String(value);
      }

      card.innerHTML = `
        <div class="signal-name">${name}</div>
        <div class="signal-value">${displayValue}</div>
      `;
      
      container.appendChild(card);
    }

    function formatActionType(type) {
      const typeMap = {
        'freeze': 'Freeze Trading',
        'apply_policy': 'Apply Risk Policy',
        'notify_only': 'Notification Only',
        'escalate': 'Escalate Alert'
      };
      return typeMap[type] || type;
    }

    function formatActionDetails(action) {
      if (action.type === 'freeze') {
        return `Duration: ${action.ttl_minutes} minutes. ${action.reason || ''}`;
      } else if (action.type === 'apply_policy') {
        return `Mode: ${action.mode}, Daily Cap: ${(action.cap_daily * 100).toFixed(1)}%, Ramp Hours: ${action.ramp_hours}`;
      }
      return JSON.stringify(action, null, 2);
    }

    function updateModalButtonStates(alert) {
      const ackBtn = document.getElementById('ack-btn');
      const snoozeBtn = document.getElementById('snooze-btn');
      
      // Disable if already acknowledged
      if (alert.acknowledged_at) {
        ackBtn.textContent = 'Acknowledged';
        ackBtn.disabled = true;
        ackBtn.classList.add('modal-action-secondary');
        ackBtn.classList.remove('modal-action-primary');
      } else {
        ackBtn.textContent = 'Acknowledge';
        ackBtn.disabled = false;
        ackBtn.classList.add('modal-action-primary');
        ackBtn.classList.remove('modal-action-secondary');
      }

      // Disable snooze if already snoozed
      if (alert.snooze_until && new Date(alert.snooze_until) > new Date()) {
        snoozeBtn.textContent = 'Snoozed';
        snoozeBtn.disabled = true;
      } else {
        snoozeBtn.textContent = 'Snooze 30m';
        snoozeBtn.disabled = false;
      }
    }

    // Modal action functions
    async function acknowledgeCurrentAlert() {
      if (!currentAlert) return;

      try {
        const response = await window.globalConfig.apiRequest(`/api/alerts/test/acknowledge/${currentAlert.id}`, {
          method: 'POST',
          body: JSON.stringify({ notes: 'Acknowledged from dashboard modal' })
        });

        if (response && (response.ok || response.success || !response.error)) {
          showToast('Alert acknowledged successfully', 'success');
          currentAlert.acknowledged_at = new Date().toISOString();
          currentAlert.acknowledged_by = 'user';
          updateModalButtonStates(currentAlert);
          
          // Refresh alerts history if visible
          refreshAlertsHistory();
        } else {
          throw new Error(`HTTP ${response.status}`);
        }
      } catch (error) {
        console.error('Failed to acknowledge alert:', error);
        showToast('Failed to acknowledge alert', 'error');
      }
    }

    async function snoozeCurrentAlert() {
      if (!currentAlert) return;

      try {
        const response = await window.globalConfig.apiRequest(`/api/alerts/test/snooze/${currentAlert.id}`, {
          method: 'POST',
          headers: { 'Idempotency-Key': `snooze-${currentAlert.id}-${Date.now()}` },
          body: JSON.stringify({ minutes: 30 })
        });

        if (response.ok) {
          showToast('Alert snoozed for 30 minutes', 'success');
          currentAlert.snooze_until = new Date(Date.now() + 30 * 60 * 1000).toISOString();
          updateModalButtonStates(currentAlert);
          closeAlertModal();
          
          // Refresh alerts history if visible
          refreshAlertsHistory();
        } else {
          throw new Error(`HTTP ${response.status}`);
        }
      } catch (error) {
        console.error('Failed to snooze alert:', error);
        showToast('Failed to snooze alert', 'error');
      }
    }

    async function applyAction() {
      if (!currentAlert || !currentAlert.suggested_action) return;

      const action = currentAlert.suggested_action;
      const confirmMessage = `Apply ${formatActionType(action.type)}?\\n\\nDetails: ${formatActionDetails(action)}`;

      if (!confirm(confirmMessage)) {
        return;
      }

      try {
        const response = await fetch(`${API_BASE_URL}/api/alerts/${currentAlert.id}/apply`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Idempotency-Key': `apply-${currentAlert.id}-${Date.now()}`
          },
          body: JSON.stringify({
            applied_by: 'user'
          })
        });

        if (response.ok) {
          showToast(`${formatActionType(action.type)} applied successfully`, 'success');
          currentAlert.applied_at = new Date().toISOString();
          currentAlert.applied_by = 'user';
          closeAlertModal();
          
          // Refresh alerts and governance
          refreshAlertsHistory();
          refreshGovernancePanel();
        } else {
          throw new Error(`HTTP ${response.status}`);
        }
      } catch (error) {
        console.error('Failed to apply action:', error);
        showToast('Failed to apply action', 'error');
      }
    }

    // Helper functions
    function getAlertTypeDisplayName(alertType) {
      const typeMap = {
        'VOL_Q90_CROSS': 'Volatility Q90 Cross',
        'REGIME_FLIP': 'Regime Flip',
        'CORR_HIGH': 'High Correlation',
        'CONTRADICTION_SPIKE': 'Contradiction Spike',
        'DECISION_DROP': 'Decision Drop',
        'EXEC_COST_SPIKE': 'Execution Cost Spike'
      };
      return typeMap[alertType] || alertType.replace(/_/g, ' ');
    }

    function findAlertById(alertId) {
      // This will be populated by the alerts tab when it loads
      if (window.currentAlertsData) {
        return window.currentAlertsData.find(alert => alert.id === alertId);
      }
      return null;
    }

    function formatDateTime(dateStr) {
      if (!dateStr) return 'N/A';
      const date = new Date(dateStr);
      return date.toLocaleString();
    }

    // ===== PHASE 2A: REAL-TIME S3 ALERT MONITORING =====
    let alertPollingInterval = null;
    let lastKnownAlerts = [];

    function startAlertMonitoring() {
      if (alertPollingInterval) {
        clearInterval(alertPollingInterval);
      }

      // Check for new S3 alerts every 30 seconds
      alertPollingInterval = setInterval(checkForNewS3Alerts, 30000);
      
      // Initial check
      checkForNewS3Alerts();
    }

    async function checkForNewS3Alerts() {
      try {
        const apiBaseUrl = globalConfig.get('api_base_url');
        const response = await fetch(`${apiBaseUrl}/api/alerts/active?severity_filter=S3`);
        
        if (response.ok) {
          const currentAlerts = await response.json();
          
          // Find new S3 alerts
          const newAlerts = currentAlerts.filter(alert => 
            alert.severity === 'S3' && 
            !lastKnownAlerts.some(old => old.id === alert.id)
          );

          // Show toast for each new S3 alert
          newAlerts.forEach(alert => {
            showS3AlertToast(alert);
          });

          lastKnownAlerts = currentAlerts;
        }
      } catch (error) {
        console.error('Failed to check for new S3 alerts:', error);
      }
    }

    // Expose functions globally
    window.showToast = showToast;
    window.hideToast = hideToast;
    window.openAlertModal = openAlertModal;
    window.closeAlertModal = closeAlertModal;
    window.acknowledgeAlert = acknowledgeAlert;
    window.snoozeAlert = snoozeAlert;
    window.acknowledgeCurrentAlert = acknowledgeCurrentAlert;
    window.snoozeCurrentAlert = snoozeCurrentAlert;
    window.applyAction = applyAction;
    window.startAlertMonitoring = startAlertMonitoring;
    window.refreshAlertsHistory = refreshAlertsHistory;

    // Start monitoring when page loads
    document.addEventListener('DOMContentLoaded', () => {
      loadDismissedAlerts();  // Load previously dismissed alerts
      startAlertMonitoring();
      
      // Add event delegation for toast dismiss buttons
      const toastContainer = document.getElementById('toast-container');
      if (toastContainer) {
        toastContainer.addEventListener('click', (event) => {
          // Handle close button clicks
          if (event.target.classList.contains('toast-close')) {
            const toast = event.target.closest('.toast');
            if (toast) {
              console.log('Toast close button clicked:', toast.id);
              hideToast(toast.id);
            }
          }
          
          // Handle action button clicks
          if (event.target.classList.contains('toast-action')) {
            const onclickAttr = event.target.getAttribute('onclick');
            if (onclickAttr) {
              // Execute the onclick code safely
              try {
                eval(onclickAttr);
              } catch (error) {
                console.error('Error executing toast action:', error);
              }
            }
          }
        });
      }
      
      // Remove old reference since function is now defined globally above
      // window.hideAllToasts = hideAllToasts;
      
      // Debug logging removed - system ready for production
    });

    // ===== Refresh menu helpers =====
    function toggleRefreshMenu(event) {
      event.stopPropagation?.();
      const menu = document.getElementById('refresh-menu');
      const btn = document.getElementById('refresh-menu-btn');
      if (!menu || !btn) return;
      const isOpen = menu.style.display === 'block';
      menu.style.display = isOpen ? 'none' : 'block';
      btn.setAttribute('aria-expanded', String(!isOpen));
    }

    function closeRefreshMenu() {
      const menu = document.getElementById('refresh-menu');
      const btn = document.getElementById('refresh-menu-btn');
      if (menu) menu.style.display = 'none';
      if (btn) btn.setAttribute('aria-expanded', 'false');
    }

    // Close the menu when clicking outside or pressing Escape
    document.addEventListener('click', (e) => {
      const menu = document.getElementById('refresh-menu');
      const btn = document.getElementById('refresh-menu-btn');
      if (!menu || !btn) return;
      if (!menu.contains(e.target) && e.target !== btn) {
        closeRefreshMenu();
      }
    });
    document.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeRefreshMenu(); });

    // ===== PERSISTENT CACHE SYSTEM =====
    const CACHE_CONFIG = {
      SCORES: { key: 'risk_scores_cache', ttl: 12 * 60 * 60 * 1000 }, // 12 heures
      CCS_DATA: { key: 'ccs_data_cache', ttl: 6 * 60 * 60 * 1000 },  // 6 heures  
      ONCHAIN: { key: 'onchain_data_cache', ttl: 4 * 60 * 60 * 1000 }, // 4 heures
      RISK_METRICS: { key: 'risk_metrics_cache', ttl: 8 * 60 * 60 * 1000 }, // 8 heures
      CYCLE_CONTENT: { key: 'cycle_content_cache', ttl: 12 * 60 * 60 * 1000 }, // 12 heures HTML
      CYCLE_DATA: { key: 'cycle_data_cache', ttl: 6 * 60 * 60 * 1000 }, // 6 heures données
      CYCLE_CHART: { key: 'cycle_chart_cache', ttl: 24 * 60 * 60 * 1000 } // 24 heures graphique
    };

    function initPersistentCache() {
      console.log('🗄️ Initializing persistent cache system...');

      // Check existing cached scores
      const cachedScores = getCachedData('SCORES');
      if (cachedScores) {
        const age = Math.round((Date.now() - cachedScores.timestamp) / (1000 * 60));
        console.log(`✅ Found cached scores (${age} minutes old)`);

        // Restore scores in localStorage for compatibility  
        const dataSource = globalConfig.get('data_source') || 'unknown';
        localStorage.setItem('risk_score_onchain', cachedScores.data.onchainScore?.toString() || '');
        localStorage.setItem('risk_score_risk', cachedScores.data.riskScore?.toString() || '');
        localStorage.setItem('risk_score_blended', cachedScores.data.blendedScore?.toString() || '');
        localStorage.setItem('risk_score_ccs', cachedScores.data.ccsScore?.toString() || '');
        localStorage.setItem('risk_score_timestamp', cachedScores.timestamp?.toString() || '');
        localStorage.setItem('risk_score_data_source', dataSource);
      }

      // Override clearCache to be selective
      window.originalClearCache = window.clearCache;
      window.clearCache = function (force = false) {
        if (force) {
          console.log('🧹 Force clearing all cache');
          clearAllPersistentCache();
          window.originalClearCache?.();
        } else {
          console.log('⏭️ Selective cache clear - keeping valid cached data');
          cleanExpiredCache();
        }
      };
    }

    function setCachedData(type, data) {
      const config = CACHE_CONFIG[type];
      if (!config) return false;
      
      // Make cache keys data-source-aware
      const dataSource = globalConfig.get('data_source') || 'unknown';
      const sourceAwareKey = `${config.key}_${dataSource}`;

      const cacheEntry = {
        data: data,
        timestamp: Date.now(),
        ttl: config.ttl,
        source: dataSource
      };

      try {
        localStorage.setItem(sourceAwareKey, JSON.stringify(cacheEntry));
        console.log(`💾 Cached ${type} data for source ${dataSource} (TTL: ${Math.round(config.ttl / (1000 * 60 * 60))}h)`);
        return true;
      } catch (error) {
        console.warn(`Failed to cache ${type}:`, error);
        return false;
      }
    }

    function getCachedData(type) {
      const config = CACHE_CONFIG[type];
      if (!config) return null;
      
      // Make cache keys data-source-aware
      const dataSource = globalConfig.get('data_source') || 'unknown';
      const sourceAwareKey = `${config.key}_${dataSource}`;

      try {
        const cached = localStorage.getItem(sourceAwareKey);
        if (!cached) return null;

        const cacheEntry = JSON.parse(cached);
        const isExpired = (Date.now() - cacheEntry.timestamp) > cacheEntry.ttl;

        if (isExpired) {
          localStorage.removeItem(sourceAwareKey);
          console.log(`⏰ Expired cache removed: ${type} for source ${dataSource}`);
          return null;
        }

        return cacheEntry;
      } catch (error) {
        console.warn(`Failed to read cache ${type}:`, error);
        localStorage.removeItem(sourceAwareKey);
        return null;
      }
    }

    function cleanExpiredCache() {
      Object.keys(CACHE_CONFIG).forEach(type => {
        getCachedData(type); // This will auto-remove expired entries
      });
    }

    function clearAllPersistentCache() {
      // Clear both old format and new data-source-aware format cache entries
      const dataSource = globalConfig.get('data_source') || 'unknown';
      
      Object.values(CACHE_CONFIG).forEach(config => {
        // Clear old format
        localStorage.removeItem(config.key);
        // Clear new data-source-aware format
        localStorage.removeItem(`${config.key}_${dataSource}`);
        
        // Also clear other potential data sources to ensure complete cleanup
        ['cointracking', 'api', 'unknown'].forEach(source => {
          localStorage.removeItem(`${config.key}_${source}`);
        });
      });
      console.log(`🧹 All persistent cache cleared for source ${dataSource}`);
    }

    // ===== CYCLE CACHE SYSTEM =====
    /**
     * Generate hash of cycle data to detect changes
     */
    function generateCycleDataHash(state) {
      const ccsScore = state.ccs?.score || 0;
      const cycleMonths = state.cycle?.months || 0;
      const cyclePhase = state.cycle?.phase?.phase || 'unknown';
      const onchainScore = state.scores?.onchain || 0;
      const riskScore = state.scores?.risk || 0;
      
      // Include calibration params if available
      const calibParams = localStorage.getItem('bitcoin_cycle_params');
      const calibHash = calibParams ? btoa(calibParams).slice(0, 10) : 'default';
      
      const dataString = `${ccsScore}-${cycleMonths}-${cyclePhase}-${onchainScore}-${riskScore}-${calibHash}`;
      
      // Simple hash function
      let hash = 0;
      for (let i = 0; i < dataString.length; i++) {
        const char = dataString.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32bit integer
      }
      
      return Math.abs(hash).toString(16);
    }

    /**
     * Check if cycle content needs refresh based on data changes
     */
    function shouldRefreshCycleContent(state) {
      const currentHash = generateCycleDataHash(state);
      const cachedContent = getCachedData('CYCLE_CONTENT');
      
      if (!cachedContent || !cachedContent.dataHash) {
        console.debug('🔄 Cycle cache miss - no cached content');
        return { shouldRefresh: true, reason: 'cache_miss' };
      }
      
      if (cachedContent.dataHash !== currentHash) {
        console.debug('🔄 Cycle data changed', { 
          cached: cachedContent.dataHash, 
          current: currentHash 
        });
        return { shouldRefresh: true, reason: 'data_changed' };
      }
      
      console.debug('⚡ Cycle data unchanged - using cache');
      return { shouldRefresh: false, reason: 'cache_hit' };
    }

    function updateScoreDisplays(onchainScore, riskScore, blendedScore, ccsScore) {
      // Update score displays using existing UI update functions
      try {
        if (typeof updateOnChainIndicators === 'function') {
          updateOnChainIndicators();
        }

        // Update the main dashboard scores display
        const scoreElements = {
          onchain: document.querySelector('[data-score="onchain"]'),
          risk: document.querySelector('[data-score="risk"]'),
          blended: document.querySelector('[data-score="blended"]'),
          ccs: document.querySelector('[data-score="ccs"]')
        };

        if (scoreElements.onchain) scoreElements.onchain.textContent = Math.round(onchainScore || 0);
        if (scoreElements.risk) scoreElements.risk.textContent = Math.round(riskScore || 0);
        if (scoreElements.blended) scoreElements.blended.textContent = Math.round(blendedScore || 0);
        if (scoreElements.ccs) scoreElements.ccs.textContent = Math.round(ccsScore || 0);

        // Fallback: also update sidebar KPI elements by id
        const elOn = document.getElementById('kpi-onchain');
        const elRisk = document.getElementById('kpi-risk');
        const elBlend = document.getElementById('kpi-blended');
        const elCcs = document.getElementById('ccs-ccs-mix');
        if (elOn && onchainScore != null) elOn.textContent = String(Math.round(onchainScore));
        if (elRisk && riskScore != null) elRisk.textContent = String(Math.round(riskScore));
        if (elBlend && blendedScore != null) elBlend.textContent = String(Math.round(blendedScore));
        if (elCcs && ccsScore != null) elCcs.textContent = String(Math.round(ccsScore));

        console.log('📊 Score displays updated from cache');
      } catch (error) {
        console.warn('Error updating score displays:', error);
      }
    }

    // Initialize on DOM ready
    document.addEventListener('DOMContentLoaded', function () {
      console.log('Risk Dashboard CCS MVP initializing...');

      // Initialize data source tracking for cross-tab synchronization
      window.lastKnownDataSource = globalConfig.get('data_source');
      console.log(`🔗 Risk Dashboard initialized with data source: ${window.lastKnownDataSource}`);

      // Initialize persistent cache system
      initPersistentCache();
      console.log('Persistent cache system initialized');

      // Listen for data source changes and clear cache
      window.addEventListener('dataSourceChanged', (event) => {
        console.log('🔄 Data source changed, clearing cache and reloading...', event.detail);
        clearCache();
        // Reload the dashboard after source change
        setTimeout(loadDashboard, 100);
      });

      // Initialize shared header
      // Navigation thématique initialisée automatiquement

      // Appliquer le thème immédiatement
      console.log('Initializing theme for risk-dashboard page...');
      if (window.globalConfig && window.globalConfig.applyTheme) {
        window.globalConfig.applyTheme();
      }
      if (window.applyAppearance) {
        window.applyAppearance();
      }
      console.log('Current theme after risk-dashboard init:', document.documentElement.getAttribute('data-theme'));

      // Hydrate store from localStorage
      store.hydrate();

      // Initial sidebar update
      updateSidebar(store.snapshot());

      // Initialize dynamic weighting toggle
      initializeDynamicWeightingToggle();

      // Initialize section collapse states
      initializeSectionStates();

      // Load initial data
      // Init analysis window UI then first refresh
      // controls removed
      refreshDashboard();

      // Initialize governance system
      setTimeout(async () => {
        try {
          console.log('🏛️ Initializing governance system...');
          await store.syncGovernanceState();
          await store.syncMLSignals();
          console.log('✅ Governance system initialized');
          
          // Update sidebar with governance status
          updateSidebar(store.snapshot());
        } catch (error) {
          console.warn('⚠️ Failed to initialize governance:', error);
        }
      }, 500);

      // Apply blended strategy as default if no strategy is already selected
      setTimeout(() => {
        const currentStrategy = store.get('targets.strategy');
        if (!currentStrategy) {
          console.log('No strategy found, applying Blended as default...');
          applyStrategy('blend');
        }
      }, 1000);

      // Écouter les changements de thème et source pour synchronisation cross-tab
      window.addEventListener('storage', function (e) {
        const expectedKey = (window.globalConfig?.getStorageKey && window.globalConfig.getStorageKey()) || 'crypto_rebal_settings_v1';
        if (e.key === expectedKey) {
          console.log('Settings changed in another tab, checking for theme and data source changes...');
          
          // Check if data source changed
          const currentSource = globalConfig.get('data_source');
          const previousSource = window.lastKnownDataSource;
          
          if (currentSource && currentSource !== previousSource) {
            console.log(`🔄 Data source changed from ${previousSource} to ${currentSource}, clearing cache and reloading...`);
            window.lastKnownDataSource = currentSource;
            clearCache();
            // Reload the risk dashboard after source change
            setTimeout(() => {
              window.location.reload();
            }, 500);
          }
          
          // Apply theme changes
          setTimeout(() => {
            if (window.globalConfig && window.globalConfig.applyTheme) {
              window.globalConfig.applyTheme();
            }
            if (window.applyAppearance) {
              window.applyAppearance();
            }
          }, 100);
        }
      });

      console.log('Risk Dashboard CCS MVP initialized');
    });

    (function () {
      const layout = document.querySelector('.dashboard-layout');
      const sidebar = document.querySelector('.sidebar');
      const btn = document.getElementById('sidebar-toggle');
      const icon = document.getElementById('sidebar-toggle-icon');
      const LS_KEY = 'risk_sidebar_collapsed';

      if (!layout || !sidebar || !btn || !icon) return;

      // Restaurer l'état depuis localStorage
      const collapsed = localStorage.getItem(LS_KEY) === '1';
      applyCollapsed(collapsed);

      // Toggle
      btn.addEventListener('click', () => {
        const newState = !layout.classList.contains('sidebar-collapsed');
        applyCollapsed(newState);
        localStorage.setItem(LS_KEY, newState ? '1' : '0');
        // Certains graphes réagissent mieux avec un resize
        window.dispatchEvent(new Event('resize'));
      });

      function applyCollapsed(isCollapsed) {
        layout.classList.toggle('sidebar-collapsed', isCollapsed);
        sidebar.classList.toggle('collapsed', isCollapsed);
        if (isCollapsed) {
          icon.textContent = '⟩⟩'; // état réduit → icône pour "agrandir"
          btn.setAttribute('aria-label', 'Agrandir la barre latérale');
          btn.title = 'Agrandir la barre';
        } else {
          icon.textContent = '⟨⟨'; // état normal → icône pour "réduire"
          btn.setAttribute('aria-label', 'Réduire la barre latérale');
          btn.title = 'Réduire la barre';
        }
      }
    })();
  </script>

  <script type="module">
    import { GovernancePanel } from './components/GovernancePanel.js';
    
    // Initialisation automatique de la navigation thématique et governance
    document.addEventListener('DOMContentLoaded', async function () {
      // Auto-détecter la page courante pour la navigation thématique
      /* unified nav enabled via components/nav.js; legacy init removed */
      
      // Initialize governance panel
      const governanceContainer = document.getElementById('governance-container');
      if (governanceContainer) {
        console.log('🏛️ Initializing Governance Panel...');
        const governancePanel = new GovernancePanel(governanceContainer);

        // Auto-refresh initial state
        setTimeout(() => {
          governancePanel.refreshState();
        }, 1000);

        // Store reference globally for debugging
        window.governancePanel = governancePanel;
        console.log('✅ Governance Panel initialized');
      }


        // ===== Toggle Basic/Advanced Mode =====
        
        function toggleAdvancedMode() {
          const modeSwitch = document.getElementById('mode-switch');
          const modeDescription = document.getElementById('mode-description');
          const riskTab = document.getElementById('risk-tab');
          
          if (modeSwitch.checked) {
            // Advanced Mode
            riskTab.classList.add('advanced-mode');
            modeDescription.textContent = 'Advanced risk analysis with VaR, stress tests, and Monte Carlo simulations';
            
            // Load Phase 3A components if not already loaded
            loadAdvancedRiskComponents();
          } else {
            // Basic Mode
            riskTab.classList.remove('advanced-mode');
            modeDescription.textContent = 'Essential risk metrics and portfolio overview';
          }
          
          // Save user preference
          localStorage.setItem('risk-dashboard-mode', modeSwitch.checked ? 'advanced' : 'basic');
        }

        async function loadAdvancedRiskComponents() {
          try {
            // Check if advanced components are already loaded
            if (document.querySelector('.advanced-risk-panel')) {
              return; // Already loaded
            }

            // Add advanced sections after basic content
            const riskContent = document.getElementById('risk-dashboard-content');
            
            // Create Advanced Risk Analysis Panel
            const advancedPanel = document.createElement('div');
            advancedPanel.className = 'advanced-section advanced-risk-panel';
            advancedPanel.innerHTML = `
              <div class="card">
                <div class="card-header">
                  <h3>🎯 Phase 3A: Advanced Risk Analysis</h3>
                  <span class="status-badge active">VaR Models Active</span>
                </div>
                <div class="card-content">
                  <div class="risk-grid two-col-advanced">
                    <div class="left-stack">
                      <!-- VaR Analysis -->
                      <div class="risk-card">
                        <h4>Value at Risk (VaR)</h4>
                        <div id="var-analysis-content">
                          <div class="loading">Loading VaR analysis...</div>
                        </div>
                      </div>
                      <!-- Monte Carlo -->
                      <div class="risk-card">
                        <h4>Monte Carlo Simulation</h4>
                        <div id="monte-carlo-content">
                          <div class="loading">Loading simulations...</div>
                        </div>
                      </div>
                      <!-- Risk Attribution -->
                      <div class="risk-card">
                        <h4>Risk Attribution</h4>
                        <div id="risk-attribution-content">
                          <div class="loading">Loading attribution analysis...</div>
                        </div>
                      </div>
                    </div>
                    <div class="right-stack">
                      <!-- Stress Testing (free height on the right) -->
                      <div class="risk-card">
                        <h4>Stress Testing</h4>
                        <div id="stress-test-content">
                          <div class="loading">Loading stress tests...</div>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            `;
            
            riskContent.appendChild(advancedPanel);
            
            // Load actual Phase 3A data
            await loadPhase3AData();
            
          } catch (error) {
            console.error('Error loading advanced risk components:', error);
            showToast('Failed to load advanced risk analysis', 'error');
          }
        }

        async function loadPhase3AData() {
          try {
            // Get Phase 3A status
            const statusResponse = await fetch('/api/phase3/status');
            const statusData = await statusResponse.json();
            
            if (statusData.phase_3a_advanced_risk?.status === 'active') {
              // Load VaR analysis
              await loadVaRAnalysis();
              // Load stress testing scenarios  
              await loadStressTestScenarios();
              // Load Monte Carlo results
              await loadMonteCarloResults();
              // Load Risk Attribution
              await loadRiskAttribution();
            } else {
              document.getElementById('var-analysis-content').innerHTML = 
                '<div class="warning">Advanced Risk Engine not available</div>';
            }
          } catch (error) {
            console.error('Error loading Phase 3A data:', error);
          }
        }

        // Helper functions for portfolio data
        function getCurrentPortfolioWeights() {
          // Get portfolio weights from current UI state or default
          const btcWeight = parseFloat(document.querySelector('[data-asset="BTC"] .allocation-value')?.textContent || '0.6');
          const ethWeight = parseFloat(document.querySelector('[data-asset="ETH"] .allocation-value')?.textContent || '0.4');
          const solWeight = parseFloat(document.querySelector('[data-asset="SOL"] .allocation-value')?.textContent || '0');
          
          return { BTC: btcWeight, ETH: ethWeight, SOL: solWeight };
        }
        
        function getCurrentPortfolioValue() {
          // Get portfolio value from UI or default to 10000
          const valueElement = document.querySelector('.portfolio-value');
          if (valueElement) {
            const valueText = valueElement.textContent.replace(/[,$€]/g, '');
            return parseFloat(valueText) || 10000;
          }
          return 10000;
        }

        async function loadVaRAnalysis() {
          try {
            // Get current portfolio data for VaR calculation
            const currentPortfolio = getCurrentPortfolioWeights();
            const portfolioValue = getCurrentPortfolioValue();
            
            // Call real Phase 3A VaR API
            const response = await fetch('/api/phase3/risk/comprehensive-analysis', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                portfolio_weights: currentPortfolio,
                portfolio_value: portfolioValue,
                analysis_types: ['var_parametric', 'var_historical'],
                confidence_levels: [0.95, 0.99],
                horizons: ['1d']
              })
            });
            
            if (!response.ok) {
              throw new Error(`VaR API failed: ${response.status}`);
            }
            
            const apiData = await response.json();
            
            // Extract VaR values from API response
            const var_95_1d = apiData.var_analysis['95%_1d'];
            const var_99_1d = apiData.var_analysis['99%_1d'] || { parametric_var: 0, historical_var: 0 };
            
            const varData = {
              parametric: { 
                var_95: var_95_1d.parametric_var, 
                var_99: var_99_1d.parametric_var 
              },
              historical: { 
                var_95: var_95_1d.historical_var, 
                var_99: var_99_1d.historical_var 
              },
              monte_carlo: { var_95: 1320.0, var_99: 1950.0 } // Keep mock for now
            };
            
            document.getElementById('var-analysis-content').innerHTML = `
              <div class="var-methods">
                <div class="var-method">
                  <span class="method-label">Parametric</span>
                  <span class="var-value">$${varData.parametric.var_95.toLocaleString()} (95%)</span>
                </div>
                <div class="var-method">
                  <span class="method-label">Historical</span>
                  <span class="var-value">$${varData.historical.var_95.toLocaleString()} (95%)</span>
                </div>
                <div class="var-method">
                  <span class="method-label">Monte Carlo</span>
                  <span class="var-value">$${varData.monte_carlo.var_95.toLocaleString()} (95%)</span>
                </div>
              </div>
            `;
          } catch (error) {
            console.error('Error loading VaR analysis:', error);
            // Fallback to mock data if API fails
            const varData = {
              parametric: { var_95: 1250.0, var_99: 1890.0 },
              historical: { var_95: 1180.0, var_99: 2100.0 },
              monte_carlo: { var_95: 1320.0, var_99: 1950.0 }
            };
            
            document.getElementById('var-analysis-content').innerHTML = `
              <div class="var-methods">
                <div class="var-method">
                  <span class="method-label">Parametric</span>
                  <span class="var-value">$${varData.parametric.var_95.toLocaleString()} (95%)</span>
                </div>
                <div class="var-method">
                  <span class="method-label">Historical</span>
                  <span class="var-value">$${varData.historical.var_95.toLocaleString()} (95%)</span>
                </div>
                <div class="var-method">
                  <span class="method-label">Monte Carlo</span>
                  <span class="var-value">$${varData.monte_carlo.var_95.toLocaleString()} (95%) [Mock]</span>
                </div>
              </div>
              <div class="api-status error">⚠️ Using fallback data - API unavailable</div>
            `;
          }
        }

        async function loadStressTestScenarios() {
          try {
            // Business-friendly stress scenarios with realistic data
            const scenarios = [
              {
                id: "crisis_2008",
                name: "📉 Crise Financière 2008",
                description: "Réplique la chute des marchés de septembre-novembre 2008",
                impact: { min: -45, max: -60 },
                probability: 0.02, // 2% sur 10 ans
                duration: "6-12 mois",
                context: "Effondrement Lehman Brothers, crise des subprimes"
              },
              {
                id: "covid_2020", 
                name: "🦠 Crash COVID-19 Mars 2020",
                description: "Chute brutale liée à la pandémie mondiale",
                impact: { min: -35, max: -50 },
                probability: 0.05, // 5% sur 10 ans (pandémie)
                duration: "2-6 mois",
                context: "Confinements mondiaux, arrêt économique brutal"
              },
              {
                id: "china_ban",
                name: "🇨🇳 Interdiction Crypto Chine",
                description: "Bannissement complet des cryptos par autorités chinoises",
                impact: { min: -25, max: -40 },
                probability: 0.10, // 10% sur 10 ans (régulation)
                duration: "3-9 mois",
                context: "Fermeture exchanges, interdiction mining"
              },
              {
                id: "tether_collapse",
                name: "💰 Effondrement Tether",
                description: "Perte de confiance totale dans USDT",
                impact: { min: -30, max: -55 },
                probability: 0.08, // 8% sur 10 ans (risque stablecoin)
                duration: "1-4 mois", 
                context: "Découverte de sous-collatéralisation massive"
              },
              {
                id: "fed_emergency",
                name: "🏦 Hausse Taux Fed d'Urgence",
                description: "Remontée brutale des taux pour lutter contre l'inflation",
                impact: { min: -20, max: -35 },
                probability: 0.15, // 15% sur 10 ans (politique monétaire)
                duration: "6-18 mois",
                context: "Taux directeur à 8-10%, fuite des capitaux risqués"
              },
              {
                id: "exchange_hack",
                name: "🔓 Hack Exchange Majeur",
                description: "Piratage d'un exchange de premier plan (Binance/Coinbase)",
                impact: { min: -15, max: -30 },
                probability: 0.20, // 20% sur 10 ans (sécurité)
                duration: "1-3 mois",
                context: "Vol de plusieurs milliards, panique générale"
              }
            ];

            const scenariosHtml = scenarios.map(scenario => `
              <div class="scenario-card" onclick="showScenarioDetails('${scenario.id}')">
                <div class="scenario-header">
                  <h5>${scenario.name}</h5>
                  <span class="scenario-probability">${(scenario.probability * 100).toFixed(0)}% / 10 ans</span>
                </div>
                <div class="scenario-impact">
                  Impact: ${scenario.impact.min}% à ${scenario.impact.max}%
                </div>
                <div class="scenario-duration">
                  Durée: ${scenario.duration}
                </div>
                <div class="scenario-context">
                  ${scenario.context}
                </div>
              </div>
            `).join('');

            document.getElementById('stress-test-content').innerHTML = `
              <div class="stress-scenarios">
                <div class="scenarios-header">
                  <p class="scenarios-description">
                    Scénarios historiques et hypothétiques pour évaluer la résilience du portefeuille
                  </p>
                </div>
                ${scenariosHtml}
                <div class="scenarios-footer">
                  <button class="btn-secondary" onclick="runAllStressTests()">
                    🧪 Lancer tous les tests
                  </button>
                  <button class="btn-secondary" onclick="createCustomScenario()">
                    ⚙️ Scénario personnalisé
                  </button>
                </div>
              </div>
            `;

            // Store scenarios globally for interactions
            window.stressScenarios = scenarios;

          } catch (error) {
            console.error('Error loading stress test scenarios:', error);
            document.getElementById('stress-test-content').innerHTML = `
              <div class="error">Erreur de chargement des scénarios de stress</div>
            `;
          }
        }

        // Interaction functions for stress scenarios
        window.showScenarioDetails = function(scenarioId) {
          const scenario = window.stressScenarios?.find(s => s.id === scenarioId);
          if (!scenario) return;
          
          // Show modal or detailed view (for now, just alert)
          alert(`${scenario.name}\\n\\n${scenario.description}\\n\\nImpact estimé: ${scenario.impact.min}% à ${scenario.impact.max}%\\nProbabilité sur 10 ans: ${(scenario.probability * 100).toFixed(1)}%\\nDurée typique: ${scenario.duration}`);
        };

        window.runAllStressTests = async function() {
          showToast('Lancement des tests de stress en cours...', 'info');
          // In a real implementation, this would call the Phase 3A API
          // For now, simulate loading
          setTimeout(() => {
            showToast('Tests de stress terminés. Résultats mis à jour.', 'success');
          }, 2000);
        };

        window.createCustomScenario = function() {
          // In a real implementation, this would open a modal for custom scenario creation
          showToast('Fonctionnalité de scénarios personnalisés à venir', 'info');
        };

        async function loadMonteCarloResults() {
          document.getElementById('monte-carlo-content').innerHTML = `
            <div class="monte-carlo-summary">
              <div class="sim-stat">
                <span class="stat-label">Simulations</span>
                <span class="stat-value">10,000</span>
              </div>
              <div class="sim-stat">
                <span class="stat-label">Pire scénario</span>
                <span class="stat-value text-danger">-68.5%</span>
              </div>
              <div class="sim-stat">
                <span class="stat-label">Probabilité perte >20%</span>
                <span class="stat-value">12.3%</span>
              </div>
            </div>
          `;
        }

        async function loadRiskAttribution() {
          const el = document.getElementById('risk-attribution-content');
          if (!el) return;
          try {
            // Collect and normalize current weights to sum to 1.0
            let weights = getCurrentPortfolioWeights();
            const sum = Object.values(weights).reduce((a, b) => a + (Number(b) || 0), 0);
            if (!(sum > 0)) {
              weights = { BTC: 0.6, ETH: 0.4 };
            } else {
              Object.keys(weights).forEach(k => { weights[k] = (Number(weights[k]) || 0) / sum; });
            }
            const value = getCurrentPortfolioValue();

            const resp = await fetch('/api/risk/advanced/attribution/analyze?confidence_level=0.95', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ weights, value })
            });
            if (!resp.ok) throw new Error(`Attribution API failed: ${resp.status}`);
            const data = await resp.json();

            // Build a compact attribution view
            const contr = data.risk_contribution_pct || {};
            const compVar = data.component_var || {};
            const entries = Object.keys(contr)
              .map(k => ({ k, pct: contr[k] ?? 0, cvar: compVar[k] ?? 0 }))
              .sort((a, b) => (b.pct - a.pct))
              .slice(0, 6);

            const rows = entries.map(e => `
              <div class="var-method">
                <span class="method-label">${e.k}</span>
                <span class="stat-value">${e.pct.toFixed(1)}% <small style="color:var(--theme-text-muted);">(cVaR ${e.cvar.toFixed(2)})</small></span>
              </div>
            `).join('');

            el.innerHTML = `
              <div class="var-methods">
                <div class="sim-stat" style="justify-content:space-between;">
                  <span class="stat-label">Concentration</span>
                  <span class="stat-value">${Math.round((data.concentration_risk||0)*100)}%</span>
                </div>
                <div class="sim-stat" style="justify-content:space-between;">
                  <span class="stat-label">Diversification</span>
                  <span class="stat-value">${(data.diversification_ratio||0).toFixed(2)}</span>
                </div>
                ${rows}
              </div>
            `;
          } catch (e) {
            console.warn('Risk attribution load failed:', e);
            el.innerHTML = `<div class="warning">Attribution indisponible pour le moment</div>`;
          }
        }

        // Initialize mode from localStorage
        document.addEventListener('DOMContentLoaded', function() {
          const savedMode = localStorage.getItem('risk-dashboard-mode');
          const modeSwitch = document.getElementById('mode-switch');
          
          if (savedMode === 'advanced' && modeSwitch) {
            modeSwitch.checked = true;
            toggleAdvancedMode();
          }
        });

        // Make functions globally available
        window.toggleAdvancedMode = toggleAdvancedMode;
        window.loadAdvancedRiskComponents = loadAdvancedRiskComponents;
    });
  </script>

  <!-- PHASE 2A: Toast Container -->
  <div id="toast-container">
    <!-- Toasts will appear here -->
  </div>

  <!-- Fixed button outside toast container -->
  <div id="toast-buttons" style="position: fixed; bottom: 20px; right: 20px; z-index: 3000; pointer-events: auto;">
    <button onclick="hideAllToasts()" style="
      background: var(--danger); 
      color: white; 
      border: none; 
      padding: 8px 16px; 
      border-radius: var(--radius-md); 
      cursor: pointer;
      font-size: 0.875rem;
      box-shadow: var(--shadow-md);
      pointer-events: auto;
    ">🗑️ Clear All Alerts</button>
  </div>

  <!-- PHASE 2A: Alert Detail Modal -->
  <div class="modal-overlay" id="alert-modal">
    <div class="modal">
      <div class="modal-header">
        <h2 class="modal-title" id="modal-title">
          <span class="modal-severity-badge" id="modal-severity-badge">S3</span>
          <span id="modal-alert-type">VOL_Q90_CROSS</span>
        </h2>
        <button class="modal-close" onclick="closeAlertModal()">&times;</button>
      </div>

      <div class="modal-body">
        <!-- Alert Overview -->
        <div class="modal-section">
          <div class="modal-section-title">Alert Overview</div>
          <div class="alert-metadata" id="alert-overview">
            <div class="metadata-item">
              <span class="metadata-label">Alert ID</span>
              <span class="metadata-value" id="modal-alert-id">-</span>
            </div>
            <div class="metadata-item">
              <span class="metadata-label">Created</span>
              <span class="metadata-value" id="modal-created-at">-</span>
            </div>
            <div class="metadata-item">
              <span class="metadata-label">Current Value</span>
              <span class="metadata-value" id="modal-current-value">-</span>
            </div>
            <div class="metadata-item">
              <span class="metadata-label">Threshold</span>
              <span class="metadata-value" id="modal-threshold">-</span>
            </div>
          </div>
        </div>

        <!-- ML Signals Snapshot -->
        <div class="modal-section">
          <div class="modal-section-title">ML Signals Snapshot</div>
          <div class="signals-grid" id="signals-snapshot">
            <!-- Dynamic signal cards will be inserted here -->
          </div>
        </div>

        <!-- Suggested Action -->
        <div class="modal-section">
          <div class="modal-section-title">Suggested Action</div>
          <div class="suggested-action" id="suggested-action">
            <div class="action-type" id="action-type">Apply Policy</div>
            <div class="action-details" id="action-details">Mode: Slow, Cap Daily: 4%, Ramp Hours: 24</div>
          </div>
        </div>
      </div>

      <div class="modal-actions">
        <button class="modal-action modal-action-secondary" onclick="closeAlertModal()">Close</button>
        <button class="modal-action modal-action-secondary" onclick="snoozeCurrentAlert()" id="snooze-btn">Snooze 30m</button>
        <button class="modal-action modal-action-primary" onclick="acknowledgeCurrentAlert()" id="ack-btn">Acknowledge</button>
        <button class="modal-action modal-action-danger" onclick="applyAction()" id="apply-btn" style="display:none;">Apply Action</button>
      </div>
    </div>
  </div>

  <!-- Bitcoin Cycle Chart Lazy Loading Component -->
  <script>
    // Composant pour le chargement lazy de Chart.js et du graphique Bitcoin Cycle
    class BitcoinCycleChart {
      constructor(element) {
        console.log('🔧 BitcoinCycleChart constructor called with element:', element);
        this.element = element;
        this.chartLoaded = false;
        this.placeholder = element.querySelector('.chart-lazy-placeholder');
        this.canvas = element.querySelector('#bitcoin-cycle-chart');
        console.log('🔍 Placeholder found:', !!this.placeholder, 'Canvas found:', !!this.canvas);
      }

      async init() {
        console.log('🚀 BitcoinCycleChart init() called');
        try {
          // Afficher un indicateur de chargement
          if (this.placeholder) {
            console.log('✅ Showing loading indicator');
            this.placeholder.innerHTML = `
              <div style="text-align: center;">
                <div style="font-size: 2rem; margin-bottom: 0.5rem;">📊</div>
                <div>Chargement de Chart.js...</div>
                <div class="lazy-loading" style="margin-top: 1rem;"></div>
              </div>
            `;
          } else {
            console.warn('⚠️ No placeholder found for loading indicator');
          }

          // Charger Chart.js de manière asynchrone
          console.log('📊 Starting to load Chart.js...');
          await this.loadChartJS();
          console.log('✅ Chart.js loaded successfully');

          // Masquer le placeholder et afficher le canvas
          console.log('🔄 Switching from placeholder to canvas...');
          if (this.placeholder) {
            this.placeholder.style.display = 'none';
            console.log('✅ Placeholder hidden');
          }
          if (this.canvas) {
            this.canvas.style.display = 'block';
            console.log('✅ Canvas shown');
          } else {
            console.warn('⚠️ No canvas found to show');
          }

          // Créer le graphique Bitcoin Cycle
          if (typeof createBitcoinCycleChart === 'function') {
            console.log('📊 Calling createBitcoinCycleChart...');
            await createBitcoinCycleChart('bitcoin-cycle-chart');
            console.log('✅ createBitcoinCycleChart completed');
          } else {
            console.error('❌ createBitcoinCycleChart function not found');
          }

          this.chartLoaded = true;
          console.log('✅ Bitcoin Cycle Chart loaded successfully via lazy loading');

        } catch (error) {
          console.error('❌ Failed to lazy load Bitcoin Cycle Chart:', error);

          // Afficher l'erreur dans le placeholder
          if (this.placeholder) {
            this.placeholder.innerHTML = `
              <div style="text-align: center; color: var(--theme-error, #dc3545);">
                <div style="font-size: 2rem; margin-bottom: 0.5rem;">⚠️</div>
                <div>Erreur lors du chargement du graphique</div>
                <div style="font-size: 0.8rem; margin-top: 0.5rem;">${error.message}</div>
              </div>
            `;
          }
        }
      }

      async loadChartJS() {
        // Vérifier si Chart.js est déjà chargé
        if (window.Chart) {
          console.log('📊 Chart.js already loaded');
          return Promise.resolve();
        }

        console.log('📊 Loading Chart.js...');

        // Charger Chart.js principal
        const chartPromise = new Promise((resolve, reject) => {
          const script = document.createElement('script');
          script.src = 'https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.js';
          script.onload = resolve;
          script.onerror = () => reject(new Error('Failed to load Chart.js'));
          document.head.appendChild(script);
        });

        await chartPromise;

        // Charger l'adaptateur de dates
        const adapterPromise = new Promise((resolve, reject) => {
          const script = document.createElement('script');
          script.src = 'https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js';
          script.onload = resolve;
          script.onerror = () => reject(new Error('Failed to load Chart.js date adapter'));
          document.head.appendChild(script);
        });

        await adapterPromise;

        // Petit délai pour s'assurer que Chart.js est disponible
        await new Promise(resolve => setTimeout(resolve, 100));

        if (!window.Chart) {
          throw new Error('Chart.js failed to initialize');
        }

        console.log('✅ Chart.js loaded successfully');
      }
    }

    // Enregistrer le composant globalement pour le lazy loader
    window.BitcoinCycleChart = BitcoinCycleChart;
  </script>

</body>

</html>
