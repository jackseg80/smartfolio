<!DOCTYPE html>
<html lang="fr">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Risk Dashboard - Crypto Portfolio</title>

  <!-- Th√®me/compat identiques √† ta page actuelle -->
  <link rel="stylesheet" href="shared-theme.css">
  <link rel="stylesheet" href="theme-compat.css">

  <!-- Scripts partag√©s existants -->
  <script src="global-config.js"></script>
  <script src="shared-header.js"></script>
  <script src="appearance.js"></script>

  <!-- Core modules ESM -->
  <script type="module" src="core/risk-dashboard-store.js"></script>
  <script type="module" src="core/fetcher.js"></script>

  <!-- CCS modules ESM -->
  <script type="module" src="modules/signals-engine.js"></script>
  <script type="module" src="modules/cycle-navigator.js"></script>
  <script type="module" src="modules/targets-coordinator.js"></script>

  <!-- Chart.js for Bitcoin Cycle Visualization -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.js"></script>
  <script
    src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>

  <style>
    /* ===== Container responsive ===== */
    .container {
      width: 100%;
      max-width: 95vw;
      margin: 0 auto;
      padding: 0 var(--space-lg);
    }

    @media (max-width: 768px) {
      .container {
        padding: 0 var(--space-md);
      }
    }

    /* ===== Layout Hybride: Sidebar + Main ===== */
    .dashboard-layout {
      display: grid;
      grid-template-columns: 320px 1fr;
      gap: var(--space-lg);
      min-height: calc(100vh - 200px);
    }

    @media (max-width: 1024px) {
      .dashboard-layout {
        grid-template-columns: 1fr;
        gap: var(--space-md);
      }

      .sidebar {
        max-height: none;
        position: relative;
      }
    }

    .sidebar {
      background: var(--theme-surface);
      border: 1px solid var(--theme-border);
      border-radius: var(--radius-lg);
      padding: var(--space-lg);
      box-shadow: var(--shadow-sm);
      position: sticky;
      top: var(--space-lg);
      max-height: calc(100vh - 120px);
      overflow-y: auto;
    }

    .main-content {
      background: var(--theme-surface);
      border: 1px solid var(--theme-border);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-sm);
    }

    /* ===== Sidebar Components ===== */
    .sidebar-section {
      margin-bottom: var(--space-xl);
    }

    .sidebar-section:last-child {
      margin-bottom: 0;
    }

    .sidebar-title {
      font-size: 0.875rem;
      font-weight: 600;
      color: var(--theme-text-muted);
      margin-bottom: var(--space-sm);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .ccs-gauge {
      text-align: center;
      padding: var(--space-lg);
      background: var(--theme-bg);
      border-radius: var(--radius-md);
      border: 2px solid var(--brand-primary);
    }

    .ccs-score {
      font-size: 2.5rem;
      font-weight: 700;
      color: var(--brand-primary);
      line-height: 1;
      margin-bottom: var(--space-xs);
    }

    .ccs-label {
      font-size: 0.75rem;
      color: var(--theme-text-muted);
      font-weight: 500;
    }

    .status-indicator {
      display: flex;
      align-items: center;
      gap: var(--space-xs);
      padding: var(--space-sm);
      background: var(--theme-bg);
      border-radius: var(--radius-sm);
      margin-bottom: var(--space-sm);
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--theme-text-muted);
    }

    .status-dot.healthy {
      background: var(--success);
    }

    .status-dot.warning {
      background: var(--warning);
    }

    .status-dot.error {
      background: var(--danger);
    }

    .status-text {
      font-size: 0.75rem;
      color: var(--theme-text-muted);
    }

    /* ===== Onglets ===== */
    .tabs {
      display: flex;
      border-bottom: 1px solid var(--theme-border);
      background: var(--theme-bg);
    }

    .tab-button {
      flex: 1;
      padding: var(--space-lg);
      background: none;
      border: none;
      color: var(--theme-text-muted);
      font-weight: 500;
      cursor: pointer;
      transition: all var(--transition-normal);
      border-bottom: 3px solid transparent;
    }

    .tab-button:hover {
      color: var(--theme-text);
      background: var(--theme-surface);
    }

    .tab-button.active {
      color: var(--brand-primary);
      border-bottom-color: var(--brand-primary);
      background: var(--theme-surface);
    }

    .tab-content {
      padding: var(--space-xl);
      min-height: 400px;
    }

    .tab-pane {
      display: none;
    }

    .tab-pane.active {
      display: block;
    }

    /* ===== Risk Components (existants) ===== */
    .risk-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: var(--space-lg);
      margin: var(--space-lg) 0;
    }

    .risk-card {
      background: var(--theme-surface);
      border: 1px solid var(--theme-border);
      border-radius: var(--radius-lg);
      padding: var(--space-xl);
      box-shadow: var(--shadow-sm);
      transition: all var(--transition-normal);
    }

    .risk-card:hover {
      box-shadow: var(--shadow-md);
      transform: translateY(-2px);
    }

    .risk-card h3 {
      margin-top: 0;
      color: var(--theme-text);
      border-bottom: 2px solid var(--brand-primary);
      padding-bottom: var(--space-sm);
      font-size: 1.25rem;
      font-weight: 600;
    }

    .metric-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: var(--space-sm) 0;
      border-bottom: 1px solid var(--theme-border);
    }

    .metric-label {
      font-weight: 500;
      color: var(--theme-text-muted);
      font-size: 0.875rem;
    }

    .metric-value {
      font-weight: 600;
      font-family: 'Monaco', 'Consolas', monospace;
      color: var(--theme-text);
    }

    .risk-level {
      display: inline-block;
      padding: 0.375rem 0.75rem;
      border-radius: 9999px;
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: .05em;
    }

    .risk-low {
      background: var(--success-bg);
      color: var(--success)
    }

    .risk-medium {
      background: var(--warning-bg);
      color: var(--warning)
    }

    .risk-high,
    .risk-very-high {
      background: var(--danger-bg);
      color: var(--danger)
    }

    .risk-critical {
      background: var(--danger);
      color: #fff
    }

    .alert {
      padding: var(--space-lg);
      margin: var(--space-sm) 0;
      border-radius: var(--radius-md);
      border-left: 4px solid;
    }

    .alert-high {
      background: var(--danger-bg);
      color: var(--danger);
      border-color: var(--danger)
    }

    .alert-medium {
      background: var(--warning-bg);
      color: var(--warning);
      border-color: var(--warning)
    }

    .alert-low {
      background: var(--info-bg);
      color: var(--info);
      border-color: var(--info)
    }

    .correlation-heatmap {
      width: 100%;
      height: 300px;
      background: var(--theme-surface);
      border: 1px solid var(--theme-border);
      border-radius: 4px;
      overflow-x: auto;
    }

    .loading {
      text-align: center;
      padding: 40px;
      color: var(--theme-text-muted);
    }

    .error {
      background: var(--danger-bg);
      color: var(--danger);
      padding: 20px;
      border-radius: 8px;
      border: 1px solid var(--danger);
    }

    .metric-interpretation {
      font-size: 0.8rem;
      color: var(--theme-text-muted);
      padding: 0.5rem 0.75rem;
      margin: 0.25rem 0 0.5rem 0;
      background: var(--theme-surface);
      border-radius: 6px;
      border-left: 3px solid var(--theme-accent);
      font-style: italic;
    }

    .metric-benchmark {
      font-size: 0.75rem;
      color: var(--theme-text-muted);
      padding: 0.5rem 0.75rem;
      margin-top: 0.75rem;
      background: var(--theme-bg);
      border-radius: 6px;
      border: 1px solid var(--theme-border);
    }

    .metric-benchmark strong {
      color: var(--theme-text);
    }

    .recommendation {
      margin: 1rem 0;
      padding: 1rem;
      border-radius: 8px;
      border-left: 4px solid;
    }

    .recommendation-high {
      background: var(--danger-bg);
      border-color: var(--danger);
    }

    .recommendation-medium {
      background: var(--warning-bg);
      border-color: var(--warning);
    }

    .recommendation-low {
      background: var(--success-bg);
      border-color: var(--success);
    }

    .recommendation-header {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-bottom: 0.5rem;
    }

    .recommendation-icon {
      font-size: 1.2rem;
    }

    .recommendation-title {
      font-weight: 600;
      color: var(--theme-text);
      flex: 1;
    }

    .recommendation-priority {
      font-size: 0.7rem;
      padding: 0.25rem 0.5rem;
      background: var(--theme-text);
      color: var(--theme-bg);
      border-radius: 12px;
      font-weight: 600;
      text-transform: uppercase;
    }

    .recommendation-description {
      color: var(--theme-text-muted);
      margin-bottom: 0.5rem;
      font-size: 0.9rem;
    }

    .recommendation-action {
      color: var(--theme-text);
      font-weight: 500;
      font-size: 0.9rem;
    }

    .refresh-btn {
      background: var(--brand-primary);
      color: #fff;
      border: 0;
      padding: .75rem 1.5rem;
      border-radius: var(--radius-md);
      cursor: pointer;
      font-size: .875rem;
      font-weight: 500;
      margin: var(--space-sm);
      transition: all var(--transition-normal);
      display: inline-flex;
      align-items: center;
      gap: var(--space-sm);
    }

    .refresh-btn:hover:not(:disabled) {
      background: var(--brand-primary-hover);
      transform: translateY(-1px);
      box-shadow: var(--shadow-md);
    }

    .refresh-btn:disabled {
      background: var(--theme-border);
      cursor: not-allowed;
      opacity: .5
    }

    .timestamp {
      font-size: .75rem;
      color: var(--theme-text-muted);
      text-align: right;
      margin-bottom: var(--space-sm)
    }

    .controls {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      margin: var(--space-lg) 0;
      flex-wrap: wrap
    }

    /* ===== Tooltip (l√©ger, autonome) ===== */
    .tooltip {
      position: fixed;
      z-index: 9999;
      min-width: 260px;
      max-width: 360px;
      pointer-events: none;
      background: #0e1528;
      color: #e9f0ff;
      border: 1px solid #243355;
      border-radius: 10px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, .35);
      padding: 10px 12px;
      opacity: 0;
      transform: translateY(6px);
      transition: opacity .12s ease, transform .12s ease;
    }

    .tooltip.show {
      opacity: 1;
      transform: translateY(0)
    }

    .tooltip .tip-title {
      font-weight: 700;
      margin-bottom: 6px;
      color: #d7e6ff
    }

    .tooltip .tip-body {
      white-space: pre-line;
      color: #c6d6f3;
      font-size: 13px
    }

    /* Indication de survol explicatif */
    .hinted {
      cursor: help;
      text-decoration: underline dotted;
      text-underline-offset: 2px;
    }
  </style>
</head>

<body>
  <div id="shared-header"></div>

  <div class="container">
    <!-- Controls Header -->
    <div class="controls">
      <button class="refresh-btn" onclick="refreshDashboard()" id="refresh-btn">üîÑ Refresh Data</button>
      <button class="refresh-btn" onclick="enableAutoRefresh()" id="auto-refresh-btn">‚è±Ô∏è Enable Auto-Refresh
        (30s)</button>
      <button class="refresh-btn" onclick="testEndpoint()" style="background:#007bff">üß™ Test API</button>
      <div class="timestamp" id="last-update"></div>
    </div>

    <!-- Layout Hybride: Sidebar + Main -->
    <div class="dashboard-layout">
      <!-- Sidebar Fixe -->
      <div class="sidebar">
        <!-- CCS Gauge -->
        <div class="sidebar-section">
          <div class="sidebar-title">Market Score CCS</div>
          <div class="ccs-gauge" id="ccs-gauge">
            <div class="ccs-score" id="ccs-score">--</div>
            <div class="ccs-label">Loading...</div>
          </div>
        </div>

        <!-- Cycle Indicator -->
        <div class="sidebar-section">
          <div class="sidebar-title">Cycle Position</div>
          <div id="cycle-indicator">
            <div class="status-indicator">
              <div class="status-dot" id="cycle-dot"></div>
              <div class="status-text" id="cycle-text">Loading cycle data...</div>
            </div>
          </div>
        </div>

        <!-- Targets Summary -->
        <div class="sidebar-section">
          <div class="sidebar-title">Target Changes</div>
          <div id="targets-summary">
            <div class="status-text">No changes proposed</div>
          </div>
        </div>

        <!-- API Status -->
        <div class="sidebar-section">
          <div class="sidebar-title">API Health</div>
          <div id="api-status">
            <div class="status-indicator">
              <div class="status-dot" id="backend-dot"></div>
              <div class="status-text">Backend API</div>
            </div>
            <div class="status-indicator">
              <div class="status-dot" id="signals-dot"></div>
              <div class="status-text">Market Signals</div>
            </div>
          </div>
        </div>
      </div>

      <!-- Main Content avec Onglets -->
      <div class="main-content">
        <div class="tabs">
          <button class="tab-button active" data-tab="risk" onclick="switchTab('risk')">Risk Overview</button>
          <button class="tab-button" data-tab="cycles" onclick="switchTab('cycles')">Market Cycles</button>
          <button class="tab-button" data-tab="targets" onclick="switchTab('targets')">Strategic Targets</button>
        </div>

        <div class="tab-content">
          <!-- Risk Overview Tab -->
          <div class="tab-pane active" id="risk-tab">
            <div id="risk-dashboard-content">
              <div class="loading">Loading risk metrics...</div>
            </div>
          </div>

          <!-- Market Cycles Tab -->
          <div class="tab-pane" id="cycles-tab">
            <div id="cycles-content">
              <div class="loading">Loading cycle analysis...</div>
            </div>
          </div>

          <!-- Strategic Targets Tab -->
          <div class="tab-pane" id="targets-tab">
            <div id="targets-content">
              <h3>üéØ Strategic Targets</h3>
              <p>Target management will be implemented here...</p>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Tooltip partag√© -->
  <div id="tooltip" class="tooltip" aria-hidden="true" role="tooltip">
    <div class="tip-title"></div>
    <div class="tip-body"></div>
  </div>

  <script type="module">
    // ‚öôÔ∏è Unifier l‚ÄôURL d‚Äôimport du module (pas de ?v=3 ici)
    import { cycleScoreFromMonths, getCurrentCycleMonths } from './modules/cycle-navigator.js';
    // Note: calibrateCycleParams & getCycleParams seront import√©s √† la vol√©e, ce qui
    // √©vite tout probl√®me si le bouton est inject√© apr√®s coup.

    // üîó √âcoute d√©l√©gu√©e (le bouton est ajout√© dynamiquement)
    document.addEventListener('click', async (e) => {
      const btn = e.target?.closest('#btn-calibrate');
      if (!btn) return;
      try {
        const { calibrateCycleParams, getCycleParams } = await import('./modules/cycle-navigator.js');
        const res = calibrateCycleParams(); // ancres par d√©faut
        console.log('Cycle params calibr√©s:', getCycleParams(), 'score=', res.score);
        // ‚úÖ Redessiner le m√™me canvas
        await createBitcoinCycleChart('bitcoin-cycle-chart');
        window.showToast?.('Cycle calibr√© sur historiques', 'success');
      } catch (e) {
        console.error(e);
        window.showToast?.('√âchec calibration', 'error');
      }
    });

    // Helper functions (must be defined first)
    function safeFixed(v, d = 2) { return (v == null || isNaN(v)) ? 'N/A' : Number(v).toFixed(d); }
    function formatPercent(v) { return (v == null || isNaN(v)) ? 'N/A' : (v * 100).toFixed(2) + '%'; }
    function formatNumber(v) {
      if (v == null || isNaN(v)) return 'N/A';
      return new Intl.NumberFormat('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 }).format(v);
    }

    // Import core modules
    import { store } from './core/risk-dashboard-store.js';
    import { fetchCached } from './core/fetcher.js';

    // Import CCS modules
    import { fetchAndComputeCCS, interpretCCS, DEFAULT_CCS_WEIGHTS } from './modules/signals-engine.js';
    import { estimateCyclePosition, blendCCS, getCyclePhase } from './modules/cycle-navigator.js';
    import { proposeTargets, applyTargets, computePlan, DEFAULT_MACRO_TARGETS, getDecisionLog } from './modules/targets-coordinator.js';

    // Global state
    let autoRefreshInterval = null;
    let isRefreshing = false;

    // ====== Tab Management ======
    window.switchTab = function (tabName) {
      // Update UI state
      document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
      document.querySelectorAll('.tab-pane').forEach(pane => pane.classList.remove('active'));

      document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
      document.getElementById(`${tabName}-tab`).classList.add('active');

      // Update store
      store.set('ui.activeTab', tabName);

      // Render content based on active tab
      switch (tabName) {
        case 'risk':
          // Risk content is already rendered by refreshDashboard
          break;
        case 'cycles':
          // Only render if not already on cycles tab to avoid recreating chart
          const currentTab = store.snapshot().ui?.activeTab;
          if (currentTab !== 'cycles') {
            renderCyclesContent();
          }
          break;
        case 'targets':
          renderTargetsContent().catch(err => console.error('Failed to render targets:', err));
          break;
      }

      console.log(`Switched to tab: ${tabName}`);
    };

    // ====== Tooltip helpers ======
    const $tip = document.getElementById('tooltip');
    const $tipTitle = $tip?.querySelector('.tip-title');
    const $tipBody = $tip?.querySelector('.tip-body');

    function showTip(title, body, x, y) {
      if (!$tip) return;
      $tipTitle.textContent = title || '';
      $tipBody.textContent = body || '';
      $tip.style.left = x + 'px';
      $tip.style.top = y + 'px';
      $tip.classList.add('show');
      $tip.setAttribute('aria-hidden', 'false');
    }

    function moveTip(x, y) {
      if (!$tip) return;
      $tip.style.left = x + 'px';
      $tip.style.top = y + 'px';
    }

    function hideTip() {
      if (!$tip) return;
      $tip.classList.remove('show');
      $tip.setAttribute('aria-hidden', 'true');
    }

    function attachTip(el, title, body) {
      if (!el) return;
      el.addEventListener('mouseenter', e => showTip(title, body, e.clientX, e.clientY));
      el.addEventListener('mousemove', e => moveTip(e.clientX, e.clientY));
      el.addEventListener('mouseleave', hideTip);
      el.classList.add('hinted');
    }

    // ====== Formatters ======
    const pct = v => (v == null || isNaN(v) ? 'N/A' : (v * 100).toFixed(2) + '%');
    const num = v => (v == null || isNaN(v) ? 'N/A' : Number(v).toFixed(2));

    // ====== API Functions ======
    async function fetchRiskData() {
      try {
        const apiResult = await fetchCached(
          'risk-dashboard',
          () => fetch('http://localhost:8000/api/risk/dashboard?source=cointracking&pricing=local&min_usd=1.00')
            .then(r => {
              if (!r.ok) throw new Error(`HTTP ${r.status}: ${r.statusText}`);
              return r.json();
            }),
          'risk'
        );

        // If API returns success:false, use CSV fallback instead
        if (!apiResult.success) {
          console.warn('Risk API returned error:', apiResult.message, '- using CSV fallback');
          return getMockRiskData();
        }

        return apiResult;
      } catch (error) {
        console.warn('Risk API unavailable, using fallback data:', error);
        return getMockRiskData();
      }
    }

    // Fallback mock data when API is unavailable - uses configured data source
    async function getMockRiskData() {
      try {
        console.log('üîç Loading risk data using configured source...');
        const balanceResult = await window.loadBalanceData();

        if (!balanceResult.success) {
          throw new Error(balanceResult.error);
        }

        let balances;

        if (balanceResult.csvText) {
          // Source CSV locale
          balances = window.parseCSVBalances(balanceResult.csvText);
        } else if (balanceResult.data && balanceResult.data.items) {
          // Source API (stub ou cointracking_api)
          balances = balanceResult.data.items.map(item => ({
            symbol: item.symbol,
            balance: item.balance,
            value_usd: item.value_usd
          }));
        } else {
          throw new Error('Invalid data format received');
        }

        const totalValue = balances.reduce((sum, item) => sum + item.value_usd, 0);
        const assetCount = balances.length; // Dynamic calculation (>=configured threshold)

        console.log('üîç DEBUG Risk Dashboard: Using REAL CSV data - total:', totalValue.toFixed(2), 'assets:', assetCount);
        console.log('üîç DEBUG Risk Dashboard: Individual assets parsed:', balances.length);

        // Calculate real risk metrics based on portfolio composition
        try {
          const groups = groupAssetsByAliases(balances);
          console.log('üîç DEBUG Risk Dashboard: Groups created:', groups.length);

          const riskMetrics = calculateRealRiskMetrics(balances, totalValue);
          console.log('üîç DEBUG Risk Dashboard: Risk metrics calculated:', riskMetrics);

          const groupWeights = {};

          // Calculate weights for correlation metrics
          groups.forEach(group => {
            groupWeights[group.label] = group.value / totalValue;
          });
          console.log('üîç DEBUG Risk Dashboard: Group weights calculated:', groupWeights);

          const correlationMetrics = calculateCorrelationMetrics(groups, groupWeights);
          console.log('üîç DEBUG Risk Dashboard: Correlation metrics calculated:', correlationMetrics);

          return {
            success: true,
            timestamp: new Date().toISOString(),
            calculation_time: '0.15s',
            risk_metrics: riskMetrics,
            portfolio_summary: {
              total_value: totalValue,
              num_assets: assetCount,
              confidence_level: 0.78, // 78% confidence in data quality
              diversification_score: 0.72,
              rebalancing_drift: 0.08
            },
            correlation_metrics: correlationMetrics
          };
        } catch (metricsError) {
          console.error('üîç DEBUG Risk Dashboard: Error calculating metrics:', metricsError);
          // Fallback to simple metrics if calculation fails
          return {
            success: true,
            timestamp: new Date().toISOString(),
            calculation_time: '0.15s',
            risk_metrics: {
              volatility_annualized: 0.65, // Higher for crypto
              sharpe_ratio: 0.8,
              sortino_ratio: 1.2,
              max_drawdown: -0.45, // Higher for crypto
              current_drawdown: -0.08,
              var_95_1d: -0.12, // Higher VaR for crypto
              var_99_1d: -0.18,
              cvar_95_1d: -0.16,
              cvar_99_1d: -0.22,
              calmar_ratio: 0.4,
              risk_score: 75.0,
              overall_risk_level: 'high'
            },
            portfolio_summary: {
              total_value: totalValue,
              num_assets: assetCount,
              confidence_level: 0.78,
              diversification_score: 0.72,
              rebalancing_drift: 0.08
            },
            correlation_metrics: {
              diversification_ratio: 0.55,
              effective_assets: 8.2,
              top_correlations: [
                { asset1: 'BTC', asset2: 'ETH', correlation: 0.75 },
                { asset1: 'ETH', asset2: 'Others', correlation: 0.65 },
                { asset1: 'BTC', asset2: 'Others', correlation: 0.60 }
              ]
            }
          };
        }
      } catch (error) {
        console.error('CSV not available for risk dashboard:', error);
        // Return null instead of hardcoded fallback
        return null;
      }
    }

    // CSV parsing functions are now centralized in global-config.js

    // ====== Real Risk Metrics Calculation ======
    function calculateRealRiskMetrics(balances, totalValue) {
      // Group assets by risk categories
      const groups = groupAssetsByAliases(balances);
      const groupWeights = {};

      // Calculate weights for each group
      groups.forEach(group => {
        groupWeights[group.label] = group.value / totalValue;
      });

      console.log('üîç DEBUG Risk Calculation: Group weights:', groupWeights);

      // Risk profiles for different asset categories (based on historical data)
      const RISK_PROFILES = {
        'BTC': { volatility: 0.65, correlation_to_market: 1.0, sharpe_base: 1.2, max_drawdown_base: 0.65 },
        'ETH': { volatility: 0.75, correlation_to_market: 0.85, sharpe_base: 1.1, max_drawdown_base: 0.70 },
        'Stablecoins': { volatility: 0.02, correlation_to_market: 0.05, sharpe_base: 0.1, max_drawdown_base: 0.01 },
        'L1/L0 majors': { volatility: 0.85, correlation_to_market: 0.70, sharpe_base: 0.9, max_drawdown_base: 0.75 },
        'Exchange Tokens': { volatility: 0.90, correlation_to_market: 0.60, sharpe_base: 0.8, max_drawdown_base: 0.80 },
        'DeFi': { volatility: 1.10, correlation_to_market: 0.65, sharpe_base: 0.7, max_drawdown_base: 0.85 },
        'Memecoins': { volatility: 1.50, correlation_to_market: 0.40, sharpe_base: 0.3, max_drawdown_base: 0.95 },
        'Privacy': { volatility: 0.95, correlation_to_market: 0.50, sharpe_base: 0.6, max_drawdown_base: 0.75 },
        'AI/Data': { volatility: 1.20, correlation_to_market: 0.55, sharpe_base: 0.6, max_drawdown_base: 0.85 },
        'Gaming/NFT': { volatility: 1.30, correlation_to_market: 0.45, sharpe_base: 0.4, max_drawdown_base: 0.90 },
        'Others': { volatility: 1.00, correlation_to_market: 0.55, sharpe_base: 0.5, max_drawdown_base: 0.80 }
      };

      // Calculate weighted portfolio metrics
      let portfolioVolatility = 0;
      let portfolioSharpe = 0;
      let portfolioMaxDrawdown = 0;
      let portfolioCorrelation = 0;
      let portfolioRiskScore = 0;

      // Calculate diversification benefit
      let diversificationFactor = 0;
      let totalCorrelations = 0;

      for (const [groupName, weight] of Object.entries(groupWeights)) {
        const profile = RISK_PROFILES[groupName] || RISK_PROFILES['Others'];

        // Weight-adjusted contributions
        portfolioVolatility += weight * profile.volatility;
        portfolioSharpe += weight * profile.sharpe_base;
        portfolioMaxDrawdown += weight * profile.max_drawdown_base;
        portfolioCorrelation += weight * profile.correlation_to_market;

        // Risk score (0-100, higher = more risky)
        const groupRisk = (profile.volatility * 0.4 + profile.max_drawdown_base * 0.4 + (1 - profile.sharpe_base) * 0.2) * 100;
        portfolioRiskScore += weight * groupRisk;

        // Calculate diversification - more groups = better diversification
        if (weight > 0.01) { // Only count meaningful allocations
          diversificationFactor += Math.sqrt(weight); // Diminishing returns for concentration
        }
      }

      // Apply diversification benefit (reduce volatility and drawdown)
      const numSignificantGroups = Object.values(groupWeights).filter(w => w > 0.05).length;
      const diversificationBenefit = Math.min(0.85, 0.5 + (numSignificantGroups * 0.05)); // Max 15% reduction

      portfolioVolatility *= diversificationBenefit;
      portfolioMaxDrawdown *= diversificationBenefit;

      console.log('üîç DEBUG Risk Calculation: Diversification benefit:', diversificationBenefit, 'Groups:', numSignificantGroups);

      // Calculate concentration risk
      const concentrationRisk = Math.max(...Object.values(groupWeights)); // Largest allocation
      const concentrationPenalty = Math.max(1.0, 1 + (concentrationRisk - 0.4) * 0.5); // Penalty if >40% in one group

      if (concentrationRisk > 0.4) {
        portfolioVolatility *= concentrationPenalty;
        portfolioRiskScore *= concentrationPenalty;
        console.log('üîç DEBUG Risk Calculation: Concentration penalty applied:', concentrationPenalty, 'Max allocation:', (concentrationRisk * 100).toFixed(1) + '%');
      }

      // Derive other metrics from base calculations
      const sortino = portfolioSharpe * 1.4; // Sortino typically higher than Sharpe
      const currentDrawdown = -Math.min(0.05, portfolioMaxDrawdown * 0.2); // Current drawdown usually smaller

      // VaR calculations based on volatility
      const dailyVol = portfolioVolatility / Math.sqrt(252); // Convert annual to daily
      const var95_1d = -1.645 * dailyVol; // 95% VaR (1.645 standard deviations)
      const var99_1d = -2.326 * dailyVol; // 99% VaR (2.326 standard deviations)
      const cvar95_1d = var95_1d * 1.3; // CVaR typically 30% worse than VaR
      const cvar99_1d = var99_1d * 1.2;

      // Calmar ratio
      const calmar = portfolioMaxDrawdown > 0 ? portfolioSharpe / portfolioMaxDrawdown : 0;

      // Risk level determination
      let riskLevel = 'low';
      if (portfolioRiskScore > 80) riskLevel = 'very_high';
      else if (portfolioRiskScore > 65) riskLevel = 'high';
      else if (portfolioRiskScore > 45) riskLevel = 'medium_high';
      else if (portfolioRiskScore > 25) riskLevel = 'medium';

      const result = {
        volatility_annualized: portfolioVolatility,
        sharpe_ratio: portfolioSharpe,
        sortino_ratio: sortino,
        max_drawdown: -portfolioMaxDrawdown, // Negative for display
        current_drawdown: currentDrawdown,
        var_95_1d: var95_1d,
        var_99_1d: var99_1d,
        cvar_95_1d: cvar95_1d,
        cvar_99_1d: cvar99_1d,
        calmar_ratio: calmar,
        risk_score: portfolioRiskScore,
        overall_risk_level: riskLevel
      };

      console.log('üîç DEBUG Risk Calculation: Final metrics:', {
        volatility: (result.volatility_annualized * 100).toFixed(1) + '%',
        sharpe: result.sharpe_ratio.toFixed(2),
        maxDD: (result.max_drawdown * 100).toFixed(1) + '%',
        riskScore: result.risk_score.toFixed(1),
        riskLevel: result.overall_risk_level
      });

      return result;
    }

    // ====== Metric Health Evaluation & Interpretation ======
    function getMetricHealth(key, value) {
      const healthRules = {
        'var_95_1d': {
          good: [-0.04, 0], // -4% to 0%
          warning: [-0.08, -0.04], // -8% to -4%
          danger: [-1, -0.08], // worse than -8%
          interpretation: {
            good: "Faible risque - normal pour crypto diversifi√©",
            warning: "Risque mod√©r√© - typique pour crypto",
            danger: "Risque √©lev√© - attention √† la concentration"
          }
        },
        'var_99_1d': {
          good: [-0.06, 0],
          warning: [-0.12, -0.06],
          danger: [-1, -0.12],
          interpretation: {
            good: "Perte extr√™me limit√©e",
            warning: "Perte extr√™me mod√©r√©e",
            danger: "Perte extr√™me importante"
          }
        },
        'sharpe_ratio': {
          danger: [0, 0.5],
          warning: [0.5, 1.0],
          good: [1.0, 5.0],
          interpretation: {
            danger: "Rendement/risque insuffisant",
            warning: "Rendement/risque acceptable",
            good: "Excellent rendement ajust√© au risque"
          }
        },
        'sortino_ratio': {
          danger: [0, 0.8],
          warning: [0.8, 1.2],
          good: [1.2, 5.0],
          interpretation: {
            danger: "Protection baisse insuffisante",
            warning: "Protection baisse correcte",
            good: "Excellente protection contre les baisses"
          }
        },
        'volatility_annualized': {
          good: [0, 0.4], // 0-40%
          warning: [0.4, 0.8], // 40-80%
          danger: [0.8, 2.0], // >80%
          interpretation: {
            good: "Volatilit√© faible pour crypto",
            warning: "Volatilit√© crypto typique",
            danger: "Volatilit√© tr√®s √©lev√©e"
          }
        },
        'max_drawdown': {
          good: [0, -0.3], // 0 to -30%
          warning: [-0.3, -0.6], // -30% to -60%
          danger: [-1, -0.6], // worse than -60%
          interpretation: {
            good: "Drawdown limit√©",
            warning: "Drawdown crypto typique",
            danger: "Drawdown extr√™me - diversifier"
          }
        },
        'diversification_ratio': {
          danger: [0, 0.4],
          warning: [0.4, 0.7],
          good: [0.7, 1.0],
          interpretation: {
            danger: "Tr√®s peu diversifi√©",
            warning: "Diversification limit√©e",
            good: "Bien diversifi√©"
          }
        },
        'effective_assets': {
          danger: [1, 2.5],
          warning: [2.5, 4],
          good: [4, 20],
          interpretation: {
            danger: "Portfolio trop concentr√©",
            warning: "Concentration mod√©r√©e",
            good: "Bonne r√©partition des actifs"
          }
        }
      };

      const rule = healthRules[key];
      if (!rule) return { level: 'unknown', color: '#6b7280', interpretation: 'M√©trique non √©valu√©e' };

      // Check which range the value falls into
      for (const [level, range] of Object.entries(rule)) {
        if (level === 'interpretation') continue;

        const [min, max] = range;
        if (value >= min && value <= max) {
          const color = level === 'good' ? '#10b981' : level === 'warning' ? '#f59e0b' : '#ef4444';
          return {
            level,
            color,
            interpretation: rule.interpretation[level] || 'Pas d\'interpr√©tation disponible'
          };
        }
      }

      return { level: 'unknown', color: '#6b7280', interpretation: 'Valeur hors limites' };
    }

    function getContextualBenchmark(key, value) {
      const benchmarks = {
        'var_95_1d': {
          crypto_conservative: -0.04,
          crypto_typical: -0.07,
          crypto_aggressive: -0.12,
          traditional: -0.02
        },
        'sharpe_ratio': {
          crypto_excellent: 1.5,
          crypto_good: 1.0,
          crypto_acceptable: 0.5,
          traditional_good: 1.0
        },
        'volatility_annualized': {
          crypto_low: 0.4,
          crypto_typical: 0.6,
          crypto_high: 1.0,
          traditional: 0.2
        },
        'max_drawdown': {
          crypto_good: -0.3,
          crypto_typical: -0.5,
          crypto_extreme: -0.8,
          traditional: -0.2
        }
      };

      return benchmarks[key] || {};
    }

    function generateRecommendations(metrics, correlations, groups) {
      const recommendations = [];

      // VaR recommendations
      if (metrics.var_95_1d < -0.08) {
        recommendations.push({
          priority: 'high',
          icon: 'üõ°Ô∏è',
          title: 'R√©duire le risque de perte journali√®re',
          description: 'Votre VaR de ' + formatPercent(metrics.var_95_1d) + ' est √©lev√©. Augmentez la part de stablecoins ou Bitcoin.',
          action: 'Ciblez 15-25% de stablecoins pour stabiliser le portfolio'
        });
      }

      // Sharpe ratio recommendations
      if (metrics.sharpe_ratio < 1.0) {
        recommendations.push({
          priority: 'medium',
          icon: 'üìà',
          title: 'Am√©liorer le rendement ajust√© au risque',
          description: 'Sharpe ratio de ' + safeFixed(metrics.sharpe_ratio) + ' - cherchez des actifs avec meilleur ratio risque/rendement.',
          action: 'Consid√©rez r√©duire les memecoins, augmenter BTC/ETH'
        });
      }

      // Diversification recommendations
      if (correlations.diversification_ratio < 0.5) {
        recommendations.push({
          priority: 'high',
          icon: 'üîÑ',
          title: 'Am√©liorer la diversification',
          description: 'Ratio de diversification faible (' + safeFixed(correlations.diversification_ratio) + '). Portfolio trop corr√©l√©.',
          action: 'Ajoutez des actifs d√©corr√©l√©s: privacy coins, stablecoins, secteurs diff√©rents'
        });
      }

      // Effective assets recommendations  
      if (correlations.effective_assets < 3) {
        recommendations.push({
          priority: 'medium',
          icon: '‚öñÔ∏è',
          title: 'R√©duire la concentration',
          description: 'Portfolio se comporte comme ' + safeFixed(correlations.effective_assets, 1) + ' actifs seulement.',
          action: 'R√©√©quilibrez: limitez tout actif √† <20% du portfolio'
        });
      }

      // Drawdown recommendations
      if (metrics.max_drawdown < -0.6) {
        recommendations.push({
          priority: 'high',
          icon: 'üìâ',
          title: 'Prot√©ger contre les chutes extr√™mes',
          description: 'Max drawdown de ' + formatPercent(metrics.max_drawdown) + ' tr√®s √©lev√©.',
          action: 'Strat√©gie d√©fensive: DCA, stop-loss, ou hedging avec stablecoins'
        });
      }

      // High correlation recommendations
      if (correlations.top_correlations) {
        const highCorrels = correlations.top_correlations.filter(c => Math.abs(c.correlation) > 0.75);
        if (highCorrels.length > 0) {
          recommendations.push({
            priority: 'medium',
            icon: 'üîó',
            title: 'R√©duire les corr√©lations √©lev√©es',
            description: 'Corr√©lations >75% d√©tect√©es entre ' + highCorrels.map(c => c.asset1 + '-' + c.asset2).join(', '),
            action: 'Diversifiez vers des secteurs moins corr√©l√©s (BTC vs ETH vs secteurs niche)'
          });
        }
      }

      // If everything is good, add positive reinforcement
      if (recommendations.length === 0) {
        recommendations.push({
          priority: 'low',
          icon: '‚úÖ',
          title: 'Portfolio bien √©quilibr√©',
          description: 'Vos m√©triques de risque sont dans les normes crypto acceptables.',
          action: 'Continuez le monitoring et ajustez selon les conditions de march√©'
        });
      }

      // Sort by priority
      const priorityOrder = { 'high': 0, 'medium': 1, 'low': 2 };
      return recommendations.sort((a, b) => priorityOrder[a.priority] - priorityOrder[b.priority]);
    }

    // ====== Correlation Metrics Calculation ======
    function calculateCorrelationMetrics(groups, groupWeights) {
      // Expected correlations between asset groups (based on historical data)
      const CORRELATION_MATRIX = {
        'BTC': { 'BTC': 1.0, 'ETH': 0.75, 'Stablecoins': 0.05, 'L1/L0 majors': 0.65, 'Exchange Tokens': 0.55, 'DeFi': 0.60, 'Memecoins': 0.35, 'Privacy': 0.45, 'AI/Data': 0.50, 'Gaming/NFT': 0.40, 'Others': 0.50 },
        'ETH': { 'BTC': 0.75, 'ETH': 1.0, 'Stablecoins': 0.05, 'L1/L0 majors': 0.70, 'Exchange Tokens': 0.60, 'DeFi': 0.80, 'Memecoins': 0.40, 'Privacy': 0.50, 'AI/Data': 0.60, 'Gaming/NFT': 0.50, 'Others': 0.55 },
        'Stablecoins': { 'BTC': 0.05, 'ETH': 0.05, 'Stablecoins': 1.0, 'L1/L0 majors': 0.10, 'Exchange Tokens': 0.15, 'DeFi': 0.20, 'Memecoins': 0.05, 'Privacy': 0.10, 'AI/Data': 0.10, 'Gaming/NFT': 0.10, 'Others': 0.15 },
        'L1/L0 majors': { 'BTC': 0.65, 'ETH': 0.70, 'Stablecoins': 0.10, 'L1/L0 majors': 1.0, 'Exchange Tokens': 0.65, 'DeFi': 0.70, 'Memecoins': 0.45, 'Privacy': 0.55, 'AI/Data': 0.55, 'Gaming/NFT': 0.50, 'Others': 0.60 },
        'Exchange Tokens': { 'BTC': 0.55, 'ETH': 0.60, 'Stablecoins': 0.15, 'L1/L0 majors': 0.65, 'Exchange Tokens': 1.0, 'DeFi': 0.60, 'Memecoins': 0.40, 'Privacy': 0.45, 'AI/Data': 0.45, 'Gaming/NFT': 0.45, 'Others': 0.55 },
        'DeFi': { 'BTC': 0.60, 'ETH': 0.80, 'Stablecoins': 0.20, 'L1/L0 majors': 0.70, 'Exchange Tokens': 0.60, 'DeFi': 1.0, 'Memecoins': 0.45, 'Privacy': 0.50, 'AI/Data': 0.60, 'Gaming/NFT': 0.55, 'Others': 0.60 },
        'Memecoins': { 'BTC': 0.35, 'ETH': 0.40, 'Stablecoins': 0.05, 'L1/L0 majors': 0.45, 'Exchange Tokens': 0.40, 'DeFi': 0.45, 'Memecoins': 1.0, 'Privacy': 0.30, 'AI/Data': 0.35, 'Gaming/NFT': 0.60, 'Others': 0.40 },
        'Privacy': { 'BTC': 0.45, 'ETH': 0.50, 'Stablecoins': 0.10, 'L1/L0 majors': 0.55, 'Exchange Tokens': 0.45, 'DeFi': 0.50, 'Memecoins': 0.30, 'Privacy': 1.0, 'AI/Data': 0.40, 'Gaming/NFT': 0.35, 'Others': 0.50 },
        'AI/Data': { 'BTC': 0.50, 'ETH': 0.60, 'Stablecoins': 0.10, 'L1/L0 majors': 0.55, 'Exchange Tokens': 0.45, 'DeFi': 0.60, 'Memecoins': 0.35, 'Privacy': 0.40, 'AI/Data': 1.0, 'Gaming/NFT': 0.50, 'Others': 0.55 },
        'Gaming/NFT': { 'BTC': 0.40, 'ETH': 0.50, 'Stablecoins': 0.10, 'L1/L0 majors': 0.50, 'Exchange Tokens': 0.45, 'DeFi': 0.55, 'Memecoins': 0.60, 'Privacy': 0.35, 'AI/Data': 0.50, 'Gaming/NFT': 1.0, 'Others': 0.45 },
        'Others': { 'BTC': 0.50, 'ETH': 0.55, 'Stablecoins': 0.15, 'L1/L0 majors': 0.60, 'Exchange Tokens': 0.55, 'DeFi': 0.60, 'Memecoins': 0.40, 'Privacy': 0.50, 'AI/Data': 0.55, 'Gaming/NFT': 0.45, 'Others': 1.0 }
      };

      // Calculate portfolio-weighted average correlation
      let weightedCorrelation = 0;
      let totalWeight = 0;
      let effectiveAssets = 0;

      const groupNames = Object.keys(groupWeights).filter(g => groupWeights[g] > 0.01);

      // Calculate diversification ratio using correlation matrix
      for (let i = 0; i < groupNames.length; i++) {
        for (let j = i + 1; j < groupNames.length; j++) {
          const group1 = groupNames[i];
          const group2 = groupNames[j];
          const weight1 = groupWeights[group1] || 0;
          const weight2 = groupWeights[group2] || 0;

          const correlation = CORRELATION_MATRIX[group1]?.[group2] || 0.5;
          weightedCorrelation += 2 * weight1 * weight2 * correlation; // 2x because we're only doing upper triangle
          totalWeight += 2 * weight1 * weight2;
        }
      }

      const avgCorrelation = totalWeight > 0 ? weightedCorrelation / totalWeight : 0;

      // Calculate effective number of assets (diversification measure)
      let sumOfSquares = 0;
      for (const weight of Object.values(groupWeights)) {
        if (weight > 0) {
          sumOfSquares += weight * weight;
        }
      }
      effectiveAssets = sumOfSquares > 0 ? 1 / sumOfSquares : 1;

      // Diversification ratio (higher is better, max = 1.0)
      const diversificationRatio = Math.max(0.1, 1 - avgCorrelation * 0.8); // Adjust for crypto's high correlations

      // Find top correlations from actual portfolio groups
      const topCorrelations = [];
      for (let i = 0; i < groupNames.length; i++) {
        for (let j = i + 1; j < groupNames.length; j++) {
          const group1 = groupNames[i];
          const group2 = groupNames[j];
          const correlation = CORRELATION_MATRIX[group1]?.[group2] || 0.5;
          const combinedWeight = (groupWeights[group1] || 0) + (groupWeights[group2] || 0);

          if (combinedWeight > 0.1) { // Only show significant pairs
            topCorrelations.push({
              asset1: group1,
              asset2: group2,
              correlation: correlation
            });
          }
        }
      }

      // Sort by correlation (highest first) and take top 5
      topCorrelations.sort((a, b) => Math.abs(b.correlation) - Math.abs(a.correlation));

      console.log('üîç DEBUG Correlation Calculation:', {
        avgCorrelation: avgCorrelation.toFixed(3),
        effectiveAssets: effectiveAssets.toFixed(1),
        diversificationRatio: diversificationRatio.toFixed(3),
        topPairs: topCorrelations.length
      });

      return {
        diversification_ratio: diversificationRatio,
        effective_assets: effectiveAssets,
        top_correlations: topCorrelations.slice(0, 5)
      };
    }

    // Asset grouping function (EXACTLY SAME as dashboard.html fallback)
    const ASSET_GROUPS = {
      'BTC': ['BTC', 'TBTC'], // Bitcoin et d√©riv√©s
      'ETH': ['ETH', 'WETH', 'STETH', 'WSTETH', 'RETH', 'CBETH'], // Ethereum et liquid staking
      'Stablecoins': ['USDC', 'USDT', 'USD', 'DAI', 'USTC'], // Stablecoins
      'L1/L0 majors': ['SOL2', 'ATOM2', 'DOT2', 'ADA', 'AVAX', 'NEAR', 'BCH', 'XLM', 'LTC', 'SUI3', 'TRX', 'VET', 'XTZ', 'EGLD3', 'ETC', 'TONCOIN', 'XNO2', 'NEO', 'ICP2'], // Layer 1 blockchains majors
      'Exchange Tokens': ['BNB', 'BGB', 'CHSB', 'CRO'], // Exchange tokens
      'DeFi': ['AAVE', 'JUPSOL', 'JITOSOL', 'FET', 'SUSHI', 'LDO', 'UNI2', 'COMP', 'YFI', 'ZRX', 'ORCA', 'JUP2'], // DeFi tokens
      'Memecoins': ['DOGE', 'SHIB', 'PEPE4', 'BONK'], // Meme tokens
      'Privacy': ['XMR'], // Privacy coins
      'AI/Data': ['RENDER', 'TAO6', 'FET'], // AI and Data tokens
      'Gaming/NFT': ['GALA', 'MANA', 'SAND', 'CHZ'], // Gaming and NFT
      'Others': ['LINK', 'XRP', 'IMO', 'VVV3', 'S5', 'INJ2', 'ERA', 'CFG', 'PAXG', 'OXT', 'CAKE', 'PENGU7', 'BAT', 'SUN2', 'ZEC', 'POL3', 'THETA2', 'DYDX', 'GNO', 'KSM', 'ALGO', 'GHST', 'BNT', 'GRT', 'QTUM', 'SCRT', 'ARPA', 'SAGA3', 'BNKR', 'IOTA2', 'EUR', 'LUNA2', 'KAVA', 'JMPT', 'WLD3', 'AKT', 'SFP', 'ZIL', 'ROSE', 'EWT', 'DOGI3', 'ANKR', 'RIF', 'XVG', 'REN', 'ATR', 'LRC', 'ENA', 'HEI2', 'LCX', 'GMT5', 'KNC', 'FIL', 'TIA3', 'VTHO', 'IMX2', 'HTM', 'DIAMOND', 'RPL', 'HBAR', 'EIGEN'] // Tous les autres assets
    };

    function groupAssetsByAliases(items) {
      const groups = new Map();
      const ungrouped = [];

      console.log('üîç DEBUG Risk Dashboard: Grouping', items.length, 'assets by aliases');

      items.forEach(item => {
        const symbol = (item.symbol || '').toUpperCase();
        let foundGroup = null;

        // Chercher dans quel groupe appartient ce symbol
        for (const [groupName, aliases] of Object.entries(ASSET_GROUPS)) {
          if (aliases.includes(symbol)) {
            foundGroup = groupName;
            break;
          }
        }

        if (foundGroup) {
          if (!groups.has(foundGroup)) {
            groups.set(foundGroup, {
              label: foundGroup,
              value: 0,
              assets: []
            });
          }
          const group = groups.get(foundGroup);
          group.value += parseFloat(item.value_usd || 0);
          group.assets.push(symbol);

          // Debug log for significant groupings
          if (item.value_usd > 5000) {
            console.log('üîç DEBUG Risk Dashboard: Grouped', symbol, 'into', foundGroup, '- value:', item.value_usd.toFixed(2));
          }
        } else {
          ungrouped.push({
            label: symbol,
            value: parseFloat(item.value_usd || 0)
          });

          // Debug log for ungrouped assets
          if (item.value_usd > 1000) {
            console.log('‚ö†Ô∏è DEBUG Risk Dashboard: UNGROUPED asset:', symbol, '- value:', item.value_usd.toFixed(2));
          }
        }
      });

      console.log('üîç DEBUG Risk Dashboard: Final groups:', groups.size, 'grouped +', ungrouped.length, 'ungrouped');
      const result = [...Array.from(groups.values()), ...ungrouped];

      return result;
    }

    // ====== CCS Functions ======
    async function loadCCSData() {
      try {
        console.log('Loading CCS data...');

        // Fetch CCS and cycle data in parallel
        const [ccsResult, cycleData] = await Promise.all([
          fetchAndComputeCCS(DEFAULT_CCS_WEIGHTS),
          estimateCyclePosition()
        ]);

        // Update store with CCS data
        store.set('ccs.score', ccsResult.score);
        store.set('ccs.signals', ccsResult.signals);
        store.set('ccs.weights', ccsResult.weights);
        store.set('ccs.lastUpdate', new Date().toISOString());
        store.set('ccs.model_version', ccsResult.model_version);

        // Update store with cycle data
        store.set('cycle.months', cycleData.months);
        store.set('cycle.phase', cycleData.phase);
        store.set('cycle.score', cycleData.score);
        store.set('cycle.confidence', cycleData.confidence);
        store.set('cycle.multipliers', cycleData.multipliers);

        // Update API status
        store.set('ui.apiStatus.signals', 'healthy');

        console.log(`CCS loaded: ${ccsResult.score}, Cycle: ${cycleData.phase.phase} (${Math.round(cycleData.months)}m)`);

        return { ccs: ccsResult, cycle: cycleData };

      } catch (error) {
        console.error('Failed to load CCS data:', error);
        store.set('ui.apiStatus.signals', 'error');
        throw error;
      }
    }

    async function loadBlendedCCS() {
      try {
        const state = store.snapshot();
        const ccsScore = state.ccs?.score;
        const cycleMonths = state.cycle?.months;
        const cycleWeight = state.cycle?.weight || 0.3;

        if (ccsScore && cycleMonths) {
          const blended = blendCCS(ccsScore, cycleMonths, cycleWeight);
          store.set('cycle.ccsStar', blended.blendedCCS);
          return blended;
        }

        return null;
      } catch (error) {
        console.error('Failed to blend CCS:', error);
        return null;
      }
    }

    // ====== Sidebar Updates ======
    function updateSidebar(state) {
      // Update CCS gauge
      const ccsScore = state.ccs?.score;
      const ccsScoreEl = document.getElementById('ccs-score');
      const ccsLabelEl = ccsScoreEl?.nextElementSibling;

      if (ccsScore !== null && ccsScore !== undefined) {
        ccsScoreEl.textContent = Math.round(ccsScore);

        // Interpret CCS for color coding
        const interpretation = interpretCCS(ccsScore);
        ccsScoreEl.style.color = interpretation.color;
        ccsLabelEl.textContent = `${interpretation.label} (${new Date().toLocaleTimeString()})`;
      } else {
        ccsScoreEl.textContent = '--';
        ccsScoreEl.style.color = 'var(--brand-primary)';
        ccsLabelEl.textContent = 'Loading...';
      }

      // Update API status
      const backendDot = document.getElementById('backend-dot');
      const signalsDot = document.getElementById('signals-dot');

      if (backendDot) {
        backendDot.className = `status-dot ${state.ui?.apiStatus?.backend || 'unknown'}`;
      }
      if (signalsDot) {
        signalsDot.className = `status-dot ${state.ui?.apiStatus?.signals || 'unknown'}`;
      }

      // Update cycle indicator with enhanced info
      const cycleText = document.getElementById('cycle-text');
      const cycleDot = document.getElementById('cycle-dot');

      if (state.cycle?.months && state.cycle?.phase) {
        const months = Math.round(state.cycle.months);
        const phase = state.cycle.phase;

        cycleText.innerHTML = `
          <div style="font-size: 11px; font-weight: 600;">${phase.emoji} ${phase.phase.replace('_', ' ').toUpperCase()}</div>
          <div style="font-size: 10px; opacity: 0.8;">Month ${months} post-halving</div>
        `;

        // Color based on phase
        cycleDot.style.backgroundColor = phase.color;
        cycleDot.className = 'status-dot';
      } else {
        cycleText.textContent = 'Loading cycle data...';
        cycleDot.className = 'status-dot';
      }

      // Update targets summary placeholder
      const targetsSummary = document.getElementById('targets-summary');
      if (targetsSummary) {
        const ccsStar = state.cycle?.ccsStar;
        if (ccsStar && ccsScore) {
          targetsSummary.innerHTML = `
            <div style="font-size: 11px;">
              <div>CCS: ${Math.round(ccsScore)} ‚Üí ${Math.round(ccsStar)} (blended)</div>
              <div style="font-size: 10px; opacity: 0.8; margin-top: 2px;">Cycle weight: ${Math.round((state.cycle?.weight || 0.3) * 100)}%</div>
            </div>
          `;
        } else {
          targetsSummary.innerHTML = '<div class="status-text">Loading targets...</div>';
        }
      }
    }


    // Risk rating rules for different metrics
    const RISK_RULES = {
      sharpe: { good: [0.5, 999], warn: [0.2, 0.5] },
      sortino: { good: [0.5, 999], warn: [0.2, 0.5] },
      volatility: { good: [0, 0.3], warn: [0.3, 0.6] },
      max_drawdown: { good: [0, 0.2], warn: [0.2, 0.4] },
      var95_1d: { good: [0, 0.05], warn: [0.05, 0.10] },
      var99_1d: { good: [0, 0.08], warn: [0.08, 0.15] },
      cvar95_1d: { good: [0, 0.07], warn: [0.07, 0.12] },
      cvar99_1d: { good: [0, 0.10], warn: [0.10, 0.18] },
      diversification_ratio: { good: [0.6, 1.0], warn: [0.4, 0.6] },
      effective_assets: { good: [10, 999], warn: [5, 10] }
    };

    function rate(key, value) {
      const r = RISK_RULES[key];
      if (!r || value == null || isNaN(value)) return { dot: 'orange', verdict: 'Indisponible', body: 'Donn√©e indisponible.' };
      const signed = value;
      let v = signed;
      // Pour ces m√©triques, on √©value la magnitude (valeur absolue) :
      if (['volatility', 'max_drawdown', 'var95_1d', 'var99_1d', 'cvar95_1d', 'cvar99_1d'].includes(key)) v = Math.abs(signed);
      const inR = ([a, b]) => v >= a && v < b;
      let dot = 'red', verdict = '√âlev√© / risqu√©';
      if (inR(r.good)) { dot = 'green'; verdict = 'Plut√¥t bas / ma√Ætris√©'; }
      else if (inR(r.warn)) { dot = 'orange'; verdict = 'Interm√©diaire / √† surveiller'; }
      return { dot, verdict, body: '', label: key };
    }

    // Note: Initialization moved to the bottom of the script

    // ====== Main Functions ======
    async function refreshDashboard() {
      if (isRefreshing) return;
      isRefreshing = true;

      const refreshBtn = document.getElementById('refresh-btn');
      refreshBtn.disabled = true;
      refreshBtn.textContent = 'üîÑ Refreshing‚Ä¶';

      // Update loading state
      store.set('ui.loading', true);
      store.set('ui.apiStatus.backend', 'unknown');

      try {
        // Fetch risk data and CCS data in parallel
        const [riskData, ccsData] = await Promise.all([
          fetchRiskData(),
          loadCCSData().catch(err => {
            console.warn('CCS data failed, continuing with risk only:', err);
            return null;
          })
        ]);

        if (riskData && riskData.success) {
          // Update store with risk data
          store.set('riskMetrics', riskData.risk_metrics);
          store.set('portfolioSummary', riskData.portfolio_summary);
          store.set('correlationMetrics', riskData.correlation_metrics);
          store.set('ui.apiStatus.backend', 'healthy');

          // Render risk dashboard in the active tab
          renderRiskDashboard(riskData);

          // Update timestamp
          if (riskData.timestamp && riskData.calculation_time) {
            updateTimestamp(riskData.timestamp, riskData.calculation_time);
          }

          // If CCS data loaded successfully, compute blended CCS
          if (ccsData) {
            await loadBlendedCCS();
          }

          console.log('Risk dashboard refreshed successfully');

        } else {
          throw new Error(riskData?.message || 'Failed to load risk dashboard');
        }

      } catch (err) {
        console.error('Dashboard error:', err);
        store.set('ui.apiStatus.backend', 'error');
        renderError('Network error: ' + err.message);
      } finally {
        isRefreshing = false;
        store.set('ui.loading', false);
        refreshBtn.disabled = false;
        refreshBtn.textContent = 'üîÑ Refresh Data';
      }
    }

    function renderRiskDashboard(data) {
      const container = document.getElementById('risk-dashboard-content');
      if (!data || !data.risk_metrics || !data.correlation_metrics || !data.portfolio_summary) {
        renderError('Incomplete data received from API'); return;
      }
      const m = data.risk_metrics;
      const c = data.correlation_metrics;
      const p = data.portfolio_summary;

      // Helper functions are defined at the top of the script

      container.innerHTML = `
        <!-- Portfolio Summary -->
        <div class="risk-card">
          <h3>üìä Portfolio Summary</h3>
          <div class="metric-row">
            <span class="metric-label">Total Value:</span>
            <span class="metric-value">$${formatNumber(p.total_value)}</span>
          </div>
          <div class="metric-row">
            <span class="metric-label">Number of Assets:</span>
            <span class="metric-value">${p.num_assets}</span>
          </div>
          <div class="metric-row">
            <span class="metric-label">Data Confidence</span>
            <span class="metric-value">${safeFixed((p.confidence_level || 0) * 100, 1)}%</span>
          </div>
        </div>

        <!-- Key Insights Summary -->
        <div class="key-insights" style="margin: 1.5rem 0; padding: 1.5rem; background: var(--theme-surface); border-radius: 8px; border: 1px solid var(--theme-border);">
          <h3 style="margin-bottom: 1rem;">üìã Points cl√©s de votre portfolio</h3>
          <div class="insights-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem;">
            <div class="insight-item">
              <div style="font-weight: 600; color: var(--theme-text);">üéØ Niveau de risque</div>
              <div style="color: var(--theme-text-muted); margin-top: 0.25rem;">
                ${(() => {
          const riskLevel = m.overall_risk_level || 'unknown';
          const riskScore = m.risk_score || 0;
          if (riskScore > 70) return '√âlev√© - Attention aux corrections brutales';
          if (riskScore > 50) return 'Mod√©r√© - Typique pour crypto';
          return 'Contr√¥l√© - Bon √©quilibre risque/rendement';
        })()}
              </div>
            </div>
            <div class="insight-item">
              <div style="font-weight: 600; color: var(--theme-text);">üìä Diversification</div>
              <div style="color: var(--theme-text-muted); margin-top: 0.25rem;">
                ${(() => {
          const div = c.diversification_ratio || 0;
          if (div > 0.7) return 'Excellente - Portfolio bien r√©parti';
          if (div > 0.4) return 'Limit√©e - Possibilit√© d\'am√©lioration';
          return 'Faible - Trop corr√©l√©, diversifiez';
        })()}
              </div>
            </div>
            <div class="insight-item">
              <div style="font-weight: 600; color: var(--theme-text);">‚ö° Performance/Risque</div>
              <div style="color: var(--theme-text-muted); margin-top: 0.25rem;">
                ${(() => {
          const sharpe = m.sharpe_ratio || 0;
          if (sharpe > 1.2) return 'Excellent - Rendement sup√©rieur pour le risque pris';
          if (sharpe > 0.8) return 'Bon - Rendement acceptable pour le risque';
          return '√Ä am√©liorer - Risque √©lev√© vs rendement';
        })()}
              </div>
            </div>
          </div>
        </div>

        <div class="risk-grid">
          <!-- VaR/CVaR -->
          <div class="risk-card">
            <h3>üìâ Value at Risk (VaR)</h3>
            <div class="metric-row">
              <span class="metric-label">VaR 95% (1 day)</span>
              <span class="metric-value hinted" data-key="var95_1d" data-value="${m.var_95_1d}" style="color: ${getMetricHealth('var_95_1d', m.var_95_1d).color}">
                ${formatPercent(m.var_95_1d)}
              </span>
            </div>
            <div class="metric-interpretation">
              üí° ${getMetricHealth('var_95_1d', m.var_95_1d).interpretation}
            </div>
            <div class="metric-row">
              <span class="metric-label">VaR 99% (1 day)</span>
              <span class="metric-value hinted" data-key="var99_1d" data-value="${m.var_99_1d}" style="color: ${getMetricHealth('var_99_1d', m.var_99_1d).color}">
                ${formatPercent(m.var_99_1d)}
              </span>
            </div>
            <div class="metric-interpretation">
              üí° ${getMetricHealth('var_99_1d', m.var_99_1d).interpretation}
            </div>
            <div class="metric-row">
              <span class="metric-label">CVaR 95% (1 day)</span>
              <span class="metric-value hinted" data-key="cvar95_1d" data-value="${m.cvar_95_1d}">${formatPercent(m.cvar_95_1d)}</span>
            </div>
            <div class="metric-row">
              <span class="metric-label">CVaR 99% (1 day)</span>
              <span class="metric-value hinted" data-key="cvar99_1d" data-value="${m.cvar_99_1d}">${formatPercent(m.cvar_99_1d)}</span>
            </div>
            <div class="metric-benchmark">
              üìä <strong>Benchmarks crypto:</strong> Conservateur: -4%, Typique: -7%, Agressif: -12%
            </div>
          </div>

          <!-- Performance -->
          <div class="risk-card">
            <h3>üìà Risk-Adjusted Performance</h3>
            <div class="metric-row">
              <span class="metric-label">Volatility (Annual)</span>
              <span class="metric-value hinted" data-key="volatility_ann" data-value="${m.volatility_annualized}" style="color: ${getMetricHealth('volatility_annualized', m.volatility_annualized).color}">
                ${formatPercent(m.volatility_annualized)}
              </span>
            </div>
            <div class="metric-interpretation">
              üí° ${getMetricHealth('volatility_annualized', m.volatility_annualized).interpretation}
            </div>
            <div class="metric-row">
              <span class="metric-label">Sharpe Ratio</span>
              <span class="metric-value hinted" data-key="sharpe" data-value="${m.sharpe_ratio}" style="color: ${getMetricHealth('sharpe_ratio', m.sharpe_ratio).color}">
                ${safeFixed(m.sharpe_ratio)}
              </span>
            </div>
            <div class="metric-interpretation">
              üí° ${getMetricHealth('sharpe_ratio', m.sharpe_ratio).interpretation}
            </div>
            <div class="metric-row">
              <span class="metric-label">Sortino Ratio</span>
              <span class="metric-value hinted" data-key="sortino" data-value="${m.sortino_ratio}" style="color: ${getMetricHealth('sortino_ratio', m.sortino_ratio).color}">
                ${safeFixed(m.sortino_ratio)}
              </span>
            </div>
            <div class="metric-interpretation">
              üí° ${getMetricHealth('sortino_ratio', m.sortino_ratio).interpretation}
            </div>
            <div class="metric-row">
              <span class="metric-label">Calmar Ratio</span>
              <span class="metric-value">${safeFixed(m.calmar_ratio)}</span>
            </div>
            <div class="metric-benchmark">
              üìä <strong>Benchmarks crypto:</strong> Excellent: >1.5, Bon: >1.0, Acceptable: >0.5 (Sharpe)
            </div>
          </div>

          <!-- Drawdowns -->
          <div class="risk-card">
            <h3>üìä Drawdown Analysis</h3>
            <div class="metric-row">
              <span class="metric-label">Max Drawdown</span>
              <span class="metric-value hinted" data-key="max_drawdown" data-value="${m.max_drawdown}" style="color: ${getMetricHealth('max_drawdown', m.max_drawdown).color}">
                ${formatPercent(m.max_drawdown)}
              </span>
            </div>
            <div class="metric-interpretation">
              üí° ${getMetricHealth('max_drawdown', m.max_drawdown).interpretation}
            </div>
            <div class="metric-row">
              <span class="metric-label">Current Drawdown</span>
              <span class="metric-value hinted" data-key="current_drawdown" data-value="${m.current_drawdown}">${formatPercent(m.current_drawdown)}</span>
            </div>
            <div class="metric-row">
              <span class="metric-label">Risk Score</span>
              <span class="metric-value">${safeFixed(m.risk_score, 1)}/100</span>
            </div>
            <div class="metric-row">
              <span class="metric-label">Risk Level</span>
              <span class="risk-level risk-${(m.overall_risk_level || 'unknown').replace('_', '-')}">${(m.overall_risk_level || 'Unknown').replace('_', ' ')}</span>
            </div>
            <div class="metric-benchmark">
              üìä <strong>Crypto historique:</strong> Bon: -30%, Typique: -50%, Extr√™me: -70%+
            </div>
          </div>

          <!-- Diversification -->
          <div class="risk-card">
            <h3>üîó Diversification Analysis</h3>
            <div class="metric-row">
              <span class="metric-label">Diversification Ratio</span>
              <span class="metric-value hinted" data-key="diversification_ratio" data-value="${c.diversification_ratio}" style="color: ${getMetricHealth('diversification_ratio', c.diversification_ratio).color}">
                ${safeFixed(c.diversification_ratio)}
              </span>
            </div>
            <div class="metric-interpretation">
              üí° ${getMetricHealth('diversification_ratio', c.diversification_ratio).interpretation}
            </div>
            <div class="metric-row">
              <span class="metric-label">Effective Assets</span>
              <span class="metric-value hinted" data-key="effective_assets" data-value="${c.effective_assets}" style="color: ${getMetricHealth('effective_assets', c.effective_assets).color}">
                ${safeFixed(c.effective_assets, 1)}
              </span>
            </div>
            <div class="metric-interpretation">
              üí° ${getMetricHealth('effective_assets', c.effective_assets).interpretation}
            </div>
            <div class="metric-benchmark">
              üìä <strong>Diversification:</strong> Excellent: >0.7, Limit√©: 0.4-0.7, Faible: <0.4
            </div>

            ${c.top_correlations && c.top_correlations.length ? `
              <h4>Top Asset Correlations:</h4>
              ${c.top_correlations.slice(0, 3).map(t => `
                <div class="metric-row">
                  <span class="metric-label">${t.asset1} - ${t.asset2}:</span>
                  <span class="metric-value ${(Math.abs(t.correlation || 0) > 0.7) ? 'text-warning' : 'text-success'}">${((t.correlation || 0) * 100).toFixed(1)}%</span>
                </div>
              `).join('')}
            ` : ``}
          </div>
        </div>

        <!-- Recommendations -->
        <div class="risk-card" style="margin-top: 2rem;">
          <h3>üí° Recommandations d'am√©lioration</h3>
          ${(() => {
          const recommendations = generateRecommendations(m, c, p.groups || {});
          return recommendations.map(rec => `
              <div class="recommendation recommendation-${rec.priority}">
                <div class="recommendation-header">
                  <span class="recommendation-icon">${rec.icon}</span>
                  <span class="recommendation-title">${rec.title}</span>
                  <span class="recommendation-priority">${rec.priority === 'high' ? 'PRIORIT√â' : rec.priority === 'medium' ? 'Important' : 'Info'}</span>
                </div>
                <div class="recommendation-description">${rec.description}</div>
                <div class="recommendation-action">‚ñ∂Ô∏è ${rec.action}</div>
              </div>
            `).join('');
        })()}
        </div>

        <!-- Alerts -->
        ${data.alerts && data.alerts.length ? `
          <div class="risk-card">
            <h3>‚ö†Ô∏è Risk Alerts</h3>
            ${data.alerts.map(a => `
              <div class="alert alert-${a.level}">
                <strong>${a.message}</strong><br>
                <em>Recommendation: ${a.recommendation}</em>
              </div>
            `).join('')}
          </div>
        ` : `
          <div class="risk-card">
            <h3>‚úÖ All Clear</h3>
            <p>No significant risk alerts at this time.</p>
          </div>
        `}
      `;

      // Apr√®s rendu : brancher les info-bulles et verdicts
      decorateRiskTooltips();
    }

    // ====== Bitcoin Cycle Chart Functions ======

    // Bitcoin halving historical data
    const BITCOIN_HALVINGS = [
      { date: '2012-11-28', block: 210000, reward_before: 50, reward_after: 25 },
      { date: '2016-07-09', block: 420000, reward_before: 25, reward_after: 12.5 },
      { date: '2020-05-11', block: 630000, reward_before: 12.5, reward_after: 6.25 },
      { date: '2024-04-20', block: 840000, reward_before: 6.25, reward_after: 3.125 },
      { date: '2028-04-20', block: 1050000, reward_before: 3.125, reward_after: 1.5625, estimated: true }
    ];

    // ----------- Fetch historique BTC fiable (sans mock) -----------
    async function fetchBitcoinHistoricalData() {
      console.log('üèõÔ∏è Tentative de r√©cup√©ration historique Bitcoin...');
      
      // 1) FRED via Proxy Backend (r√©sout les probl√®mes CORS)
      try {
        console.log('üèõÔ∏è R√©cup√©ration historique Bitcoin depuis FRED via proxy...');
        const proxyUrl = '/proxy/fred/bitcoin?start_date=2014-01-01';
        const r = await fetch(proxyUrl);
        if (!r.ok) throw new Error(`Proxy HTTP ${r.status}: ${r.statusText}`);
        const result = await r.json();
        
        if (result.success && result.data && result.data.length > 0) {
          console.log(`‚úÖ FRED Proxy: ${result.data.length} points r√©cup√©r√©s (premi√®re: $${result.data[0].price}, derni√®re: $${result.data[result.data.length-1].price})`);
          console.log(`üìä Total disponible: ${result.raw_count} observations`);
          
          // V√©rifier que les donn√©es commencent bien en 2014
          const firstDate = new Date(result.data[0].time);
          if (firstDate.getFullYear() <= 2014) {
            console.log(`üéØ HISTORIQUE COMPLET: Donn√©es depuis ${firstDate.getFullYear()}!`);
          }
          
          return { 
            data: result.data.map(point => ({ time: point.time, price: point.price })), 
            source: result.source 
          };
        } else {
          console.warn('‚ö†Ô∏è FRED Proxy: Aucune donn√©e ou erreur -', result.error);
        }
      } catch (e) {
        console.warn('‚ùå FRED Proxy √©chou√©, passage √† Binance:', e.message);
      }

      // 2) Binance Klines (BTCUSDT) ‚Äî 2017+, sans cl√©, pagin√©
      try {
        console.log('üü° R√©cup√©ration historique Bitcoin depuis Binance API...');
        const ONE_DAY = 24 * 60 * 60 * 1000;
        const LIMIT = 1000;
        const out = [];
        let start = Date.UTC(2017, 6, 1); // 1er juillet 2017
        const end = Date.now();
        let requestCount = 0;
        
        while (start < end) {
          const next = Math.min(start + ONE_DAY * (LIMIT - 1), end);
          const u = new URL('https://api.binance.com/api/v3/klines');
          u.searchParams.set('symbol', 'BTCUSDT');
          u.searchParams.set('interval', '1d');
          u.searchParams.set('startTime', String(start));
          u.searchParams.set('endTime', String(next));
          u.searchParams.set('limit', String(LIMIT));
          const r = await fetch(u.toString());
          if (!r.ok) throw new Error(`Binance HTTP ${r.status}: ${r.statusText}`);
          const rows = await r.json();
          if (!Array.isArray(rows) || rows.length === 0) break;
          for (const k of rows) {
            const openTime = k[0];           // ms
            const close = parseFloat(k[4]);  // close
            if (Number.isFinite(close)) out.push({ time: openTime, price: close });
          }
          start = rows[rows.length - 1][0] + ONE_DAY;
          requestCount++;
          await new Promise(res => setTimeout(res, 120)); // √©viter rate limit
        }
        if (out.length > 0) {
          console.log(`‚úÖ Binance: ${out.length} points r√©cup√©r√©s en ${requestCount} requ√™tes (${out[0].price}$ √† ${out[out.length-1].price}$)`);
          return { data: out, source: 'Binance BTCUSDT (1d close)' };
        } else {
          console.warn('‚ö†Ô∏è Binance: Aucune donn√©e r√©cup√©r√©e');
        }
      } catch (e) {
        console.error('‚ùå Binance fetch √©chou√©:', e.message);
      }

      // 3) CoinGecko 365 jours (si on veut au moins la derni√®re ann√©e)
      try {
        console.log('ü¶é R√©cup√©ration historique Bitcoin depuis CoinGecko API (365j)...');
        const r = await fetch('https://api.coingecko.com/api/v3/coins/bitcoin/market_chart?vs_currency=usd&days=365&interval=daily');
        if (!r.ok) throw new Error(`CoinGecko HTTP ${r.status}: ${r.statusText}`);
        const j = await r.json();
        if (Array.isArray(j.prices)) {
          const data = j.prices.map(([t, p]) => ({ time: t, price: p }));
          if (data.length > 0) {
            console.log(`‚úÖ CoinGecko: ${data.length} points r√©cup√©r√©s (${data[0].price.toFixed(0)}$ √† ${data[data.length-1].price.toFixed(0)}$)`);
            return { data, source: 'CoinGecko (365j)' };
          } else {
            console.warn('‚ö†Ô∏è CoinGecko: Aucune donn√©e dans la r√©ponse');
          }
        } else {
          console.warn('‚ö†Ô∏è CoinGecko: Format de r√©ponse inattendu');
        }
      } catch (e) {
        console.error('‚ùå CoinGecko fetch √©chou√©:', e.message);
      }

      // 4) Rien trouv√© ‚Üí renvoyer vide (pas de courbe prix)
      console.warn('‚ùå Aucune source d\'historique Bitcoin disponible');
      return { data: [], source: 'Aucune (toutes les APIs ont √©chou√©)' };
    }

    // Create Bitcoin cycle chart
    async function createBitcoinCycleChart(canvasId) {
      const canvas = document.getElementById(canvasId);
      if (!canvas) {
        console.error('Canvas not found:', canvasId);
        return null;
      }

      // Destroy existing chart if it exists
      if (window.bitcoinCycleChart) {
        console.log('üîÑ Destroying existing Bitcoin chart...');
        window.bitcoinCycleChart.destroy();
        window.bitcoinCycleChart = null;
      }

      // Also check if Chart.js has any existing chart on this canvas
      const existingChart = Chart.getChart(canvas);
      if (existingChart) {
        console.log('üîÑ Destroying Chart.js existing chart on canvas...');
        existingChart.destroy();
      }

      try {
        // Fetch historical data
        const { data: historicalData, source } = await fetchBitcoinHistoricalData();

        // Get current cycle state
        const state = store.snapshot();
        const cycleData = state.cycle;

        // Prepare chart data (Bitcoin price - transparent background)
        const priceData = historicalData.map(point => ({
          x: point.time,
          y: point.price
        }));

        // Import cycle navigator functions (m√™me URL que partout)
        const { cycleScoreFromMonths, getCyclePhase } = await import('./modules/cycle-navigator.js');

        // üéØ CALIBRATION HISTORIQUE AUTOMATIQUE
        try {
          const { calibrateCycleParams } = await import('./modules/cycle-navigator.js');
          const calibRes = calibrateCycleParams();
          console.log('üéØ Calibration historique automatique:', calibRes);
        } catch (e) {
          console.warn('‚ö†Ô∏è Calibration automatique √©chou√©e:', e.message);
        }

        // Calculate cycle score for each data point
        const cycleScoreData = historicalData.map(point => {
          const date = new Date(point.time);

          // Find which cycle period this date falls into
          let monthsAfterHalving = 0;
          for (let i = BITCOIN_HALVINGS.length - 1; i >= 0; i--) {
            const halving = BITCOIN_HALVINGS[i];
            const halvingDate = new Date(halving.date);

            if (date >= halvingDate && !halving.estimated) {
              const diffTime = date.getTime() - halvingDate.getTime();
              monthsAfterHalving = diffTime / (1000 * 60 * 60 * 24 * 30.44); // Convert to months
              break;
            }
          }

          // Calculate cycle score using the existing function
          const cycleScore = cycleScoreFromMonths(monthsAfterHalving);

          return {
            x: point.time,
            y: cycleScore
          };
        });

        // Current position marker
        const currentTimestamp = Date.now();
        const currentPrice = priceData[priceData.length - 1]?.y || 108000; // Prix actuel ~$108k

        console.log('üìä Bitcoin price data loaded:', {
          dataPoints: priceData.length,
          latestPrice: currentPrice,
          dataSource: priceData.length > 100 ? 'CoinGecko API' : 'Fallback mock data'
        });

        // Chart configuration
        const config = {
          type: 'line',
          data: {
            datasets: [
              {
                label: 'Bitcoin Price (USD)',
                data: priceData,
                borderColor: 'rgba(247, 147, 26, 0.15)', // Bitcoin orange tr√®s transparent (arri√®re-plan)
                backgroundColor: 'rgba(247, 147, 26, 0.02)',
                borderWidth: 1,
                fill: false,
                yAxisID: 'y',
                pointRadius: 0, // Pas de points visibles
                pointHoverRadius: 3,
                order: 2 // Afficher en arri√®re-plan
              },
              {
                label: 'Cycle Score',
                data: cycleScoreData,
                borderColor: '#10b981', // Green - ligne principale visible
                backgroundColor: 'rgba(16, 185, 129, 0.1)',
                borderWidth: 3, // Plus √©paisse pour √™tre la ligne principale
                fill: false,
                yAxisID: 'y1',
                pointRadius: 0,
                pointHoverRadius: 4,
                order: 1 // Afficher au premier plan
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            layout: {
              padding: {
                bottom: 80  // Reserve space for timeline
              }
            },
            interaction: {
              intersect: false,
              mode: 'index'
            },
            plugins: {
              title: {
                display: true,
                text: 'Bitcoin Cycle Analysis - Historical Price & Position',
                font: { size: 16 }
              },
              legend: {
                display: true,
                position: 'top'
              },
              tooltip: {
                callbacks: {
                  title: function (context) {
                    const date = new Date(context[0].parsed.x);
                    return date.toLocaleDateString('fr-FR');
                  },
                  label: function (context) {
                    const dataset = context.dataset;
                    const value = context.parsed.y;

                    if (dataset.label.includes('Price')) {
                      return `Prix: $${value.toLocaleString()}`;
                    } else {
                      return `Cycle Score: ${Math.round(value)}/100`;
                    }
                  }
                }
              }
            },
            scales: {
              x: {
                type: 'time',
                time: {
                  unit: 'year',
                  displayFormats: {
                    year: 'yyyy'
                  }
                },
                title: {
                  display: true,
                  text: 'Date'
                },
                max: new Date(Date.now() + (30 * 24 * 60 * 60 * 1000)) // Add 30 days padding to the right
              },
              y: {
                type: 'logarithmic',
                position: 'left',
                title: {
                  display: true,
                  text: 'Prix Bitcoin (USD, √©chelle log)'
                },
                ticks: {
                  callback: function (value) {
                    return '$' + value.toLocaleString();
                  }
                }
              },
              y1: {
                type: 'linear',
                position: 'right',
                min: 0,
                max: 100,
                title: {
                  display: true,
                  text: 'Score de Cycle (0-100)'
                },
                grid: {
                  drawOnChartArea: false
                }
              }
            }
          },
          plugins: [{
            id: 'halvingLines',
            afterDraw: function (chart) {
              const ctx = chart.ctx;
              const xAxis = chart.scales.x;
              const yAxis = chart.scales.y;

              // Draw halving vertical lines
              BITCOIN_HALVINGS.forEach((halving, index) => {
                if (halving.estimated) return; // Skip estimated future halving

                const halvingDate = new Date(halving.date);
                const x = xAxis.getPixelForValue(halvingDate.getTime());

                if (x >= xAxis.left && x <= xAxis.right) {
                  ctx.save();
                  ctx.strokeStyle = '#8b5cf6'; // Purple color
                  ctx.lineWidth = 2;
                  ctx.setLineDash([5, 5]);

                  ctx.beginPath();
                  ctx.moveTo(x, yAxis.top + 10);
                  ctx.lineTo(x, yAxis.bottom);
                  ctx.stroke();

                  // Label
                  ctx.fillStyle = '#8b5cf6';
                  ctx.font = '12px sans-serif';
                  ctx.textAlign = 'center';
                  ctx.fillText(
                    `Halving ${index + 1}`,
                    x,
                    yAxis.top + 10
                  );
                  ctx.restore();
                }
              });

              // Historical cycle highs data
              const CYCLE_INTERVALS = [
                {
                  halving: { date: '2012-11-28', name: 'Halving 1' },
                  peak: { date: '2013-11-30', name: 'ATH Cycle 1' },
                  cycle: 1
                },
                {
                  halving: { date: '2016-07-09', name: 'Halving 2' },
                  peak: { date: '2017-12-17', name: 'ATH Cycle 2' },
                  cycle: 2
                },
                {
                  halving: { date: '2020-05-11', name: 'Halving 3' },
                  peak: { date: '2021-11-10', name: 'ATH Cycle 3' },
                  cycle: 3
                },
                {
                  halving: { date: '2024-04-20', name: 'Halving 4' },
                  peak: { date: new Date().toISOString().split('T')[0], name: 'Aujourd\'hui' },
                  cycle: 4,
                  isCurrent: true
                }
              ];


              // Calculate days until next halving
              const nextHalving = BITCOIN_HALVINGS.find(h => h.estimated);
              const daysUntilHalving = nextHalving ?
                Math.ceil((new Date(nextHalving.date).getTime() - currentTimestamp) / (1000 * 60 * 60 * 24)) :
                null;

              // Draw timeline bar at bottom
              const timelineY = yAxis.bottom + 40;
              const timelineHeight = 50;

              // Draw background bar
              ctx.save();
              ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
              ctx.fillRect(xAxis.left, timelineY, xAxis.right - xAxis.left, timelineHeight);
              ctx.restore();

              // Draw historical cycle intervals (1, 2, 3)
              CYCLE_INTERVALS.filter(interval => !interval.isCurrent).forEach((interval) => {
                const halvingDate = new Date(interval.halving.date);
                const peakDate = new Date(interval.peak.date);

                const halvingX = xAxis.getPixelForValue(halvingDate.getTime());
                const peakX = xAxis.getPixelForValue(peakDate.getTime());

                if (halvingX >= xAxis.left && peakX <= xAxis.right) {
                  const daysDiff = Math.ceil((peakDate.getTime() - halvingDate.getTime()) / (1000 * 60 * 60 * 24));

                  ctx.save();

                  // Draw arrow line
                  const arrowY = timelineY + timelineHeight / 2;
                  ctx.strokeStyle = `hsl(${120 + interval.cycle * 60}, 70%, 50%)`;
                  ctx.lineWidth = 3;

                  ctx.beginPath();
                  ctx.moveTo(halvingX, arrowY);
                  ctx.lineTo(peakX, arrowY);
                  ctx.stroke();

                  // Draw arrow head
                  const arrowSize = 8;
                  ctx.fillStyle = ctx.strokeStyle;
                  ctx.beginPath();
                  ctx.moveTo(peakX, arrowY);
                  ctx.lineTo(peakX - arrowSize, arrowY - arrowSize / 2);
                  ctx.lineTo(peakX - arrowSize, arrowY + arrowSize / 2);
                  ctx.closePath();
                  ctx.fill();

                  // Draw start point (halving)
                  ctx.fillStyle = '#8b5cf6';
                  ctx.beginPath();
                  ctx.arc(halvingX, arrowY, 4, 0, 2 * Math.PI);
                  ctx.fill();

                  // Draw end point (peak)  
                  ctx.fillStyle = '#f59e0b';
                  ctx.beginPath();
                  ctx.arc(peakX, arrowY, 4, 0, 2 * Math.PI);
                  ctx.fill();

                  // Add days label in the middle
                  const midX = (halvingX + peakX) / 2;
                  ctx.fillStyle = '#6b7280';
                  ctx.font = 'bold 11px sans-serif';
                  ctx.textAlign = 'center';
                  ctx.fillText(
                    `${daysDiff} jours`,
                    midX,
                    arrowY - 8
                  );

                  // Add cycle label below
                  ctx.font = '9px sans-serif';
                  ctx.fillStyle = '#6b7280';
                  ctx.fillText(
                    `Cycle ${interval.cycle}`,
                    midX,
                    arrowY + 15
                  );

                  ctx.restore();
                }
              });

              // Draw current cycle (4) from last halving to current position
              const currentCycle = CYCLE_INTERVALS.find(interval => interval.isCurrent);
              if (currentCycle) {
                const halvingDate = new Date(currentCycle.halving.date);
                const halvingX = xAxis.getPixelForValue(halvingDate.getTime());
                const currentX_timeline = xAxis.getPixelForValue(currentTimestamp);

                if (halvingX >= xAxis.left && currentX_timeline <= xAxis.right + 10) {
                  const daysSinceHalving = Math.ceil((currentTimestamp - halvingDate.getTime()) / (1000 * 60 * 60 * 24));

                  ctx.save();

                  // Draw current cycle arrow (same style as other cycles)
                  const arrowY = timelineY + timelineHeight / 2;
                  ctx.strokeStyle = `hsl(${120 + 4 * 60}, 70%, 50%)`; // Same color pattern as other cycles
                  ctx.lineWidth = 3; // Same width as other cycles

                  ctx.beginPath();
                  ctx.moveTo(halvingX, arrowY);
                  ctx.lineTo(currentX_timeline, arrowY);
                  ctx.stroke();

                  // Draw arrow head (same size as other cycles)
                  const arrowSize = 8;
                  ctx.fillStyle = ctx.strokeStyle;
                  ctx.beginPath();
                  ctx.moveTo(currentX_timeline, arrowY);
                  ctx.lineTo(currentX_timeline - arrowSize, arrowY - arrowSize / 2);
                  ctx.lineTo(currentX_timeline - arrowSize, arrowY + arrowSize / 2);
                  ctx.closePath();
                  ctx.fill();

                  // Draw start point (halving 4)
                  ctx.fillStyle = '#8b5cf6';
                  ctx.beginPath();
                  ctx.arc(halvingX, arrowY, 4, 0, 2 * Math.PI);
                  ctx.fill();

                  // Draw end point (current position)  
                  ctx.fillStyle = '#f59e0b';
                  ctx.beginPath();
                  ctx.arc(currentX_timeline, arrowY, 4, 0, 2 * Math.PI);
                  ctx.fill();

                  // Add days label in the middle (same style as other cycles)
                  const midX = (halvingX + currentX_timeline) / 2;
                  ctx.fillStyle = '#6b7280';
                  ctx.font = 'bold 11px sans-serif';
                  ctx.textAlign = 'center';
                  ctx.fillText(
                    `${daysSinceHalving} jours (en cours)`,
                    midX,
                    arrowY - 8
                  );

                  // Add cycle label below
                  ctx.font = '9px sans-serif';
                  ctx.fillStyle = '#6b7280';
                  ctx.fillText(
                    'Cycle 4 (actuel)',
                    midX,
                    arrowY + 15
                  );

                  ctx.restore();
                }
              }

              // Draw current position line - ALWAYS show it
              const currentX = xAxis.getPixelForValue(currentTimestamp);

              if (currentX >= xAxis.left && currentX <= xAxis.right) {
                ctx.save();
                ctx.strokeStyle = '#ef4444'; // Red color for current position
                ctx.lineWidth = 2;

                ctx.beginPath();
                ctx.moveTo(currentX, yAxis.top);
                ctx.lineTo(currentX, yAxis.bottom);
                ctx.stroke();

                // Current position label
                ctx.fillStyle = '#ef4444';
                ctx.font = 'bold 12px sans-serif';
                ctx.textAlign = 'center';

                // Add current date info
                ctx.font = '10px sans-serif';
                const currentDateStr = new Date(currentTimestamp).toLocaleDateString('fr-FR');
                ctx.fillText(
                  currentDateStr,
                  currentX,
                  yAxis.top - 25
                );

                ctx.restore();
              }
            }
          }]
        };

        // Create chart
        window.bitcoinCycleChart = new Chart(canvas, config);
        console.log('‚úÖ Bitcoin cycle chart created successfully');

        return window.bitcoinCycleChart;

      } catch (error) {
        console.error('‚ùå Failed to create Bitcoin cycle chart:', error);

        // Show error message in canvas container
        const container = canvas.parentElement;
        container.innerHTML = `
          <div style="text-align: center; padding: 2rem; color: var(--theme-text-muted);">
            <div style="font-size: 1.2rem; margin-bottom: 1rem;">‚ö†Ô∏è Impossible de charger le graphique des cycles</div>
            <div style="font-size: 0.9rem;">Erreur: ${error.message}</div>
            <div style="font-size: 0.8rem; margin-top: 0.5rem;">Essayez de rafra√Æchir la page ou v√©rifiez votre connexion.</div>
          </div>
        `;

        return null;
      }
    }

    // ====== Cycles Content ======
    async function renderCyclesContent() {
      const container = document.getElementById('cycles-content');
      const state = store.snapshot();
      const ccsData = state.ccs;
      const cycleData = state.cycle;

      if (!ccsData?.score || !cycleData?.months) {
        container.innerHTML = '<div class="loading">Loading cycle data...</div>';
        return;
      }

      const blended = cycleData.ccsStar || ccsData.score;
      const interpretation = interpretCCS(blended);

      container.innerHTML = `
        <!-- Bitcoin Cycle Chart -->
        <div class="risk-card" style="margin-bottom: 2rem;">
          <h3>üìà Graphique des Cycles Bitcoin</h3>
          <!-- Label de source inject√© dynamiquement -->
          <div id="btc-source-label" style="margin-left:auto;color:var(--theme-text-muted);font-size:12px;"></div>
          <div style="height: 520px; position: relative; margin: 1rem 0;">
            <canvas id="bitcoin-cycle-chart" style="width: 100%; height: 100%;"></canvas>
          </div>
          <div style="font-size: 0.85rem; color: var(--theme-text-muted); text-align: center; margin-top: 1rem;">
            <div><strong>L√©gende:</strong></div>
            <div style="margin-top: 0.5rem;">
              <span style="color: #8b5cf6; font-weight: 600;">‚Äî ‚Äî ‚Äî</span> Halvings Bitcoin
              &nbsp;&nbsp;|&nbsp;&nbsp;
              <span style="color: #ef4444; font-weight: 600;">‚Äî‚Äî</span> Position actuelle
              &nbsp;&nbsp;|&nbsp;&nbsp;
              <span style="color: #f7931a; font-weight: 600;">‚Äî‚Äî</span> Prix Bitcoin
              &nbsp;&nbsp;|&nbsp;&nbsp;
              <span style="color: #10b981; font-weight: 600;">‚Äî‚Äî</span> Score de cycle
            </div>
          </div>
        </div>

        <div class="risk-grid">
          <!-- CCS Overview -->
          <div class="risk-card">
            <h3>üìä CCS Market Score</h3>
            <div style="text-align: center; margin: var(--space-lg) 0;">
              <div style="font-size: 3rem; font-weight: 700; color: ${interpretation.color};">
                ${Math.round(ccsData.score)}
              </div>
              <div style="font-size: 1rem; color: var(--theme-text-muted);">
                ${interpretation.label}
              </div>
            </div>
            
            <div class="metric-row">
              <span class="metric-label">Model Version:</span>
              <span class="metric-value">${ccsData.model_version}</span>
            </div>
            <div class="metric-row">
              <span class="metric-label">Last Update:</span>
              <span class="metric-value">${new Date(ccsData.lastUpdate).toLocaleTimeString()}</span>
            </div>
          </div>
          
          <!-- Cycle Position -->
          <div class="risk-card">
            <h3>üîÑ Position dans le Cycle</h3>
            <div style="text-align: center; margin: var(--space-lg) 0;">
              <div style="font-size: 2rem;">
                ${cycleData.phase?.emoji || '‚ö´'} 
              </div>
              <div style="font-size: 1rem; font-weight: 600; color: ${cycleData.phase?.color || '#6b7280'};">
                ${cycleData.phase?.phase?.replace('_', ' ').toUpperCase() || 'UNKNOWN'}
              </div>
              <div style="font-size: 0.875rem; color: var(--theme-text-muted);">
                Mois ${Math.round(cycleData.months)} post-halving
              </div>
              <div style="font-size: 0.8rem; color: var(--theme-text-muted); margin-top: 0.5rem;">
                (Dernier halving: 20 avril 2024)
              </div>
            </div>
            
            <div class="metric-row">
              <span class="metric-label">Cycle Score:</span>
              <span class="metric-value">${Math.round(cycleData.score)}/100</span>
            </div>
            <div class="metric-row">
              <span class="metric-label">Confidence:</span>
              <span class="metric-value">${Math.round(cycleData.confidence * 100)}%</span>
            </div>
          </div>
          
          <!-- Blended Analysis -->
          <div class="risk-card">
            <h3>‚öñÔ∏è Strat√©gie Hybride</h3>
            <div class="metric-row">
              <span class="metric-label">CCS Original:</span>
              <span class="metric-value">${Math.round(ccsData.score)}</span>
            </div>
            <div class="metric-row">
              <span class="metric-label">Poids Cycle:</span>
              <span class="metric-value">${Math.round((cycleData.weight || 0.3) * 100)}%</span>
            </div>
            <div class="metric-row">
              <span class="metric-label">CCS Mixte*:</span>
              <span class="metric-value" style="color: ${interpretation.color}; font-weight: 700;">
                ${Math.round(blended)}
              </span>
            </div>
            <div class="metric-row">
              <span class="metric-label">Strat√©gie:</span>
              <span class="metric-value">${interpretation.label}</span>
            </div>
          </div>
        </div>
        
        <!-- Cycle Multipliers -->
        <div class="risk-card">
          <h3>üéØ Multiplicateurs par Classe d'Actifs</h3>
          <div style="font-size: 0.875rem; color: var(--theme-text-muted); margin-bottom: var(--space-sm);">
            Bas√© sur la phase de cycle actuelle: <strong>${cycleData.phase?.phase?.replace('_', ' ')}</strong>
          </div>
          <div class="risk-grid">
            ${Object.entries(cycleData.multipliers || {}).map(([asset, multiplier]) => {
        const color = multiplier > 1.1 ? 'var(--success)' :
          multiplier < 0.9 ? 'var(--danger)' : 'var(--theme-text)';
        const recommendation = multiplier > 1.1 ? 'Surpond√©rer' :
          multiplier < 0.9 ? 'Sous-pond√©rer' : 'Neutre';
        return `
                <div class="metric-row">
                  <span class="metric-label">${asset}:</span>
                  <span class="metric-value" style="color: ${color};">
                    ${multiplier.toFixed(2)}x <span style="font-size: 0.7rem; opacity: 0.8;">(${recommendation})</span>
                  </span>
                </div>
              `;
      }).join('')}
          </div>
          <div style="font-size: 0.8rem; color: var(--theme-text-muted); margin-top: 1rem; padding: 0.75rem; background: var(--theme-bg); border-radius: 6px;">
            üí° Les multiplicateurs indiquent l'allocation recommand√©e par rapport aux targets de base selon la phase de cycle.
          </div>
        </div>
      `;

      // Create Bitcoin cycle chart after DOM is ready
      setTimeout(async () => {
        // Prevent multiple concurrent chart creations
        if (window.bitcoinChartCreating) {
          console.log('‚ö†Ô∏è Bitcoin chart creation already in progress, skipping...');
          return;
        }

        window.bitcoinChartCreating = true;
        try {
          await createBitcoinCycleChart('bitcoin-cycle-chart');
        } finally {
          window.bitcoinChartCreating = false;
        }
      }, 100);
    }

    // ====== Portfolio Allocation Helper ======
    async function getCurrentPortfolioAllocation() {
      let realBalances = [];

      try {
        // Utiliser la source de donn√©es configur√©e
        console.log('üîç Loading portfolio allocation using configured source...');
        const balanceResult = await window.loadBalanceData();

        if (!balanceResult.success) {
          throw new Error(balanceResult.error);
        }

        let balances;

        if (balanceResult.csvText) {
          // Source CSV locale
          balances = window.parseCSVBalances(balanceResult.csvText);
        } else if (balanceResult.data && balanceResult.data.items) {
          // Source API (stub ou cointracking_api)
          balances = balanceResult.data.items.map(item => ({
            symbol: item.symbol,
            balance: item.balance,
            value_usd: item.value_usd
          }));
        } else {
          throw new Error('Invalid data format received');
        }

        realBalances = balances.map(item => ({
          symbol: item.symbol,
          value_usd: item.value_usd
        }));
        console.log('üîç DEBUG getCurrentPortfolioAllocation: Using real CSV data -', realBalances.length, 'assets, total:', realBalances.reduce((s, i) => s + i.value_usd, 0).toFixed(2), '$');

      } catch (error) {
        console.error('CRITICAL: Could not load CSV data in getCurrentPortfolioAllocation:', error);
        throw error; // Don't fallback - fail properly so we know there's an issue
      }

      const totalValue = realBalances.reduce((sum, item) => sum + item.value_usd, 0);

      // Use the same ASSET_GROUPS classification as dashboard.html for consistency
      const classification = ASSET_GROUPS;

      // Initialize allocation object with all ASSET_GROUPS categories
      const allocation = {};
      Object.keys(ASSET_GROUPS).forEach(category => {
        allocation[category] = 0;
      });
      allocation.model_version = 'portfolio-actuel';

      // Classifier chaque asset using the same logic as dashboard.html
      realBalances.forEach(item => {
        const symbol = item.symbol.toUpperCase();
        let foundGroup = null;

        // Find which group this asset belongs to
        for (const [groupName, aliases] of Object.entries(classification)) {
          if (aliases.includes(symbol)) {
            foundGroup = groupName;
            break;
          }
        }

        // Add to appropriate group or Others
        const targetGroup = foundGroup || 'Others';
        allocation[targetGroup] += (item.value_usd / totalValue) * 100;
      });

      return allocation;
    }

    // ====== Targets Content ======
    async function renderTargetsContent() {
      const container = document.getElementById('targets-content');
      const state = store.snapshot();

      // Propose different targeting strategies
      const macroProposal = proposeTargets('macro');
      const ccsProposal = proposeTargets('ccs');
      const cycleProposal = proposeTargets('cycle');
      const blendedProposal = proposeTargets('blend');

      // DEBUG: Log what blended proposal contains for display
      console.log('üîç DEBUG renderTargetsContent - blendedProposal for DISPLAY:', blendedProposal);
      console.log('üîç DEBUG renderTargetsContent - BTC allocation for DISPLAY:', blendedProposal.targets.BTC);

      // Current targets from store or use blended as default display
      const appliedTargets = state.targets?.proposed || blendedProposal.targets;
      const appliedStrategy = state.targets?.strategy || blendedProposal.strategy;

      // Get real current portfolio allocation
      const currentAllocation = await getCurrentPortfolioAllocation();

      container.innerHTML = `
        <div class="risk-grid">
          <!-- Strategy Selection -->
          <div class="risk-card" style="grid-column: 1 / -1;">
            <h3>üéØ Strategic Targeting</h3>
            <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: var(--space-sm); margin: var(--space-lg) 0;">
              <button class="refresh-btn" onclick="applyStrategy('macro')" style="background: #6b7280;">
                üìä Macro Only<br>
                <small>${macroProposal.strategy}</small>
              </button>
              <button class="refresh-btn" onclick="applyStrategy('ccs')" style="background: #3b82f6;">
                üìà CCS Based<br>
                <small>${ccsProposal.strategy}</small>
              </button>
              <button class="refresh-btn" onclick="applyStrategy('cycle')" style="background: #f59e0b;">
                üîÑ Cycle Adjusted<br>
                <small>${cycleProposal.strategy}</small>
              </button>
              <button class="refresh-btn" onclick="applyStrategy('blend')" style="background: #10b981;">
                ‚öñÔ∏è Blended Strategy<br>
                <small>${blendedProposal.strategy}</small>
              </button>
            </div>
          </div>
          
          <!-- Current vs Proposed -->
          <div class="risk-card">
            <h3>üìã Current Allocation</h3>
            ${renderTargetsTable(currentAllocation, 'Portfolio Actuel')}
          </div>
          
          <div class="risk-card">
            <h3>üéØ Proposed Targets</h3>
            ${renderTargetsTable(appliedTargets, appliedStrategy)}
            <div style="margin-top: var(--space-lg); text-align: center; padding: var(--space-sm); background: var(--info-bg); border-radius: var(--radius-md); border: 1px solid var(--info);">
              <div style="font-size: 0.875rem; color: var(--info); font-weight: 600; margin-bottom: var(--space-xs);">
                üí° Nouvelle m√©thode d'application
              </div>
              <div style="font-size: 0.75rem; color: var(--theme-text-muted);">
                Les targets sont maintenant synchronis√©s via <strong>rebalance.html</strong><br>
                Utilisez le bouton "üéØ Sync CCS" dans les strat√©gies pr√©d√©finies
              </div>
            </div>
          </div>
        </div>
        
        <!-- Action Plan -->
        ${renderActionPlan(currentAllocation, appliedTargets)}
        
        <!-- Decision History -->
        ${renderDecisionHistory()}
      `;
    }

    function renderTargetsTable(targets, strategy) {
      const { model_version, ...allocations } = targets;

      return `
        <div style="font-size: 0.75rem; color: var(--theme-text-muted); margin-bottom: var(--space-sm);">
          ${strategy} (${model_version})
        </div>
        <div class="risk-grid">
          ${Object.entries(allocations)
          .sort(([, a], [, b]) => b - a)
          .map(([asset, allocation]) => `
              <div class="metric-row">
                <span class="metric-label">${asset}:</span>
                <span class="metric-value">${allocation.toFixed(1)}%</span>
              </div>
            `).join('')}
        </div>
      `;
    }

    function renderActionPlan(current, proposed) {
      if (!current || !proposed) return '';

      try {
        const plan = computePlan(current, proposed);

        if (plan.actions.length === 0) {
          return `
            <div class="risk-card">
              <h3>üìù Action Plan</h3>
              <p style="text-align: center; color: var(--success);">‚úÖ No changes needed - targets already optimal</p>
            </div>
          `;
        }

        return `
          <div class="risk-card">
            <h3>üìù Action Plan</h3>
            <div style="font-size: 0.875rem; color: var(--theme-text-muted); margin-bottom: var(--space-lg);">
              ${plan.num_changes} changes needed ‚Ä¢ ${plan.total_reallocation.toFixed(1)}% to reallocate ‚Ä¢ Complexity: ${plan.complexity}
            </div>
            <div class="risk-grid">
              ${plan.actions.map(action => {
          const color = action.action === 'buy' ? 'var(--success)' : 'var(--danger)';
          const icon = action.action === 'buy' ? 'üìà' : 'üìâ';
          return `
                  <div class="metric-row">
                    <span class="metric-label">${icon} ${action.asset}:</span>
                    <span class="metric-value" style="color: ${color};">
                      ${action.current_pct.toFixed(1)}% ‚Üí ${action.target_pct.toFixed(1)}%
                      <span style="font-size: 0.75rem;">(${action.change_pct > 0 ? '+' : ''}${action.change_pct.toFixed(1)}%)</span>
                    </span>
                  </div>
                `;
        }).join('')}
            </div>
          </div>
        `;

      } catch (error) {
        return `
          <div class="risk-card">
            <h3>üìù Action Plan</h3>
            <div class="error">Error computing plan: ${error.message}</div>
          </div>
        `;
      }
    }

    function renderDecisionHistory() {
      const history = getDecisionLog(5);

      if (history.length === 0) {
        return `
          <div class="risk-card">
            <h3>üìö Decision History</h3>
            <p style="text-align: center; color: var(--theme-text-muted);">No previous decisions</p>
          </div>
        `;
      }

      return `
        <div class="risk-card">
          <h3>üìö Decision History</h3>
          <div style="font-size: 0.75rem; color: var(--theme-text-muted); margin-bottom: var(--space-sm);">
            Last ${history.length} decisions
          </div>
          ${history.map(entry => `
            <div class="metric-row" style="border-bottom: 1px solid var(--theme-border); padding: var(--space-sm) 0;">
              <div>
                <div style="font-weight: 500;">${entry.strategy}</div>
                <div style="font-size: 0.75rem; opacity: 0.7;">
                  ${new Date(entry.timestamp).toLocaleString()} ‚Ä¢ 
                  CCS: ${Math.round(entry.ccs_score || 0)} ‚Ä¢ 
                  Confidence: ${Math.round((entry.confidence || 0) * 100)}%
                </div>
              </div>
            </div>
          `).join('')}
        </div>
      `;
    }

    function renderError(message) {
      document.getElementById('risk-dashboard-content').innerHTML = `
        <div class="error">
          <h3>‚ùå Error Loading Dashboard</h3>
          <p>${message}</p>
          <button class="refresh-btn" onclick="refreshDashboard()">Try Again</button>
        </div>
      `;
    }

    function updateTimestamp(ts, calcTime) {
      const d = new Date(ts);
      document.getElementById('last-update').textContent = `Last updated: ${d.toLocaleString()} (${calcTime})`;
    }

    function enableAutoRefresh() {
      const btn = document.getElementById('auto-refresh-btn');
      if (autoRefreshInterval) {
        clearInterval(autoRefreshInterval); autoRefreshInterval = null;
        btn.textContent = '‚è±Ô∏è Enable Auto-Refresh (30s)'; btn.style.background = '';
      } else {
        autoRefreshInterval = setInterval(refreshDashboard, 30000);
        btn.textContent = '‚èπÔ∏è Disable Auto-Refresh'; btn.style.background = '#28a745';
      }
    }

    // Test endpoint (identique √† ta version)
    async function testEndpoint() {
      try {
        const r = await fetch('http://localhost:8000/api/risk/dashboard?source=cointracking&pricing=local&min_usd=1.00');
        const t = await r.text();
        try { JSON.parse(t); alert('API Response received. Check console for details.'); }
        catch { alert('API returned non-JSON response: ' + t.substring(0, 200)); }
      } catch (e) { alert('API test failed: ' + e.message); }
    }

    // ===== D√©coration des tooltips apr√®s rendu =====
    function decorateRiskTooltips() {
      // === Attache dynamique pour les m√©triques ===
      document.querySelectorAll('.hinted[data-key]').forEach(el => {
        const key = el.getAttribute('data-key');

        // attache une bulle "vivante" qui lit la valeur *au moment* du survol
        el.addEventListener('mouseenter', (e) => {
          // 1) essaie data-value
          let raw = el.getAttribute('data-value');

          // 2) fallback: parse le texte visible (ex: "1.23%" -> 0.0123)
          if (!raw || raw === '0') {
            const txt = (el.textContent || '').trim();
            if (txt.endsWith('%')) {
              const n = parseFloat(txt.replace('%', '').replace(',', '.'));
              raw = isFinite(n) ? String(n / 100) : '';
            } else {
              const n = parseFloat(txt.replace(',', '.'));
              raw = isFinite(n) ? String(n) : '';
            }
          }

          const val = Number(String(raw || '').replace(',', '.'));
          const rating = rate(key, isNaN(val) ? null : val);

          const title = rating.label || key;
          const fmt = (key === 'sharpe' || key === 'sortino') ? num : pct;
          const body = `Valeur actuelle : ${isNaN(val) ? 'N/A' : fmt(val)}\nLecture : ${rating.verdict}`;

          showTip(title, body, e.clientX, e.clientY);
        });

        el.addEventListener('mousemove', (e) => moveTip(e.clientX, e.clientY));
        el.addEventListener('mouseleave', hideTip);
        el.classList.add('hinted');
      });
    }

    // ====== Initialization & Store Connection ======

    // Subscribe to store changes for sidebar and content updates
    store.subscribe((state) => {
      updateSidebar(state);

      // Auto-update active tab content when data changes
      const activeTab = state.ui?.activeTab;
      if (activeTab === 'cycles' && state.ccs?.score && state.cycle?.months) {
        renderCyclesContent();
      }
      if (activeTab === 'targets') {
        renderTargetsContent().catch(err => console.error('Failed to render targets on store change:', err));
      }
    });

    // ====== Global Functions for UI Interaction ======

    // Apply specific strategy
    window.applyStrategy = async function (mode) {
      try {
        console.log('üîç DEBUG applyStrategy called with mode:', mode);
        console.log('üîç DEBUG store state before:', store.snapshot());

        const proposal = proposeTargets(mode);
        console.log('üîç DEBUG proposal result:', proposal);
        console.log('üîç DEBUG proposal BTC allocation:', proposal.targets.BTC);

        await applyTargets(proposal);

        // Refresh targets content to show updated data
        if (store.get('ui.activeTab') === 'targets') {
          renderTargetsContent().catch(err => console.error('Failed to render targets after strategy apply:', err));
        }

        // Update sidebar
        updateSidebar(store.snapshot());

        console.log(`Applied strategy: ${mode} - ${proposal.strategy}`);

      } catch (error) {
        console.error('Failed to apply strategy:', error);
        alert('Failed to apply strategy: ' + error.message);
      }
    };


    // Global functions for backwards compatibility
    window.refreshDashboard = refreshDashboard;
    window.enableAutoRefresh = enableAutoRefresh;
    window.testEndpoint = testEndpoint;

    // Initialize on DOM ready
    document.addEventListener('DOMContentLoaded', function () {
      console.log('Risk Dashboard CCS MVP initializing...');

      // Initialize shared header
      initSharedHeader('risk-dashboard');

      // Appliquer le th√®me imm√©diatement
      console.log('Initializing theme for risk-dashboard page...');
      if (window.globalConfig && window.globalConfig.applyTheme) {
        window.globalConfig.applyTheme();
      }
      if (window.applyAppearance) {
        window.applyAppearance();
      }
      console.log('Current theme after risk-dashboard init:', document.documentElement.getAttribute('data-theme'));

      // Hydrate store from localStorage
      store.hydrate();

      // Initial sidebar update
      updateSidebar(store.snapshot());

      // Load initial data
      refreshDashboard();

      // Apply blended strategy as default if no strategy is already selected
      setTimeout(() => {
        const currentStrategy = store.get('targets.strategy');
        if (!currentStrategy) {
          console.log('No strategy found, applying Blended as default...');
          applyStrategy('blend');
        }
      }, 1000);

      // √âcouter les changements de th√®me pour synchronisation cross-tab
      window.addEventListener('storage', function (e) {
        if (e.key === 'crypto_rebalancer_settings') {
          console.log('Settings changed in another tab, reapplying theme...');
          setTimeout(() => {
            if (window.globalConfig && window.globalConfig.applyTheme) {
              window.globalConfig.applyTheme();
            }
            if (window.applyAppearance) {
              window.applyAppearance();
            }
          }, 100);
        }
      });

      console.log('Risk Dashboard CCS MVP initialized');
    });
  </script>
</body>

</html>