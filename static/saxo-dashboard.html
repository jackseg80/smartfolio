<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üìà Stock Market Dashboard - SmartFolio</title>
    <link rel="stylesheet" href="css/tokens.css">
    <link rel="stylesheet" href="shared-theme.css">
    <link rel="stylesheet" href="theme-compat.css">
    <link rel="stylesheet" href="css/view-modes.css">
    <link rel="stylesheet" href="css/responsive.css">
    <link rel="stylesheet" href="css/saxo-dashboard.css">
    <script type="module" src="components/data-freshness.js"></script>
    <script type="module" src="network-state-manager.js"></script>
    <script type="module" src="core/sentry-init.js"></script>
    <script type="module" src="components/nav.js"></script>
    <script type="module" src="components/view-toggle.js"></script>
    <script type="module" src="components/domain-nav.js"></script>
    <script type="module">
    // ===== AUTH GUARD (Dec 2025) =====
    import { checkAuth } from './core/auth-guard.js';
    await checkAuth();  // V√©rifie authentification + redirect si n√©cessaire
    // =================================

    // ===== VIEW MODE MANAGER (Feb 2026) =====
    import { ViewModeManager } from './core/view-mode-manager.js';
    ViewModeManager.init();
    // ========================================

        import { initDeepLinks } from './components/deep-links.js';
        import { wealthContextBar } from './components/WealthContextBar.js';
        import { safeFetch } from './core/fetcher.js';

        // Anchors for saxo-dashboard.html
        initDeepLinks({
            'overview': 'Overview',
            'positions': 'Positions',
            'allocation': 'Allocation',
            'performance': 'Performance'
        });

        window.wealthContextBar = wealthContextBar;
        window.safeFetch = safeFetch;
    </script>
    <script src="debug-logger.js"></script>
    <script src="components/toast.js" type="module"></script>
  <script src="global-config.js"></script>
    <script src="appearance.js"></script>

    <!-- Chart.js for interactive charts -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>

    <!-- Plotly.js: Lazy loaded on demand for heatmaps/dendrograms (saves 3 MB on initial load) -->
    <!-- jsPDF and html2canvas: Lazy loaded on demand (saves 1 MB initial load) -->

    <!-- AI Chat Component (Global System) -->
    <link rel="stylesheet" href="/static/components/ai-chat.css">
    <script type="module">
        import { initAIChat } from '/static/components/ai-chat-init.js';
        initAIChat('saxo-dashboard');
    </script>
</head>

<body>
    <main role="main">
    <div class="container">
        <!-- Dashboard Header -->
        <div class="dashboard-header">
            <div style="display: flex; align-items: center; gap: 1rem;">
                <div>
                    <h1>üìà Stock Dashboard (Saxo Bank)</h1>
                    <p style="color: var(--theme-text-muted); margin: 0;">Analysis of your stock portfolio</p>
                </div>
                <span
                    id="cacheIndicator"
                    style="display: none; padding: 0.25rem 0.75rem; background: var(--success); color: white; border-radius: var(--radius-sm); font-size: 0.75rem; font-weight: 600;">
                    ‚ö° Cached
                </span>
            </div>
            <div style="display: flex; gap: 0.75rem; align-items: center;">
                <view-toggle></view-toggle>
                <button
                    id="btnForceRefresh"
                    onclick="loadCurrentSaxoData(true)"
                    style="padding: 0.75rem 1.25rem; background: var(--brand-primary); color: white; border: none; border-radius: var(--radius-md); cursor: pointer; font-size: 0.875rem; font-weight: 600; display: flex; align-items: center; gap: 0.5rem;"
                    title="Force data reload (bypass cache)">
                    üîÑ Refresh
                </button>
            </div>
        </div>

        <!-- Navigation contextuelle Bourse Domain (Feb 2026) -->
        <domain-nav domain="bourse"></domain-nav>


        <!-- Main Content (initially empty, filled by loadCurrentSaxoData) -->
        <div id="mainContent">
            <div class="loading">üìä Loading...</div>
        </div>

        <!-- Dashboard Content (hidden by default) -->
        <div id="dashboardContent" style="display: none;">
            <!-- Tabs -->
            <div class="tabs">
                <button class="tab-btn active" onclick="switchTab('overview', event)">Vue d'ensemble</button>
                <button class="tab-btn pro-only" onclick="switchTab('positions', event)">Positions</button>
            </div>

            <!-- Overview Tab -->
            <div id="overview" class="tab-content active">
                <div class="dashboard-grid">
                    <!-- Portfolio Summary -->
                    <div class="dashboard-card">
                        <div class="card-header">
                            <h2 class="card-title">Portfolio Summary</h2>
                            <div class="card-badge" id="portfolioBadge">Read-Only</div>
                        </div>
                        <div id="portfolioSummary">
                            <div class="loading">Loading...</div>
                        </div>
                    </div>

                    <!-- Asset Allocation & Currency Exposure -->
                    <div class="dashboard-card pro-only">
                        <div class="card-header">
                            <h2 class="card-title">Asset Allocation & Currency Exposure</h2>
                        </div>
                        <div id="assetAllocationCurrency">
                            <div class="loading">Loading...</div>
                        </div>
                    </div>

                    <!-- Asset Allocation Chart -->
                    <div class="dashboard-card pro-only">
                        <div class="card-header">
                            <h2 class="card-title">Allocation Breakdown</h2>
                        </div>
                        <div style="padding: 1.5rem; display: flex; justify-content: center; align-items: center;">
                            <canvas id="allocationChart" style="max-width: 350px; max-height: 350px;" role="img" aria-label="Stock portfolio allocation chart"></canvas>
                        </div>
                    </div>
                </div>

                <!-- Top Holdings -->
                <div class="dashboard-card">
                    <div class="card-header">
                        <h2 class="card-title">Top 10 Holdings</h2>
                    </div>
                    <div id="topHoldings">
                        <div class="loading">Loading...</div>
                    </div>
                </div>
            </div>

            <!-- Positions Tab -->
            <div id="positions" class="tab-content">
                <div class="dashboard-card">
                    <div class="card-header">
                        <h2 class="card-title">All Positions</h2>
                        <div class="card-badge" id="positionsCount">0 positions</div>
                    </div>
                    <div id="allPositions">
                        <div class="loading">Loading...</div>
                    </div>
                </div>
            </div>

        </div>
    </div>

    <script>
        let currentPortfolioData = null;
        let positionsSortState = {
            column: 'market_value',
            ascending: false
        };
        let currentWealthContext = {
            module: 'bourse'
        };
        let currentFileKey = null;  // Track selected Saxo file

        // Expose portfolio data to window for AI Chat context builder
        Object.defineProperty(window, 'currentPortfolioData', {
            get: () => currentPortfolioData,
            set: (val) => { currentPortfolioData = val; }
        });

        // Initialize wealth context integration
        function initWealthContextIntegration() {
            debugLogger.debug('üè¶ Initializing WealthContextBar integration for Saxo dashboard...');

            if (!window.wealthContextBar) {
                debugLogger.warn('WealthContextBar not available');
                return;
            }

            // Set initial context to bourse module only (preserve other context values)
            window.wealthContextBar.setContext(currentWealthContext);

            // Listen for context changes
            window.addEventListener('wealth:change', (event) => {
                debugLogger.debug('Wealth context changed in Saxo dashboard:', event.detail);
                currentWealthContext = { ...event.detail };

                // Update UI based on context changes
                updateContextualDisplay();
            });

            debugLogger.debug('‚úÖ WealthContextBar integrated for Saxo dashboard');
        }

        function updateContextualDisplay() {
            // Update currency display based on context
            if (currentPortfolioData && currentWealthContext.currency !== 'USD') {
                // Could implement currency conversion here
                debugLogger.debug(`Display currency preference: ${currentWealthContext.currency}`);
            }
        }

        // Refresh active tab content (called after data reload)
        function refreshActiveTab() {
            const activeTab = document.querySelector('.tab-content.active');
            if (!activeTab) return;

            const tabId = activeTab.id;
            debugLogger.debug(`üîÑ Refreshing active tab: ${tabId}`);

            // Reload data for the active tab
            if (currentPortfolioData) {
                switch (tabId) {
                    case 'overview':
                        loadOverviewData(currentPortfolioData);
                        break;
                    case 'positions':
                        loadAllPositions();
                        break;
                }
            }
        }

        // Tab switching
        function switchTab(tabName, event) {
            // Update tab buttons
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });

            // Find and activate the clicked button
            if (event && event.target) {
                event.target.classList.add('active');
            } else {
                // Fallback: find button by data attribute or text content
                const buttons = document.querySelectorAll('.tab-btn');
                buttons.forEach(btn => {
                    if (btn.getAttribute('onclick')?.includes(`'${tabName}'`)) {
                        btn.classList.add('active');
                    }
                });
            }

            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(tabName).classList.add('active');

            // Load data for specific tab if needed
            if (currentPortfolioData) {
                switch (tabName) {
                    case 'overview':
                        loadOverviewData(currentPortfolioData);
                        break;
                    case 'positions':
                        loadAllPositions();
                        break;
                }
            }
        }

        // Calculate summary metrics from normalized positions
        function calculateSummaryMetrics(positions, totalValue) {
            // Group positions by symbol to aggregate lots
            const symbolGroups = {};
            positions.forEach(pos => {
                const symbol = pos.symbol;
                if (!symbolGroups[symbol]) {
                    symbolGroups[symbol] = {
                        symbol: symbol,
                        name: pos.name || symbol,
                        asset_class: pos.asset_class || pos.asset_type || 'Unknown',
                        currency: pos.currency || 'USD',
                        isin: pos.isin || '',
                        total_quantity: 0,
                        total_value: 0
                    };
                }
                const value = pos.market_value_usd || pos.market_value || 0;
                symbolGroups[symbol].total_quantity += pos.quantity || 0;
                symbolGroups[symbol].total_value += value;
            });

            // Convert to array and calculate weights
            const aggregatedPositions = Object.values(symbolGroups).map(group => ({
                symbol: group.symbol,
                name: group.name,
                instrument: group.name,
                asset_class: group.asset_class,
                currency: group.currency,
                isin: group.isin,
                quantity: group.total_quantity,
                market_value: group.total_value,
                weight: totalValue > 0 ? (group.total_value / totalValue) * 100 : 0
            }));

            // Sort by value descending
            aggregatedPositions.sort((a, b) => b.market_value - a.market_value);

            const totalPositions = aggregatedPositions.length;

            // Calculate asset allocation (by asset_class)
            const assetTotals = {};
            aggregatedPositions.forEach(pos => {
                const assetClass = pos.asset_class;
                assetTotals[assetClass] = (assetTotals[assetClass] || 0) + pos.market_value;
            });

            const assetAllocation = {};
            Object.entries(assetTotals).forEach(([assetClass, value]) => {
                assetAllocation[assetClass] = totalValue > 0 ? (value / totalValue) * 100 : 0;
            });

            // Calculate currency exposure
            const currencyTotals = {};
            aggregatedPositions.forEach(pos => {
                const currency = pos.currency;
                currencyTotals[currency] = (currencyTotals[currency] || 0) + pos.market_value;
            });

            const currencyExposure = {};
            Object.entries(currencyTotals).forEach(([currency, value]) => {
                currencyExposure[currency] = totalValue > 0 ? (value / totalValue) * 100 : 0;
            });

            // Top 10 holdings (aggregated by symbol)
            const topHoldings = aggregatedPositions.slice(0, 10);

            return {
                total_value_usd: totalValue,
                total_positions: totalPositions,     // Unique symbols
                positions_count: positions.length,    // Total lots
                asset_allocation: assetAllocation,
                currency_exposure: currencyExposure,
                top_holdings: topHoldings
            };
        }

        // Load current Saxo data from active source (via WealthContextBar)
        // OPTIMIZATIONS:
        // 1. localStorage cache (5 min TTL) ‚Üí instant reload (~500ms gain)
        // 2. Parallel API calls (list + cash) ‚Üí ~200ms gain
        // 3. Force refresh option to bypass cache
        async function loadCurrentSaxoData(forceRefresh = false) {
            debugLogger.debug('üè¶ Loading Saxo data from active source...');

            try {
                // Hide cache indicator on fresh load
                const cacheIndicator = document.getElementById('cacheIndicator');
                if (cacheIndicator && forceRefresh) {
                    cacheIndicator.style.display = 'none';
                }

                // Show loading state
                document.getElementById('mainContent').style.display = 'block';
                document.getElementById('mainContent').innerHTML = '<div class="loading">üìä Loading stock data...</div>';
                document.getElementById('dashboardContent').style.display = 'none';

                const activeUser = localStorage.getItem('activeUser') || 'demo';

                // ‚úÖ FIX: Read bourseSource dynamically (don't trust window.saxoSourceType which may be stale)
                let bourseSource = window.wealthContextBar?.getContext()?.bourse;
                if (!bourseSource) {
                    bourseSource = localStorage.getItem('bourseSource') || 'api:saxobank_api';
                    debugLogger.debug(`‚ö†Ô∏è wealthContextBar not ready, using localStorage fallback: ${bourseSource}`);
                }

                // Determine source type from bourseSource
                const isManualSource = bourseSource === 'manual_bourse';
                const isApiSource = bourseSource && bourseSource.startsWith('api:');
                const isCsvSource = bourseSource && bourseSource.startsWith('saxo:');

                debugLogger.debug(`üîç Source detection: ${bourseSource} ‚Üí ${isManualSource ? 'MANUAL' : isApiSource ? 'API' : isCsvSource ? 'CSV' : 'UNKNOWN'}`);

                // CRITICAL: Update window.saxoSourceType for other functions (Risk, Recommendations, etc.)
                if (isManualSource) {
                    window.saxoSourceType = 'manual';
                } else if (isApiSource) {
                    window.saxoSourceType = 'api';
                } else if (isCsvSource) {
                    window.saxoSourceType = 'csv';
                } else {
                    window.saxoSourceType = null;
                }
                debugLogger.debug(`üîß window.saxoSourceType set to: ${window.saxoSourceType}`);

                // Include source type in cache key to avoid mixing API and CSV data
                const sourcePrefix = isManualSource ? 'manual' : isApiSource ? 'api' : (currentFileKey || 'default');
                const cacheKey = `saxo_portfolio_${activeUser}_${sourcePrefix}`;
                const CACHE_TTL = 5 * 60 * 1000; // 5 minutes

                // Check cache first (skip if force refresh)
                if (!forceRefresh) {
                    try {
                        const cached = localStorage.getItem(cacheKey);
                        if (cached) {
                            const { data, timestamp, cashAmount } = JSON.parse(cached);
                            if (Date.now() - timestamp < CACHE_TTL) {
                                debugLogger.debug(`‚ö° Using cached portfolio data (cacheKey: ${cacheKey})`);
                                debugLogger.debug(`üí∞ Cached cash amount: $${cashAmount || 0}`);
                                currentPortfolioData = data;
                                window.portfolioCash = cashAmount || 0;

                                // Show cache indicator
                                const cacheIndicator = document.getElementById('cacheIndicator');
                                if (cacheIndicator) {
                                    cacheIndicator.style.display = 'inline-block';
                                    // Auto-hide after 3 seconds
                                    setTimeout(() => {
                                        cacheIndicator.style.display = 'none';
                                    }, 3000);
                                }

                                // Instant display from cache
                                document.getElementById('mainContent').style.display = 'none';
                                document.getElementById('dashboardContent').style.display = 'block';
                                loadOverviewData(currentPortfolioData);
                                refreshActiveTab();


                                debugLogger.debug('‚úÖ Portfolio loaded from cache');
                                return;
                            }
                        }
                    } catch (cacheError) {
                        debugLogger.warn('Cache read failed, fetching fresh data:', cacheError);
                    }
                }

                let portfolioData;

                // Load from Sources V2 if manual mode
                if (isManualSource) {
                    debugLogger.debug('üìù Loading Saxo data from Sources V2 (manual)...');

                    try {
                        // Use fetch directly (safeFetch may not be loaded yet due to race condition)
                        const response = await fetch('/api/sources/v2/bourse/balances', {
                            headers: { 'X-User': activeUser }
                        });

                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }

                        const apiResponse = await response.json();
                        const ok = apiResponse.ok;
                        const data = apiResponse.data || apiResponse;

                        // Debug: log full response
                        console.log('üîç V2 API Response:', {
                            ok,
                            hasData: !!data,
                            dataKeys: data ? Object.keys(data) : [],
                            dataDataKeys: data?.data ? Object.keys(data.data) : [],
                            items_at_data: data?.items,
                            items_at_data_data: data?.data?.items,
                            count: data?.data?.count
                        });

                        if (!ok) {
                            const errorMsg = data?.message || data?.error || 'API request failed';
                            throw new Error(`Sources V2 API failed: ${errorMsg}`);
                        }

                        if (!data) {
                            throw new Error('No data returned from Sources V2 API');
                        }

                        // Backend returns success_response: { ok, data: { items: [...], count: N } }
                        // safeFetch returns this as-is, so items are at data.data.items
                        const items = data.data?.items || data.items || [];

                        // Transform V2 items to positions array
                        const positions = items.map(item => ({
                            symbol: item.symbol || item.asset_name || 'N/A',
                            asset_name: item.asset_name || item.symbol || 'N/A',
                            quantity: Number(item.amount || item.quantity || 0),
                            market_value: Number(item.value_usd || item.value || 0),
                            market_value_usd: Number(item.value_usd || item.value || 0),
                            asset_class: item.asset_class || 'EQUITY',
                            currency: item.currency || 'USD',
                            broker: item.broker || item.location || 'Manual',
                            avg_price: item.avg_price || (item.value / item.amount) || 0,
                            // Extra fields for compatibility
                            value: Number(item.value_usd || item.value || 0),
                            notes: item.notes || ''
                        }));

                        // Calculate summary metrics from positions
                        const totalValue = positions.reduce((sum, p) => sum + (p.market_value_usd || 0), 0);
                        const summary = calculateSummaryMetrics(positions, totalValue);

                        // Format portfolioData same as API mode (with positions property)
                        portfolioData = {
                            portfolio_id: 'manual_bourse',
                            name: 'Manual Stock Entry',
                            positions: positions,
                            source: 'manual',
                            timestamp: new Date().toISOString(),
                            summary: summary,
                            totalValueIncludesCash: false
                        };

                        // Manual entries don't have separate cash
                        window.portfolioCash = 0;

                        debugLogger.debug(`‚úÖ Loaded ${positions.length} manual positions from Sources V2`);

                    } catch (error) {
                        debugLogger.error('Erreur lors du chargement depuis Sources V2:', error);
                        showNoDataState(`‚ùå Sources V2 Error: ${error.message}`);
                        return;
                    }

                // Load from API or CSV based on source type
                } else if (isApiSource) {
                    debugLogger.debug('üåê Loading Saxo data from API...');

                    // OPTIMIZATION: Parallel fetch of API positions + cash (independent calls)
                    // Use fetch directly (safeFetch may not be loaded yet due to race condition)
                    const [apiResponse, cashResult] = await Promise.all([
                        fetch(`${window.getApiBase()}/api/saxo/api-positions`, {
                            headers: { 'X-User': activeUser }
                        }),
                        loadPortfolioCash() // Run in parallel
                    ]);

                    if (!apiResponse.ok) {
                        debugLogger.warn('Erreur lors du chargement depuis l\'API Saxo.');
                        showNoDataState('‚ùå Error loading from Saxo API');
                        return;
                    }

                    const apiResult = await apiResponse.json();
                    const apiOk = apiResult.ok;
                    const apiData = apiResult.data || apiResult;

                    if (!apiOk || !apiData) {
                        debugLogger.warn('Erreur lors du chargement depuis l\'API Saxo.');
                        showNoDataState('‚ùå Error loading from Saxo API');
                        return;
                    }

                    // Extract nested data from API response (safeFetch wraps success_response twice)
                    const innerData = apiData.data || apiData;

                    // üîç DEBUG: Log API response structure
                    console.log('üîç DEBUG API Response:', {
                        total_value: innerData.total_value,
                        cash_balance: innerData.cash_balance,
                        positions_count: innerData.positions?.length
                    });

                    // Transform API response to match CSV structure
                    const positions = innerData.positions || [];

                    // Normalize positions to add USD fields
                    const normalizedPositions = positions.map(pos => ({
                        ...pos,
                        market_value_usd: pos.market_value || 0,  // API uses market_value, frontend expects market_value_usd
                        total_value_usd: pos.market_value || 0    // Add total_value_usd for compatibility
                    }));

                    // Calculate total portfolio value
                    // ‚ö†Ô∏è CRITICAL: innerData.total_value from API already includes cash!
                    const totalValue = innerData.total_value || normalizedPositions.reduce((sum, p) => sum + (p.market_value_usd || 0), 0);
                    const totalValueIncludesCash = !!innerData.total_value; // Flag: true if from API (includes cash)

                    // Calculate summary metrics from positions
                    const summary = calculateSummaryMetrics(normalizedPositions, totalValue);

                    portfolioData = {
                        portfolio_id: 'saxo_api',
                        name: `Saxo Bank API (${innerData.source})`,
                        positions: normalizedPositions,
                        source: innerData.source || 'api',
                        timestamp: innerData.timestamp || new Date().toISOString(),
                        summary: summary,
                        totalValueIncludesCash: totalValueIncludesCash  // Flag for correct cash handling
                    };

                    // Extract cash balance from API
                    if (innerData.cash_balance !== undefined) {
                        window.portfolioCash = innerData.cash_balance;
                        debugLogger.debug(`üí∞ Cash balance from API: ${innerData.cash_balance} ${innerData.currency || 'EUR'}`);
                    } else {
                        // Fallback: calculate from total_value - positions
                        window.portfolioCash = Math.max(0, totalValue - normalizedPositions.reduce((sum, p) => sum + (p.market_value_usd || 0), 0));
                    }

                    // Show warning if using cached API data
                    if (innerData.warning) {
                        debugLogger.warn(`‚ö†Ô∏è API Cache Fallback: ${innerData.warning}`);
                    }

                    debugLogger.debug(`‚úÖ Loaded ${portfolioData.positions.length} positions from API (Total: ${totalValue.toLocaleString()} ${innerData.currency || 'EUR'})`);

                    // Show info message for empty Sim accounts
                    if (normalizedPositions.length === 0 && innerData.source === 'api') {
                        const envLabel = window.availableSources?.find(s => s.key === 'saxobank_api')?.environment || 'sim';
                        if (envLabel === 'sim') {
                            debugLogger.info('‚ÑπÔ∏è Compte Saxo Simulation vide - Utilisez le portail Saxo pour ajouter des positions de test');
                        }
                    }

                } else {
                    // Load from CSV
                    debugLogger.debug('üìÑ Loading Saxo data from CSV...');

                    // ‚úÖ Use currentFileKey which has been resolved by resolveFileKeyFromSource()
                    // No need to re-resolve here (already done at init or on source change)
                    const fileKey = currentFileKey;
                    debugLogger.debug(`üìÑ Using file_key: ${fileKey || 'null (backend will resolve from config)'}`);

                    // Build URLs
                    let portfoliosUrl = '/api/saxo/portfolios';
                    if (fileKey) {
                        portfoliosUrl += `?file_key=${encodeURIComponent(fileKey)}`;
                        debugLogger.debug(`üîç Loading portfolio with file_key: ${fileKey}`);
                    } else {
                        debugLogger.debug(`üîç Loading portfolio without file_key (backend auto-select from config)`);
                    }

                    // OPTIMIZATION: Parallel fetch of list + cash (independent calls)
                    // Use fetch directly (safeFetch may not be loaded yet due to race condition)
                    const fullUrl = `${window.getApiBase()}${portfoliosUrl}`;
                    debugLogger.debug(`üåê Calling API: ${fullUrl} with X-User: ${activeUser}`);

                    const [listResponse, cashResult] = await Promise.all([
                        fetch(fullUrl, {
                            headers: { 'X-User': activeUser }
                        }),
                        loadPortfolioCash(fileKey) // Run in parallel (pass fileKey)
                    ]);

                    if (!listResponse.ok) {
                        debugLogger.warn(`‚ùå HTTP ${listResponse.status}: ${listResponse.statusText}`);
                        showNoDataState(`‚ùå HTTP Error ${listResponse.status}: ${listResponse.statusText}`);
                        return;
                    }

                    const listResult = await listResponse.json();

                    // ‚úÖ FIX: /api/saxo/portfolios returns {portfolios: [...]} directly (no wrapper)
                    const portfolios = listResult.portfolios || [];

                    // Debug: log FULL response structure
                    debugLogger.debug('üì¶ Full API Response:', listResult);
                    debugLogger.debug('üì¶ Portfolio data:', {
                        hasPortfolios: portfolios.length > 0,
                        portfolioCount: portfolios.length,
                        firstPortfolioId: portfolios[0]?.portfolio_id
                    });

                    if (!portfolios || portfolios.length === 0) {
                        debugLogger.warn('√¢≈°¬†√Ø¬∏¬è Aucun portfolio CSV trouv√©. V√©rifiez que vos fichiers sont dans data/users/{user}/saxobank/data/ ou imports/');
                        showNoDataState('üìÇ No Saxo CSV found. Please import a Saxo Bank CSV file.');
                        return;
                    }

                    // Get first portfolio
                    const portfolio = portfolios[0];
                    const portfolioId = portfolio.portfolio_id;

                    if (!portfolioId) {
                        debugLogger.warn('Portfolio ID manquant.');
                        showNoDataState('‚ùå Error: Portfolio ID missing');
                        return;
                    }

                    // Load full portfolio details
                    let detailUrl = `/api/saxo/portfolios/${portfolioId}`;
                    if (fileKey) {
                        detailUrl += `?file_key=${encodeURIComponent(fileKey)}`;
                    }

                    // Use fetch directly (safeFetch may not be loaded yet due to race condition)
                    const detailResponse = await fetch(`${window.getApiBase()}${detailUrl}`, {
                        headers: { 'X-User': activeUser }
                    });

                    if (!detailResponse.ok) {
                        debugLogger.warn('Error loading portfolio.');
                        showNoDataState('‚ùå Error loading portfolio');
                        return;
                    }

                    // ‚úÖ FIX: /api/saxo/portfolios/{id} returns portfolio object directly (no wrapper)
                    portfolioData = await detailResponse.json();

                    if (!portfolioData || !portfolioData.portfolio_id) {
                        debugLogger.warn('Error loading portfolio.');
                        showNoDataState('‚ùå Error loading portfolio');
                        return;
                    }

                    debugLogger.debug('‚úÖ Portfolio loaded:', {
                        id: portfolioData.portfolio_id,
                        positionsCount: portfolioData.positions?.length || 0,
                        totalValue: portfolioData.total_value_usd
                    });
                }

                // Store portfolio data
                currentPortfolioData = portfolioData;

                // Debug: log final portfolio structure before displaying
                debugLogger.debug('üìä Final portfolio data to display:', {
                    portfolioId: currentPortfolioData?.portfolio_id,
                    positionsCount: currentPortfolioData?.positions?.length || 0,
                    totalValue: currentPortfolioData?.total_value_usd || currentPortfolioData?.summary?.total_value_usd,
                    hasSummary: !!currentPortfolioData?.summary,
                    summaryKeys: currentPortfolioData?.summary ? Object.keys(currentPortfolioData.summary) : []
                });

                // Save to cache
                try {
                    const cashToCache = window.portfolioCash || 0;
                    debugLogger.debug(`üíæ Caching portfolio (cacheKey: ${cacheKey}, cash: $${cashToCache})`);
                    localStorage.setItem(cacheKey, JSON.stringify({
                        data: portfolioData,
                        cashAmount: cashToCache,
                        timestamp: Date.now()
                    }));
                    debugLogger.debug('üíæ Portfolio cached for 5 minutes');
                } catch (cacheError) {
                    debugLogger.warn('Failed to cache portfolio:', cacheError);
                }

                // Hide main content and show dashboard
                document.getElementById('mainContent').style.display = 'none';
                document.getElementById('dashboardContent').style.display = 'block';

                // Load all sections
                loadOverviewData(currentPortfolioData);

                // Refresh active tab content after data load
                refreshActiveTab();

                debugLogger.debug('‚úÖ Saxo data loaded successfully');

                // Add export button once (check if already exists to avoid duplicates)
                const overviewSection = document.getElementById('overview');
                if (overviewSection && !overviewSection.querySelector('.export-btn')) {
                    // Dynamic import for ES module
                    import('./modules/export-button.js').then(({ renderExportButton }) => {
                        renderExportButton(overviewSection, 'saxo', {
                            endpoint: '/api/saxo/export-lists',
                            filename: 'saxo-portfolio'
                        });
                    }).catch(err => {
                        debugLogger.warn('Failed to load export button:', err);
                    });
                }

            } catch (error) {
                debugLogger.error('Error loading Saxo data:', error);
                showError('‚ùå Error loading data: ' + error.message);
            }
        }

        function loadOverviewData(data) {
            // Safe access to data properties
            const summary = data?.summary || {};
            const totalValue = Number(summary.total_value_usd || 0);
            const totalPositions = summary.total_positions || data?.positions?.length || 0;
            const assetAllocation = summary.asset_allocation || {};
            const currencyExposure = summary.currency_exposure || {};

            // Get saved cash value for this portfolio
            const savedCash = window.portfolioCash || 0;

            // ‚ö†Ô∏è CRITICAL: If total_value comes from API, it already includes cash!
            // Only add cash if totalValue was calculated from positions (CSV mode)
            const totalValueIncludesCash = data?.totalValueIncludesCash || false;
            const totalWithCash = totalValueIncludesCash ? totalValue : (totalValue + savedCash);

            // Portfolio Summary
            const summaryHtml = `
                <div class="metric-large">$${totalWithCash.toLocaleString()}</div>
                <div class="metric-label">Total Portfolio Value</div>
                <div style="margin-top: 1rem;">
                    <div style="display: flex; justify-content: space-between; margin: 0.5rem 0;">
                        <span>Positions:</span>
                        <span><strong>${totalPositions}</strong></span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin: 0.5rem 0;">
                        <span>Asset Classes:</span>
                        <span><strong>${Object.keys(assetAllocation).length + (savedCash > 0 ? 1 : 0)}</strong></span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin: 0.5rem 0;">
                        <span>Currencies:</span>
                        <span><strong>${Object.keys(currencyExposure).length}</strong></span>
                    </div>
                </div>
            `;
            document.getElementById('portfolioSummary').innerHTML = summaryHtml;

            // Asset Allocation (include cash as an asset class)
            const allocationWithCash = {};

            // Handle cash allocation based on source
            if (totalValueIncludesCash) {
                // API mode: totalValue already includes cash, percentages are already correct
                // Just copy existing allocations and add cash as separate class
                Object.assign(allocationWithCash, assetAllocation);
                if (savedCash > 0 && totalWithCash > 0) {
                    const cashPercentage = (savedCash / totalWithCash) * 100;
                    allocationWithCash['Cash'] = cashPercentage;
                }
            } else {
                // CSV mode: totalValue is positions only, need to recalculate with cash
                if (totalWithCash > 0) {
                    // Add existing asset classes with recalculated percentages
                    Object.entries(assetAllocation).forEach(([assetClass, percentage]) => {
                        const originalValue = (percentage / 100) * totalValue;
                        const newPercentage = (originalValue / totalWithCash) * 100;
                        allocationWithCash[assetClass] = newPercentage;
                    });

                    // Add cash as an asset class
                    if (savedCash > 0) {
                        const cashPercentage = (savedCash / totalWithCash) * 100;
                        allocationWithCash['Cash'] = cashPercentage;
                    }
                } else {
                    // No cash, use original allocation
                    Object.assign(allocationWithCash, assetAllocation);
                }
            }

            // Combined Asset Allocation & Currency Exposure
            const allocationHtml = Object.keys(allocationWithCash).length > 0 ? `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                    <h3 style="margin: 0;">Asset Classes</h3>
                    <button onclick="editCashAmount()" style="padding: 0.4rem 0.75rem; background: var(--brand-primary); color: white; border: none; border-radius: var(--radius-sm); cursor: pointer; font-size: 0.85rem; display: flex; align-items: center; gap: 0.35rem;">
                        Edit Cash
                    </button>
                </div>
                <div class="allocation-grid">
                    ${Object.entries(allocationWithCash)
                    .sort(([, a], [, b]) => b - a)
                    .map(([assetClass, percentage]) => {
                        const isCash = assetClass === 'Cash';
                        const style = isCash ? 'border: 2px solid #10b981;' : '';
                        return `
                            <div class="allocation-item" style="${style}">
                                <div class="allocation-percentage">${Number(percentage).toFixed(1)}%</div>
                                <div class="allocation-label">${assetClass}</div>
                                ${isCash ? `<div style="font-size: 0.75rem; opacity: 0.7; margin-top: 0.25rem;">$${savedCash.toLocaleString()}</div>` : ''}
                            </div>
                        `;
                    }).join('')}
                </div>
                <div style="border-top: 1px solid var(--theme-border); margin: 1.5rem 0 1rem 0; padding-top: 1rem;">
                    <h3 style="margin: 0 0 1rem 0;">Currencies</h3>
                    <div class="currency-grid">
                        ${Object.entries(currencyExposure)
                        .sort(([, a], [, b]) => b - a)
                        .map(([currency, percentage]) => `
                            <div class="currency-item">
                                <div class="currency-percentage">${percentage.toFixed(1)}%</div>
                                <div class="currency-code">${currency}</div>
                                <div style="font-size: 0.7rem; color: var(--theme-text-muted); margin-top: 0.25rem;">
                                    $${(totalValue * percentage / 100).toLocaleString()}
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            ` : '<div class="no-data">No allocation data available</div>';
            document.getElementById('assetAllocationCurrency').innerHTML = allocationHtml;

            // Create allocation chart
            renderAllocationChart(allocationWithCash);

            // Top Holdings
            const topHoldings = summary.top_holdings || data?.positions?.slice(0, 10) || [];
            const holdingsHtml = topHoldings.length > 0 ? `
                <table class="positions-table">
                    <thead>
                        <tr>
                            <th scope="col">Instrument</th>
                            <th scope="col">Symbol</th>
                            <th scope="col">Market Value</th>
                            <th scope="col">Asset Class</th>
                            <th scope="col">Weight</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${topHoldings.map(position => {
                            const name = position.name || position.instrument || position.symbol || 'Unknown';
                            const symbol = position.symbol || 'N/A';
                            const displayName = name !== symbol ? name : (position.isin || name);
                            return `
                            <tr>
                                <td><strong>${displayName}</strong></td>
                                <td><code style="font-size: 0.85rem; color: var(--theme-text-muted);">${symbol}</code></td>
                                <td>$${Number(position.market_value_usd || position.market_value || 0).toLocaleString()}</td>
                                <td>
                                    <span class="asset-class-badge asset-class-${(position.asset_class || 'other').toLowerCase()}">
                                        ${position.asset_class || 'N/A'}
                                    </span>
                                </td>
                                <td>${totalValue > 0 ? (((position.market_value_usd || position.market_value || 0) / totalValue) * 100).toFixed(1) : 0}%</td>
                            </tr>
                        `}).join('')}
                    </tbody>
                </table>
            ` : '<div class="no-data">No positions found</div>';
            document.getElementById('topHoldings').innerHTML = holdingsHtml;
        }

        // ==================== CASH / LIQUIDITIES MANAGEMENT ====================

        // Load saved cash amount for current portfolio (Sources V2)
        async function loadPortfolioCash(fileKey = null) {
            const activeUser = localStorage.getItem('activeUser') || 'demo';

            try {
                // Build URL with file_key (use parameter if provided, fallback to global)
                const key = fileKey || currentFileKey;
                let url = `/api/saxo/cash?user_id=${activeUser}`;
                if (key) {
                    url += `&file_key=${encodeURIComponent(key)}`;
                }

                debugLogger.debug(`üíµ Loading cash from backend (file_key: ${key || 'null -> backend will resolve from config'})`);

                // Use fetch directly (safeFetch may not be loaded yet due to race condition)
                const response = await fetch(`${window.getApiBase()}${url}`, {
                    headers: { 'X-User': activeUser }
                });
                if (response?.ok) {
                    const result = await response.json();
                    const data = result.data || result;
                    window.portfolioCash = Number(data.cash_amount || 0);
                    debugLogger.debug(`üíµ Loaded cash amount from backend: $${window.portfolioCash}`);
                } else {
                    debugLogger.warn(`üíµ Failed to load cash (HTTP ${response.status}), defaulting to 0`);
                    window.portfolioCash = 0;
                }
            } catch (error) {
                debugLogger.warn('Failed to load cash amount, defaulting to 0', error);
                window.portfolioCash = 0;
            }
        }

        // Edit cash amount (show modal)
        async function editCashAmount() {
            const currentCash = window.portfolioCash || 0;

            // Saved currency preference (default USD since portfolioCash is always in USD from API)
            const savedCurrency = localStorage.getItem('saxoCashCurrency') || 'USD';

            // Pre-load exchange rates (non-blocking)
            const ratesPromise = Promise.all([
                window.currencyManager.ensureRate('EUR'),
                window.currencyManager.ensureRate('CHF')
            ]);

            // Create modal
            const modal = document.createElement('div');
            modal.id = 'cashModal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.5);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            `;

            modal.innerHTML = `
                <div style="background: var(--theme-surface); border-radius: var(--radius-lg); padding: 2rem; max-width: 500px; width: 90%; box-shadow: var(--shadow-lg);">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
                        <h3 style="margin: 0; font-size: 1.25rem; font-weight: 700;">üíµ Edit Cash</h3>
                        <button onclick="closeCashModal()" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: var(--theme-text-muted);">√ó</button>
                    </div>

                    <div style="margin-bottom: 1rem;">
                        <label style="display: block; margin-bottom: 0.5rem; font-weight: 600;">Currency:</label>
                        <select id="currencySelect"
                            style="width: 100%; padding: 0.75rem; border: 1px solid var(--theme-border); border-radius: var(--radius-md); background: var(--theme-bg); color: var(--theme-text); font-size: 1rem; cursor: pointer;">
                            <option value="EUR" ${savedCurrency === 'EUR' ? 'selected' : ''}>EUR (Euro)</option>
                            <option value="USD" ${savedCurrency === 'USD' ? 'selected' : ''}>USD (Dollar)</option>
                            <option value="CHF" ${savedCurrency === 'CHF' ? 'selected' : ''}>CHF (Franc Suisse)</option>
                        </select>
                    </div>

                    <div style="margin-bottom: 1rem;">
                        <label style="display: block; margin-bottom: 0.5rem; font-weight: 600;">Amount:</label>
                        <input type="number" id="cashInput" value="${currentCash}" step="100" min="0"
                            style="width: 100%; padding: 0.75rem; border: 1px solid var(--theme-border); border-radius: var(--radius-md); background: var(--theme-bg); color: var(--theme-text); font-size: 1rem;"
                        />
                    </div>

                    <div id="conversionDisplay" style="padding: 1rem; background: var(--brand-primary-alpha); border-left: 3px solid var(--brand-primary); border-radius: var(--radius-sm); margin-bottom: 1rem; font-size: 0.875rem;">
                        <strong>üí± USD Equivalent:</strong> <span id="usdEquivalent">Loading exchange rates...</span>
                    </div>

                    <div style="padding: 1rem; background: var(--theme-bg); border-radius: var(--radius-sm); margin-bottom: 1.5rem; font-size: 0.875rem; color: var(--theme-text-muted);">
                        √¢‚Äû¬π√Ø¬∏¬è <strong>Info:</strong> Cette valeur repr√©sente les liquidit√©s disponibles sur votre compte Saxo. Elle sera prise en compte dans les analyses de risque et les recommandations (converties en USD).
                    </div>

                    <div style="display: flex; gap: 1rem; justify-content: flex-end;">
                        <button onclick="closeCashModal()" style="padding: 0.75rem 1.5rem; background: var(--theme-bg); border: 1px solid var(--theme-border); border-radius: var(--radius-md); cursor: pointer; font-weight: 600;">
                            Cancel
                        </button>
                        <button id="saveCashBtn" onclick="saveCashAmount()" disabled style="padding: 0.75rem 1.5rem; background: var(--brand-primary); color: white; border: none; border-radius: var(--radius-md); cursor: not-allowed; font-weight: 600; opacity: 0.5;">
                            ‚è≥ Loading...
                        </button>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);

            // Real-time conversion update
            function updateConversion() {
                const amount = parseFloat(document.getElementById('cashInput')?.value || 0);
                const currency = document.getElementById('currencySelect')?.value || 'EUR';
                const usdSpan = document.getElementById('usdEquivalent');

                if (currency === 'USD') {
                    usdSpan.textContent = `$${amount.toFixed(2)} USD`;
                } else {
                    const rate = window.currencyManager.getRateSync(currency);
                    if (rate > 0) {
                        const usdAmount = amount / rate;
                        usdSpan.textContent = `$${usdAmount.toFixed(2)} USD (taux: ${rate.toFixed(4)})`;
                    } else {
                        usdSpan.textContent = 'Loading rate...';
                    }
                }
            }

            // Add event listeners
            document.getElementById('cashInput')?.addEventListener('input', updateConversion);
            document.getElementById('currencySelect')?.addEventListener('change', updateConversion);

            // Wait for rates to be loaded, then enable save button
            ratesPromise.then(() => {
                const saveBtn = document.getElementById('saveCashBtn');
                if (saveBtn) {
                    saveBtn.disabled = false;
                    saveBtn.style.cursor = 'pointer';
                    saveBtn.style.opacity = '1';
                    saveBtn.textContent = 'üíæ Save';
                }
                updateConversion();
                document.getElementById('cashInput')?.focus();
            }).catch((error) => {
                debugLogger.warn('Failed to load exchange rates, using fallbacks', error);
                // Still enable button (we have fallback rates)
                const saveBtn = document.getElementById('saveCashBtn');
                if (saveBtn) {
                    saveBtn.disabled = false;
                    saveBtn.style.cursor = 'pointer';
                    saveBtn.style.opacity = '1';
                    saveBtn.textContent = 'üíæ Save';
                }
                updateConversion();
                document.getElementById('cashInput')?.focus();
            });

            // Close on Escape key
            window.addEventListener('keydown', function escHandler(e) {
                if (e.key === 'Escape') {
                    closeCashModal();
                    window.removeEventListener('keydown', escHandler);
                }
            });
        }

        // Close cash modal
        function closeCashModal() {
            const modal = document.getElementById('cashModal');
            if (modal) {
                modal.remove();
            }
        }

        // Save cash amount
        async function saveCashAmount() {
            const cashInput = document.getElementById('cashInput');
            const currencySelect = document.getElementById('currencySelect');
            const cashAmount = Number(cashInput?.value || 0);
            const currency = currencySelect?.value || 'EUR';

            if (cashAmount < 0) {
                alert('Amount cannot be negative');
                return;
            }

            const activeUser = localStorage.getItem('activeUser') || 'demo';

            try {
                // Show saving indicator
                cashInput.disabled = true;
                currencySelect.disabled = true;

                // Convert to USD
                let cashAmountUSD = cashAmount;
                if (currency !== 'USD') {
                    // Ensure rate is loaded
                    await window.currencyManager.ensureRate(currency);
                    const rate = window.currencyManager.getRateSync(currency);
                    if (rate > 0) {
                        cashAmountUSD = cashAmount / rate;
                        debugLogger.info(`üí± Converting ${cashAmount} ${currency} to USD using rate ${rate.toFixed(4)}`);
                    } else {
                        throw new Error(`Exchange rate ${currency}/USD not available. Please check your internet connection.`);
                    }
                }

                // Save currency preference
                localStorage.setItem('saxoCashCurrency', currency);

                // Build URL with file_key
                let url = `/api/saxo/cash?user_id=${activeUser}`;
                if (currentFileKey) {
                    url += `&file_key=${encodeURIComponent(currentFileKey)}`;
                }

                debugLogger.debug(`üíæ Saving cash: ${cashAmountUSD} USD with file_key: ${currentFileKey || 'default'}`);

                // Use fetch directly (safeFetch may not be loaded yet due to race condition)
                const response = await fetch(globalConfig.getApiUrl(url), {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-User': activeUser
                    },
                    body: JSON.stringify({
                        cash_amount: cashAmountUSD
                    })
                });

                if (!response?.ok) {
                    const errorText = await response.text();
                    throw new Error(`Failed to save cash amount: ${response.status} ${errorText}`);
                }

                // Update local value (in USD)
                window.portfolioCash = cashAmountUSD;

                // ‚úÖ FIX: Update cache with new cash amount to persist across refreshes
                try {
                    const activeUser = localStorage.getItem('activeUser') || 'demo';
                    const bourseSource = localStorage.getItem('bourseSource') || 'api:saxobank_api';
                    const isManualSource = bourseSource === 'manual_bourse';
                    const isApiSource = bourseSource && bourseSource.startsWith('api:');
                    const sourcePrefix = isManualSource ? 'manual' : isApiSource ? 'api' : (currentFileKey || 'default');
                    const cacheKey = `saxo_portfolio_${activeUser}_${sourcePrefix}`;

                    const cached = localStorage.getItem(cacheKey);
                    if (cached) {
                        const cacheObj = JSON.parse(cached);
                        // Update only cash amount, keep rest of cache intact
                        cacheObj.cashAmount = cashAmountUSD;
                        cacheObj.timestamp = Date.now(); // Update timestamp to extend cache validity
                        localStorage.setItem(cacheKey, JSON.stringify(cacheObj));
                        debugLogger.debug(`üíæ Updated cache with new cash amount: $${cashAmountUSD.toFixed(2)}`);
                    }
                } catch (e) {
                    debugLogger.warn('Failed to update cache with new cash amount', e);
                }

                // Close modal
                closeCashModal();

                // Reload overview to show updated value
                if (currentPortfolioData) {
                    loadOverviewData(currentPortfolioData);
                }

                debugLogger.info(`üíæ Cash amount saved: ${cashAmount} ${currency} ‚Üí $${cashAmountUSD.toFixed(2)} USD`);

            } catch (error) {
                debugLogger.error('Failed to save cash amount', error);
                alert('Error saving: ' + error.message);
                cashInput.disabled = false;
                currencySelect.disabled = false;
            }
        }

        function loadAllPositions() {
            if (!currentPortfolioData) return;

            // Consolidate positions by (symbol + asset_class)
            const byKey = {};
            currentPortfolioData.positions.forEach(pos => {
                const symbol = pos.symbol || 'UNKNOWN';
                const assetClass = pos.asset_class || 'Unknown';
                const key = `${symbol}|${assetClass}`;
                if (!byKey[key]) byKey[key] = [];
                byKey[key].push(pos);
            });

            const consolidated = [];
            for (const [key, positions] of Object.entries(byKey)) {
                if (positions.length === 1) {
                    consolidated.push(positions[0]);
                } else {
                    let filteredPositions = positions;
                    const values = positions.map(p => p.market_value_usd || 0).sort((a, b) => b - a);
                    const largest = values[0];
                    const sumOthers = values.slice(1).reduce((sum, v) => sum + v, 0);

                    if (values.length > 1 && Math.abs(largest - sumOthers) / Math.max(largest, 1) < 0.05) {
                        const sortedPositions = positions.slice().sort((a, b) =>
                            (b.market_value_usd || 0) - (a.market_value_usd || 0)
                        );
                        filteredPositions = sortedPositions.slice(1);
                        debugLogger.info(`Saxo summary detected for ${key}: removed summary line, keeping ${filteredPositions.length} detail lots`);
                    }

                    const total = {
                        ...filteredPositions[0],
                        quantity: filteredPositions.reduce((sum, p) => sum + (p.quantity || 0), 0),
                        market_value_usd: filteredPositions.reduce((sum, p) => sum + (p.market_value_usd || 0), 0),
                        lots_count: filteredPositions.length
                    };
                    consolidated.push(total);
                }
            }

            const positionsHtml = `
                <div class="table-container">
                    <table class="positions-table" id="positionsTable">
                        <thead>
                            <tr>
                                <th scope="col" onclick="sortPositionsTable('instrument')" style="cursor: pointer; user-select: none;">Instrument <span id="sortIcon-instrument">‚ÜïÔ∏è</span></th>
                                <th scope="col" onclick="sortPositionsTable('symbol')" style="cursor: pointer; user-select: none;">Symbol <span id="sortIcon-symbol">‚ÜïÔ∏è</span></th>
                                <th scope="col" onclick="sortPositionsTable('quantity')" style="cursor: pointer; user-select: none;">Quantity <span id="sortIcon-quantity">‚ÜïÔ∏è</span></th>
                                <th scope="col" onclick="sortPositionsTable('market_value')" style="cursor: pointer; user-select: none;">Market Value <span id="sortIcon-market_value">‚ñº</span></th>
                                <th scope="col" onclick="sortPositionsTable('pnl_value')" style="cursor: pointer; user-select: none;">P&L Value <span id="sortIcon-pnl_value">‚ÜïÔ∏è</span></th>
                                <th scope="col" onclick="sortPositionsTable('pnl_pct')" style="cursor: pointer; user-select: none;">P&L % <span id="sortIcon-pnl_pct">‚ÜïÔ∏è</span></th>
                                <th scope="col" onclick="sortPositionsTable('currency')" style="cursor: pointer; user-select: none;">Currency <span id="sortIcon-currency">‚ÜïÔ∏è</span></th>
                                <th scope="col" onclick="sortPositionsTable('asset_class')" style="cursor: pointer; user-select: none;">Asset Class <span id="sortIcon-asset_class">‚ÜïÔ∏è</span></th>
                                <th scope="col" onclick="sortPositionsTable('weight')" style="cursor: pointer; user-select: none;">Weight <span id="sortIcon-weight">‚ÜïÔ∏è</span></th>
                            </tr>
                        </thead>
                        <tbody>
                            ${consolidated
                    .sort((a, b) => (b.market_value_usd || 0) - (a.market_value_usd || 0))
                    .map(position => {
                        const name = position.name || position.instrument || position.symbol || 'Unknown';
                        const symbol = position.symbol || 'N/A';
                        const displayName = name !== symbol ? name : (position.isin || name);
                        const weight = ((position.market_value_usd / currentPortfolioData.summary.total_value_usd) * 100);

                        const lotsCount = position.lots_count || 0;
                        const fragmentationBadge = lotsCount > 1 ?
                            `<span style="display: inline-block; margin-left: 0.5rem; font-size: 0.65rem; padding: 0.15rem 0.4rem; background: #ef4444; color: white; border-radius: 3px; font-weight: 600;" title="${lotsCount} lots detected - Consider consolidation to reduce fees">‚ö†Ô∏è ${lotsCount} lots</span>` : '';

                        return `
                                <tr
                                    data-instrument="${displayName.replace(/"/g, '&quot;')}"
                                    data-symbol="${symbol}"
                                    data-quantity="${position.quantity}"
                                    data-market_value="${position.market_value_usd}"
                                    data-pnl_value="${position.pnl_value || 0}"
                                    data-pnl_pct="${position.pnl_pct || 0}"
                                    data-currency="${position.currency}"
                                    data-asset_class="${position.asset_class}"
                                    data-weight="${weight}"
                                >
                                    <td>
                                        <strong>${displayName}</strong>${fragmentationBadge}
                                        ${position.isin ? `<div style="font-size: 0.75rem; color: var(--theme-text-muted); margin-top: 0.25rem;">ISIN: ${position.isin}</div>` : ''}
                                    </td>
                                    <td><code style="font-size: 0.85rem;">${symbol}</code></td>
                                    <td>${position.quantity.toLocaleString()}</td>
                                    <td><strong>$${position.market_value_usd.toLocaleString()}</strong></td>
                                    <td style="color: ${(position.pnl_value || 0) >= 0 ? 'var(--success)' : 'var(--danger)'}; font-weight: 600;">
                                        ${(position.pnl_value || 0) >= 0 ? '+' : ''}${(position.pnl_value || 0).toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}
                                    </td>
                                    <td style="color: ${(position.pnl_pct || 0) >= 0 ? 'var(--success)' : 'var(--danger)'}; font-weight: 600;">
                                        ${(position.pnl_pct || 0) >= 0 ? '+' : ''}${(position.pnl_pct || 0).toFixed(2)}%
                                    </td>
                                    <td>${position.currency}</td>
                                    <td>
                                        <span class="asset-class-badge asset-class-${(position.asset_class || position.asset_type || 'unknown').toLowerCase()}">
                                            ${position.asset_class || position.asset_type || 'Unknown'}
                                        </span>
                                    </td>
                                    <td>${weight.toFixed(1)}%</td>
                                </tr>
                        `}).join('')}
                        </tbody>
                    </table>
                </div>
            `;

            document.getElementById('allPositions').innerHTML = positionsHtml;
            document.getElementById('positionsCount').textContent = `${consolidated.length} positions`;
        }

        function sortPositionsTable(column) {
            const table = document.getElementById('positionsTable');
            if (!table) return;
            const tbody = table.querySelector('tbody');
            if (!tbody) return;

            const rows = Array.from(tbody.querySelectorAll('tr'));

            if (positionsSortState.column === column) {
                positionsSortState.ascending = !positionsSortState.ascending;
            } else {
                positionsSortState.column = column;
                positionsSortState.ascending = ['instrument', 'symbol', 'currency', 'asset_class'].includes(column); // Default to ascending for text
            }

            const isNumeric = ['quantity', 'market_value', 'weight'].includes(column);

            rows.sort((a, b) => {
                const aValText = a.dataset[column] || '';
                const bValText = b.dataset[column] || '';

                if (isNumeric) {
                    const aVal = parseFloat(aValText);
                    const bVal = parseFloat(bValText);
                    if (!isNaN(aVal) && !isNaN(bVal)) {
                        return positionsSortState.ascending ? aVal - bVal : bVal - aVal;
                    }
                }
                
                // Fallback to string comparison
                const comparison = aValText.localeCompare(bValText);
                return positionsSortState.ascending ? comparison : -comparison;
            });

            tbody.innerHTML = '';
            rows.forEach(row => tbody.appendChild(row));

            // Update icons
            const headers = ['instrument', 'symbol', 'quantity', 'market_value', 'currency', 'asset_class', 'weight'];
            headers.forEach(header => {
                const icon = document.getElementById(`sortIcon-${header}`);
                if (icon) {
                    if (header === column) {
                        icon.textContent = positionsSortState.ascending ? '‚ñ≤' : '‚ñº';
                    } else {
                        icon.textContent = '‚ÜïÔ∏è';
                    }
                }
            });
        }

        function loadAllocationDetails() {
            if (!currentPortfolioData) return;

            // Asset class breakdown
            const assetClassHtml = `
                <div class="allocation-grid">
                    ${Object.entries(currentPortfolioData.summary.asset_allocation)
                    .sort(([, a], [, b]) => b - a)
                    .map(([assetClass, percentage]) => `
                            <div class="allocation-item">
                                <div class="allocation-percentage">${percentage.toFixed(1)}%</div>
                                <div class="allocation-label">${assetClass}</div>
                                <div style="font-size: 0.7rem; color: var(--theme-text-muted); margin-top: 0.25rem;">
                                    $${(currentPortfolioData.summary.total_value_usd * percentage / 100).toLocaleString()}
                                </div>
                            </div>
                        `).join('')}
                </div>
            `;
            document.getElementById('assetClassBreakdown').innerHTML = assetClassHtml;

            // Holdings by value
            const holdingsByValueHtml = `
                <div style="max-height: 400px; overflow-y: auto;">
                    ${currentPortfolioData.summary.top_holdings.map((position, index) => {
                        const name = position.name || position.instrument || position.symbol || 'Unknown';
                        const symbol = position.symbol || 'N/A';
                        const displayName = name !== symbol ? name : (position.isin || name);
                        return `
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.75rem 0; border-bottom: 1px solid var(--theme-border);">
                            <div>
                                <div style="font-weight: 600;">${index + 1}. ${displayName}</div>
                                <div style="font-size: 0.75rem; color: var(--theme-text-muted);">
                                    ${symbol} ‚Ä¢ ${position.asset_class}
                                </div>
                            </div>
                            <div style="text-align: right;">
                                <div style="font-weight: 600;">$${position.market_value_usd.toLocaleString()}</div>
                                <div style="font-size: 0.8rem; color: var(--theme-text-muted);">
                                    ${((position.market_value_usd / currentPortfolioData.summary.total_value_usd) * 100).toFixed(1)}%
                                </div>
                            </div>
                        </div>
                    `}).join('')}
                </div>
            `;
            document.getElementById('holdingsByValue').innerHTML = holdingsByValueHtml;
        }
        // Allocation Chart
        let allocationChartInstance = null;

        function renderAllocationChart(allocationData) {
            const canvas = document.getElementById('allocationChart');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');

            // Destroy previous chart instance if exists
            if (allocationChartInstance) {
                allocationChartInstance.destroy();
            }

            // Prepare data
            const labels = Object.keys(allocationData);
            const data = Object.values(allocationData);

            // Color palette
            const colors = {
                'ETF': '#3b82f6',      // Blue
                'Stock': '#8b5cf6',    // Purple
                'Cash': '#10b981',     // Green
                'Bond': '#f59e0b',     // Orange
                'Other': '#6b7280'     // Gray
            };

            const backgroundColors = labels.map(label => colors[label] || '#94a3b8');

            // Create chart
            allocationChartInstance = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: backgroundColors,
                        borderWidth: 2,
                        borderColor: '#ffffff'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: {
                                padding: 15,
                                font: {
                                    size: 12,
                                    family: "'Inter', sans-serif"
                                },
                                usePointStyle: true,
                                pointStyle: 'circle'
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const label = context.label || '';
                                    const value = context.parsed || 0;
                                    return `${label}: ${value.toFixed(1)}%`;
                                }
                            }
                        }
                    }
                }
            });
        }

        function showError(message) {
            document.getElementById('mainContent').innerHTML = `
                <div class="error-message">${message}</div>
            `;
            document.getElementById('dashboardContent').style.display = 'none';
        }

        function showNoDataState(message) {
            document.getElementById('mainContent').innerHTML = `
                <div class="no-data">
                    <h3>üìÇ No data available</h3>
                    <p>${message}</p>
                </div>
            `;
            document.getElementById('dashboardContent').style.display = 'none';
        }

        // Initialize page
        // ==================== INITIALIZE FILE KEY FROM SOURCE ====================
        /**
         * Resolve currentFileKey from bourseSource (extracted from event listener for reuse at init)
         */
        async function resolveFileKeyFromSource(bourseSource) {
            currentFileKey = null; // Reset
            window.saxoSourceType = null; // Reset source type

            // Detect Manual source (Sources V2)
            if (bourseSource === 'manual_bourse') {
                window.saxoSourceType = 'manual';
                debugLogger.debug(`üìù Manual source detected: ${bourseSource}`);
            }
            // Detect API source (starts with 'api:')
            else if (bourseSource && bourseSource.startsWith('api:')) {
                window.saxoSourceType = 'api';
                debugLogger.debug(`üåê API source detected: ${bourseSource}`);
            }
            // Detect CSV source (starts with 'saxo:')
            else if (bourseSource && bourseSource !== 'all' && bourseSource.startsWith('saxo:')) {
                window.saxoSourceType = 'csv';
                const key = bourseSource.substring(5); // Remove 'saxo:' prefix
                const activeUser = localStorage.getItem('activeUser') || 'demo';

                try {
                    // Load available sources to resolve file_key
                    if (!window.availableSources) {
                        // Use fetch directly (safeFetch may not be loaded yet due to race condition)
                        const response = await fetch(globalConfig.getApiUrl('/api/users/sources'));
                        if (response.ok) {
                            const result = await response.json();
                            // API returns { user, sources: [...], ... } directly (not wrapped in data)
                            window.availableSources = result.sources || [];
                        }
                    }

                    // Find matching source and extract filename
                    const source = window.availableSources?.find(s => s.key === key);
                    if (source?.file_path) {
                        // Sources V1: specific file path provided
                        currentFileKey = source.file_path.split(/[/\\]/).pop();
                        debugLogger.debug(`üìÑ Resolved file_key: ${currentFileKey}`);
                    } else if (source) {
                        // Sources V2: generic source without specific file (backend auto-loads)
                        currentFileKey = null;
                        debugLogger.debug(`üìÑ Using Sources V2 (backend will auto-load): ${key}`);
                    } else {
                        debugLogger.warn(`‚ö†Ô∏è Source not found: ${key}`);
                    }
                } catch (err) {
                    debugLogger.warn('[Saxo Dashboard] Failed to resolve file_key:', err);
                }
            }
        }

        document.addEventListener('DOMContentLoaded', async () => {
            debugLogger.debug('üè¶ Saxo Dashboard initialized');

            // Initialize wealth context integration
            initWealthContextIntegration();

            // ‚úÖ FIX: Initialize currentFileKey from bourseSource BEFORE first load
            const bourseSource = localStorage.getItem('bourseSource') || 'api:saxobank_api';
            await resolveFileKeyFromSource(bourseSource);

            // Debounce timer for source changes
            let sourceChangeTimeout = null;

            // Listen for Bourse source changes from WealthContextBar (with debounce)
            window.addEventListener('bourseSourceChanged', async (event) => {
                debugLogger.debug('üîÑ Bourse source changed:', event.detail);

                // Invalidate all Saxo caches (critical for source switching)
                const activeUser = localStorage.getItem('activeUser') || 'demo';
                Object.keys(localStorage).forEach(key => {
                    if (key.startsWith(`saxo_portfolio_${activeUser}_`)) {
                        localStorage.removeItem(key);
                        debugLogger.debug(`üßπ Cleared cache: ${key}`);
                    }
                });

                // Clear previous timeout to debounce rapid changes
                if (sourceChangeTimeout) {
                    clearTimeout(sourceChangeTimeout);
                    debugLogger.debug('‚è±Ô∏è Debouncing source change...');
                }

                // Debounce: wait 300ms before loading
                sourceChangeTimeout = setTimeout(async () => {
                    // Resolve file_key from source (reuse centralized function)
                    const bourseSource = window.wealthContextBar?.getContext()?.bourse;
                    await resolveFileKeyFromSource(bourseSource);

                    // Reload data with new source (force refresh to bypass cache on source change)
                    loadCurrentSaxoData(true);
                }, 300);
            });

            // Load current Saxo data from active source
            await loadCurrentSaxoData();
        });

    </script>
    </main>
</body>

</html>
