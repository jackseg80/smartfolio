<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Advanced Portfolio Optimization - Crypto Portfolio</title>

  <link rel="stylesheet" href="css/tokens.css">
    <link rel="stylesheet" href="shared-theme.css">
  <link rel="stylesheet" href="theme-compat.css">

  <script src="global-config.js"></script>
  <script src="appearance.js"></script>

  <!-- Navigation unifi√©e -->
  <script type="module">
    if (new URLSearchParams(window.location.search).get('nav') !== 'off') {
      import('./components/nav.js');
    }
  </script>

  <!-- Chart.js for visualizations -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.js"></script>
  <script type="module" src="components/tooltips.js"></script>

  <style>
    .wrap {
      max-width: none;
      margin: 0 auto;
      padding: var(--space-lg);
      width: 100%;
    }

    /* Adaptive padding pour grands √©crans */
    @media (min-width: 2000px) {
      .wrap {
        padding: var(--space-xl);
      }
    }

    .card {
      background: var(--theme-surface);
      border: 1px solid var(--theme-border);
      border-radius: var(--radius-lg);
      padding: var(--space-lg);
      margin-bottom: var(--space-lg);
    }

    .card-header {
      border-bottom: 1px solid var(--theme-border);
      padding-bottom: var(--space-md);
      margin-bottom: var(--space-lg);
    }

    .card-title {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 1.2rem;
      font-weight: 600;
      color: var(--theme-text);
    }

    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: .75rem;
      margin-bottom: var(--space-lg);
    }

    .controls label {
      display: block;
      font-size: .9rem;
      color: var(--theme-text-muted);
      margin-bottom: .25rem;
      font-weight: 500;
    }

    .controls select,
    .controls input,
    .controls textarea {
      width: 100%;
      padding: .5rem .6rem;
      border: 1px solid var(--theme-border);
      border-radius: var(--radius-sm);
      background: var(--theme-surface);
      color: var(--theme-text);
      font-size: 0.9rem;
    }

    .controls textarea {
      min-height: 60px;
      resize: vertical;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    }

    .algorithm-tabs {
      display: flex;
      gap: 0.5rem;
      margin-bottom: var(--space-lg);
      flex-wrap: wrap;
    }

    .tab-btn {
      padding: 0.5rem 1rem;
      border: 1px solid var(--theme-border);
      background: var(--theme-surface);
      color: var(--theme-text);
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: all 0.2s;
      font-size: 0.9rem;
    }

    .tab-btn.active {
      background: var(--brand-primary);
      color: white;
      border-color: var(--brand-primary);
    }

    .tab-btn:hover:not(.active) {
      background: var(--theme-muted);
    }

    .algorithm-config {
      display: none;
      padding: var(--space-lg);
      background: var(--theme-bg);
      border: 1px solid var(--theme-border);
      border-radius: var(--radius-md);
      margin-bottom: var(--space-lg);
    }

    .algorithm-config.active {
      display: block;
    }

    .actions {
      margin-top: var(--space-lg);
      display: flex;
      gap: .5rem;
      flex-wrap: wrap;
      align-items: center;
    }

    .btn {
      background: var(--brand-primary);
      color: #fff;
      border: 0;
      padding: .6rem 1rem;
      border-radius: var(--radius-sm);
      cursor: pointer;
      font-weight: 500;
      transition: all 0.2s;
    }

    .btn:hover {
      background: var(--brand-primary-hover);
    }

    .btn.secondary {
      background: var(--theme-surface);
      color: var(--theme-text);
      border: 1px solid var(--theme-border);
    }

    .btn.secondary:hover {
      background: var(--theme-muted);
    }

    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap: var(--space-lg);
    }

    .grid-3 {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: var(--space-md);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.9rem;
    }

    th, td {
      text-align: left;
      padding: .5rem;
      border-bottom: 1px solid var(--theme-border);
    }

    th {
      color: var(--theme-text-muted);
      font-weight: 600;
      background: var(--theme-bg);
    }

    .kpis {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: .5rem;
      margin-bottom: var(--space-md);
    }

    .kpi {
      background: var(--theme-bg);
      border: 1px solid var(--theme-border);
      border-radius: var(--radius-md);
      padding: .6rem;
      text-align: center;
    }

    .kpi .label {
      color: var(--theme-text-muted);
      font-size: .8rem;
      margin-bottom: 0.25rem;
    }

    .kpi .value {
      font-weight: 700;
      font-size: 1.1rem;
      color: var(--brand-primary);
    }

    .error, .warning, .success {
      padding: .6rem;
      border-radius: var(--radius-sm);
      margin: .5rem 0;
      font-size: 0.9rem;
    }

    .error {
      background: var(--danger-bg);
      color: var(--danger);
      border: 1px solid var(--danger);
    }

    .warning {
      background: var(--warning-bg);
      color: var(--warning);
      border: 1px solid var(--warning);
    }

    .success {
      background: var(--pos-bg);
      color: var(--pos);
      border: 1px solid var(--pos);
    }

    .chart-container {
      position: relative;
      height: 300px;
      margin-bottom: var(--space-md);
    }

    .help-text {
      font-size: 0.85rem;
      color: var(--theme-text-muted);
      margin-top: 0.25rem;
      font-style: italic;
    }

    .comparison-table {
      margin-top: var(--space-lg);
    }

    .comparison-table th {
      background: var(--brand-primary);
      color: white;
    }

    .param-group {
      background: var(--theme-surface-elevated);
      border-radius: var(--radius-sm);
      padding: var(--space-md);
      margin-bottom: var(--space-md);
    }

    .param-group h4 {
      margin: 0 0 var(--space-sm) 0;
      color: var(--theme-text);
      font-size: 1rem;
    }

    /* Tooltips */
    .tooltip-icon {
      display: inline-block;
      width: 16px;
      height: 16px;
      line-height: 16px;
      text-align: center;
      border-radius: 50%;
      background: var(--theme-text-muted);
      color: var(--theme-surface);
      font-size: 11px;
      font-weight: bold;
      cursor: help;
      margin-left: 4px;
      position: relative;
    }

    .tooltip-icon:hover::after {
      content: attr(data-tooltip);
      position: absolute;
      bottom: 125%;
      left: 50%;
      transform: translateX(-50%);
      background: var(--theme-surface-elevated);
      color: var(--theme-text);
      padding: 8px 12px;
      border-radius: var(--radius-sm);
      border: 1px solid var(--theme-border);
      font-size: 12px;
      font-weight: normal;
      white-space: normal;
      width: 220px;
      z-index: 1000;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }

    .tooltip-icon:hover::before {
      content: '';
      position: absolute;
      bottom: 115%;
      left: 50%;
      transform: translateX(-50%);
      border: 6px solid transparent;
      border-top-color: var(--theme-surface-elevated);
      z-index: 1001;
    }

    @media (max-width: 768px) {
      .controls {
        grid-template-columns: 1fr;
      }

      .algorithm-tabs {
        flex-direction: column;
      }

      .tab-btn {
        text-align: center;
      }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="card">
      <div class="card-header">
        <div class="card-title">
          üßÆ Advanced Portfolio Optimization
        </div>
        <p style="margin: 0.5rem 0 0 0; color: var(--theme-text-muted); font-size: 0.95rem;">
          Sophisticated optimal allocation algorithms: Markowitz, Black-Litterman, Risk Parity, CVaR, and more
        </p>
      </div>

      <!-- Configuration de base -->
      <div class="controls">
        <div>
          <label for="source">Data source</label>
          <select id="source">
            <option value="cointracking">CoinTracking CSV</option>
            <option value="cointracking_api">CoinTracking API</option>
            <option value="stub">Demo (stub)</option>
          </select>
        </div>
        <div>
          <label for="lookback">
            History (days)
            <span class="tooltip-icon" data-tooltip="Historical period for computing returns and volatility. Short (90d) = trend-reactive, Long (730d) = more stable">‚Ñπ</span>
          </label>
          <input id="lookback" type="number" min="30" max="2000" value="365" />
          <div class="help-text">Longer = more stable, shorter = more reactive</div>
        </div>
        <div>
          <label for="minusd">Min. amount per asset ($)</label>
          <input id="minusd" type="number" min="0" max="100000" step="10" value="100" />
        </div>
        <div>
          <label for="risk-free-rate">
            Risk-free rate (%)
            <span class="tooltip-icon" data-tooltip="Return rate of a risk-free asset (e.g., government bonds). Used in the Sharpe ratio calculation = (Return - Risk-free rate) / Volatility">‚Ñπ</span>
          </label>
          <input id="risk-free-rate" type="number" min="0" max="10" step="0.1" value="2.0" />
          <div class="help-text">Used for Sharpe ratio calculation</div>
        </div>
      </div>

      <!-- S√©lection d'algorithme -->
      <div class="algorithm-tabs">
        <button class="tab-btn active" data-algorithm="max_sharpe">Max Sharpe</button>
        <button class="tab-btn" data-algorithm="black_litterman">Black-Litterman</button>
        <button class="tab-btn" data-algorithm="risk_parity">Risk Parity</button>
        <button class="tab-btn" data-algorithm="max_diversification">Max Diversification</button>
        <button class="tab-btn" data-algorithm="cvar_optimization">CVaR Optimization</button>
        <button class="tab-btn" data-algorithm="efficient_frontier">Efficient Frontier</button>
      </div>

      <!-- Configuration Max Sharpe -->
      <div id="config-max_sharpe" class="algorithm-config active">
        <h4>üìà Sharpe Ratio Maximization</h4>
        <p style="color: var(--theme-text-muted); margin-bottom: var(--space-md);">
          Optimise le ratio rendement/risque. Algorithme classique de Markowitz.
        </p>
        <div class="param-group">
          <h4>Constraints</h4>
          <div class="controls">
            <div>
              <label for="max-weight-sharpe">Max weight per asset (%)</label>
              <input id="max-weight-sharpe" type="number" min="1" max="100" value="35" />
            </div>
            <div>
              <label for="max-sector-sharpe">Max weight per sector (%)</label>
              <input id="max-sector-sharpe" type="number" min="1" max="100" value="60" />
            </div>
          </div>
        </div>
      </div>

      <!-- Configuration Black-Litterman -->
      <div id="config-black_litterman" class="algorithm-config">
        <h4>üîÆ Black-Litterman with Market Views</h4>
        <p style="color: var(--theme-text-muted); margin-bottom: var(--space-md);">
          Integrates your views on future returns with market equilibrium.
        </p>
        <div class="param-group">
          <h4>Market Views</h4>
          <div class="controls">
            <div style="grid-column: 1 / -1;">
              <label for="market-views">Views on annual returns (JSON)</label>
              <textarea id="market-views" placeholder='{"BTC": 0.15, "ETH": 0.12, "SOL": 0.20}'>{"BTC": 0.15, "ETH": 0.12, "SOL": 0.20}</textarea>
              <div class="help-text">Format: {"SYMBOL": annual_return}. E.g., 0.15 = 15% per year</div>
            </div>
            <div style="grid-column: 1 / -1;">
              <label for="view-confidence">Confidence in views (JSON)</label>
              <textarea id="view-confidence" placeholder='{"BTC": 0.8, "ETH": 0.6, "SOL": 0.7}'>{"BTC": 0.8, "ETH": 0.6, "SOL": 0.7}</textarea>
              <div class="help-text">0 = no confidence, 1 = full confidence</div>
            </div>
          </div>
        </div>
      </div>

      <!-- Configuration Risk Parity -->
      <div id="config-risk_parity" class="algorithm-config">
        <h4>‚öñÔ∏è Risk Parity</h4>
        <p style="color: var(--theme-text-muted); margin-bottom: var(--space-md);">
          Equalizes each asset's risk contribution. Optimal diversification.
        </p>
        <div class="param-group">
          <h4>Parameters</h4>
          <div class="controls">
            <div>
              <label for="target-vol-rp">
                Target volatility (%)
                <span class="tooltip-icon" data-tooltip="Risk Parity equalizes each asset's risk contribution (not weights). Setting a target volatility controls the total portfolio risk">‚Ñπ</span>
              </label>
              <input id="target-vol-rp" type="number" min="5" max="50" step="1" value="15" />
              <div class="help-text">Leave empty for unconstrained optimization</div>
            </div>
          </div>
        </div>
      </div>

      <!-- Configuration Max Diversification -->
      <div id="config-max_diversification" class="algorithm-config">
        <h4>üåê Diversification Maximization</h4>
        <p style="color: var(--theme-text-muted); margin-bottom: var(--space-md);">
          Maximizes the diversification ratio (weighted individual volatilities / portfolio volatility).
        </p>
        <div class="param-group">
          <h4>Constraints</h4>
          <div class="controls">
            <div>
              <label for="min-div-ratio">Min diversification ratio</label>
              <input id="min-div-ratio" type="number" min="1" max="5" step="0.1" value="1.5" />
            </div>
            <div>
              <label for="max-corr-exp">Max correlation exposure</label>
              <input id="max-corr-exp" type="number" min="0.1" max="1" step="0.05" value="0.7" />
            </div>
          </div>
        </div>
      </div>

      <!-- Configuration CVaR -->
      <div id="config-cvar_optimization" class="algorithm-config">
        <h4>üìâ Conditional Value at Risk (CVaR)</h4>
        <p style="color: var(--theme-text-muted); margin-bottom: var(--space-md);">
          Minimizes extreme losses. Tail distribution optimization.
        </p>
        <div class="param-group">
          <h4>Risk Parameters</h4>
          <div class="controls">
            <div>
              <label for="confidence-level">
                Confidence level (%)
                <span class="tooltip-icon" data-tooltip="CVaR (Conditional Value at Risk) measures the average loss in worst-case scenarios. 95% = optimizes to limit losses in the worst 5% of cases">‚Ñπ</span>
              </label>
              <input id="confidence-level" type="number" min="90" max="99" value="95" />
              <div class="help-text">95% = optimizes for the worst 5% scenarios</div>
            </div>
            <div>
              <label for="cvar-weight">
                CVaR vs Sharpe weight
                <span class="tooltip-icon" data-tooltip="Balance between extreme risk minimization (CVaR) and return/risk maximization (Sharpe). 1.0 = 100% focus on protection, 0.0 = 100% focus on performance">‚Ñπ</span>
              </label>
              <input id="cvar-weight" type="number" min="0" max="1" step="0.1" value="0.7" />
              <div class="help-text">1.0 = 100% CVaR, 0.0 = 100% Sharpe</div>
            </div>
          </div>
        </div>
      </div>

      <!-- Configuration Efficient Frontier -->
      <div id="config-efficient_frontier" class="algorithm-config">
        <h4>üìä Efficient Frontier</h4>
        <p style="color: var(--theme-text-muted); margin-bottom: var(--space-md);">
          Computes the set of optimal portfolios for different risk levels.
        </p>
        <div class="param-group">
          <h4>Computation Parameters</h4>
          <div class="controls">
            <div>
              <label for="frontier-points">Number of points</label>
              <input id="frontier-points" type="number" min="10" max="100" value="30" />
            </div>
            <div>
              <label for="show-current">Show current portfolio</label>
              <select id="show-current">
                <option value="true">Yes</option>
                <option value="false">No</option>
              </select>
            </div>
          </div>
        </div>
      </div>

      <div class="actions">
        <button class="btn" id="runBtn">üöÄ Optimize</button>
        <button class="btn secondary" id="compareBtn">üìä Compare Algorithms</button>
        <button class="btn secondary" id="resetBtn">üîÑ Reset</button>
        <span id="status" style="margin-left: auto; color: var(--theme-text-muted); font-size: 0.9rem;"></span>
      </div>
    </div>

    <!-- R√©sultats -->
    <div class="grid" id="results-container" style="display: none;">
      <div class="card">
        <div class="card-title" style="margin-bottom: var(--space-md);">üìà Optimal Allocation</div>
        <div class="chart-container">
          <canvas id="weightsChart"></canvas>
        </div>
        <table id="weightsTable"></table>
      </div>

      <div class="card">
        <div class="card-title" style="margin-bottom: var(--space-md);">üìä Performance Metrics</div>
        <div class="kpis" id="kpis"></div>
        <div id="additional-metrics"></div>
      </div>

      <div class="card">
        <div class="card-title" style="margin-bottom: var(--space-md);">üîÑ Rebalancing Plan</div>
        <table id="tradesTable"></table>
      </div>

      <!-- Export Actions -->
      <div class="card" style="grid-column: 1 / -1;">
        <div style="display: flex; gap: 0.5rem; justify-content: center;">
          <button class="btn secondary small" id="exportJsonBtn">üì• Export JSON</button>
          <button class="btn secondary small" id="exportCsvBtn">üì• Export CSV</button>
        </div>
      </div>
    </div>

    <!-- Efficient Frontier -->
    <div class="card" id="frontier-container" style="display: none;">
      <div class="card-title" style="margin-bottom: var(--space-md);">üìä Efficient Frontier</div>
      <div class="chart-container">
        <canvas id="frontierChart"></canvas>
      </div>
      <div id="frontier-details"></div>
    </div>

    <!-- Comparaison d'algorithmes -->
    <div class="card" id="comparison-container" style="display: none;">
      <div class="card-title" style="margin-bottom: var(--space-md);">üìä Algorithm Comparison</div>
      <table id="comparisonTable" class="comparison-table"></table>
    </div>
  </div>

  <script>
    const API_BASE = (window.globalConfig && globalConfig.get('api_base_url')) || '';
    let weightsChart, frontierChart;
    let currentResults = {};

    // Configuration des algorithmes
    const algorithms = {
      max_sharpe: { name: "Max Sharpe", endpoint: "max_sharpe" },
      black_litterman: { name: "Black-Litterman", endpoint: "black_litterman" },
      risk_parity: { name: "Risk Parity", endpoint: "risk_parity" },
      max_diversification: { name: "Max Diversification", endpoint: "max_diversification" },
      cvar_optimization: { name: "CVaR Optimization", endpoint: "cvar_optimization" },
      efficient_frontier: { name: "Efficient Frontier", endpoint: "efficient_frontier" }
    };

    // Utilitaires
    function formatPct(x) { return (x * 100).toFixed(2) + '%'; }
    function formatPct1(x) { return (x * 100).toFixed(1) + '%'; }
    function formatNum(x) { return x.toFixed(3); }
    function setStatus(msg) {
      document.getElementById('status').textContent = msg || '';
    }

    // Loading states
    function setLoadingState(isLoading) {
      const runBtn = document.getElementById('runBtn');
      const compareBtn = document.getElementById('compareBtn');
      const resetBtn = document.getElementById('resetBtn');

      if (isLoading) {
        runBtn.disabled = true;
        runBtn.innerHTML = '‚è≥ Optimization in progress...';
        compareBtn.disabled = true;
        resetBtn.disabled = true;
      } else {
        runBtn.disabled = false;
        runBtn.innerHTML = 'üöÄ Optimize';
        compareBtn.disabled = false;
        resetBtn.disabled = false;
      }
    }

    // Gestion des onglets d'algorithmes
    function setupAlgorithmTabs() {
      const tabs = document.querySelectorAll('.tab-btn');
      const configs = document.querySelectorAll('.algorithm-config');

      tabs.forEach(tab => {
        tab.addEventListener('click', () => {
          const algorithm = tab.dataset.algorithm;

          // Update active tab
          tabs.forEach(t => t.classList.remove('active'));
          tab.classList.add('active');

          // Show corresponding config
          configs.forEach(c => c.classList.remove('active'));
          document.getElementById(`config-${algorithm}`).classList.add('active');
        });
      });
    }

    // Validation des param√®tres
    function validateParameters(algorithm) {
      const errors = [];

      // Validation inputs communs
      const lookback = parseInt(document.getElementById('lookback').value);
      if (isNaN(lookback) || lookback < 30 || lookback > 2000) {
        errors.push("History must be between 30 and 2000 days");
      }

      const minUsd = parseFloat(document.getElementById('minusd').value);
      if (isNaN(minUsd) || minUsd < 0 || minUsd > 100000) {
        errors.push("Minimum amount must be between 0 and 100,000 USD");
      }

      const riskFreeRate = parseFloat(document.getElementById('risk-free-rate').value);
      if (isNaN(riskFreeRate) || riskFreeRate < 0 || riskFreeRate > 10) {
        errors.push("Risk-free rate must be between 0% and 10%");
      }

      // Validation sp√©cifique Black-Litterman
      if (algorithm === 'black_litterman') {
        try {
          const views = JSON.parse(document.getElementById('market-views').value);
          const confidence = JSON.parse(document.getElementById('view-confidence').value);

          if (Object.keys(views).length === 0) {
            errors.push("At least one market view is required");
          }

          for (const [asset, ret] of Object.entries(views)) {
            if (typeof ret !== 'number' || ret < -1 || ret > 2) {
              errors.push(`Invalid return for ${asset}: ${ret}`);
            }
          }

          for (const [asset, conf] of Object.entries(confidence)) {
            if (typeof conf !== 'number' || conf < 0 || conf > 1) {
              errors.push(`Invalid confidence for ${asset}: ${conf}`);
            }
          }
        } catch (e) {
          errors.push("Invalid JSON format for market views");
        }
      }

      return errors;
    }

    // Optimisation principale
    async function runOptimization() {
      const activeTab = document.querySelector('.tab-btn.active');
      const algorithm = activeTab.dataset.algorithm;

      // Validation
      const errors = validateParameters(algorithm);
      if (errors.length > 0) {
        setStatus('Validation error');
        showError(errors.join('; '));
        return;
      }

      // Loading state
      setLoadingState(true);
      setStatus(`Optimization ${algorithms[algorithm].name} in progress...`);

      try {
        // Parameters de base
        const baseParams = {
          source: document.getElementById('source').value,
          min_usd: parseFloat(document.getElementById('minusd').value),
          min_history_days: 365,
          lookback_days: parseInt(document.getElementById('lookback').value),
          risk_free_rate: parseFloat(document.getElementById('risk-free-rate').value) / 100
        };

        let requestBody = {
          objective: algorithms[algorithm].endpoint,
          expected_return_method: 'mean_reversion',
          include_current_weights: true
        };

        // Parameters sp√©cifiques par algorithme
        if (algorithm === 'black_litterman') {
          requestBody.market_views = JSON.parse(document.getElementById('market-views').value);
          requestBody.view_confidence = JSON.parse(document.getElementById('view-confidence').value);
        } else if (algorithm === 'risk_parity') {
          const targetVol = document.getElementById('target-vol-rp').value;
          if (targetVol) {
            requestBody.target_volatility = parseFloat(targetVol) / 100;
          }
        } else if (algorithm === 'max_diversification') {
          requestBody.min_diversification_ratio = parseFloat(document.getElementById('min-div-ratio').value);
          requestBody.max_correlation_exposure = parseFloat(document.getElementById('max-corr-exp').value);
        } else if (algorithm === 'cvar_optimization') {
          requestBody.confidence_level = parseFloat(document.getElementById('confidence-level').value) / 100;
          requestBody.cvar_weight = parseFloat(document.getElementById('cvar-weight').value);
        } else if (algorithm === 'efficient_frontier') {
          requestBody.n_points = parseInt(document.getElementById('frontier-points').value);
          requestBody.include_current = document.getElementById('show-current').value === 'true';
        }

        // Constraints
        if (algorithm !== 'efficient_frontier') {
          requestBody.constraints = {
            max_weight: parseFloat(document.getElementById('max-weight-sharpe')?.value || 35) / 100,
            max_sector_weight: parseFloat(document.getElementById('max-sector-sharpe')?.value || 60) / 100
          };
        }

        const params = new URLSearchParams(baseParams);
        const url = `${API_BASE}/api/portfolio/optimization/optimize-advanced?${params.toString()}`;

        // Multi-tenant: utiliser le user actif
        const activeUser = localStorage.getItem('activeUser') || 'demo';

        const response = await fetch(url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-User': activeUser
          },
          body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const result = await response.json();
        if (!result.success) {
          throw new Error(result.error || 'Optimization failed');
        }

        currentResults[algorithm] = result;

        if (algorithm === 'efficient_frontier') {
          displayFrontierResults(result);
        } else {
          displayOptimizationResults(result, algorithm);
        }

        setStatus('‚úÖ Optimization completed successfully');

      } catch (error) {
        (window.debugLogger || console).error('Optimization error:', error);
        setStatus('‚ùå Optimization error');
        showError(`Error: ${error.message}`);
      } finally {
        setLoadingState(false);
      }
    }

    // Affichage des r√©sultats d'optimisation
    function displayOptimizationResults(result, algorithm) {
      // Validation robuste des r√©sultats
      if (!result || !result.weights || typeof result.weights !== 'object') {
        (window.debugLogger || console).error('Invalid optimization result: missing or invalid weights', result);
        showError('Invalid optimization result: missing weight data');
        return;
      }

      // V√©rifier que weights n'est pas vide
      if (Object.keys(result.weights).length === 0) {
        (window.debugLogger || console).warn('Optimization result has empty weights');
        showError('Optimization produced no weights (empty portfolio)');
        return;
      }

      document.getElementById('results-container').style.display = 'grid';
      document.getElementById('frontier-container').style.display = 'none';

      // Graphique des poids (avec comparaison si current_weights disponible)
      renderWeightsChart(result.weights, result.current_weights);
      renderWeightsTable(result.weights, result.current_weights);

      // KPIs
      renderKPIs(result, algorithm);

      // Trades de r√©√©quilibrage
      renderTrades(result.rebalancing_trades || []);
    }

    // Affichage fronti√®re efficiente
    function displayFrontierResults(result) {
      document.getElementById('results-container').style.display = 'none';
      document.getElementById('frontier-container').style.display = 'block';

      renderFrontierChart(result.efficient_frontier);
    }

    function renderWeightsChart(weights, currentWeights) {
      // Validation robuste
      if (!weights || typeof weights !== 'object') {
        (window.debugLogger || console).warn('renderWeightsChart: weights is invalid', weights);
        return;
      }

      // Check Chart.js disponible
      if (typeof Chart === 'undefined') {
        console.error('Chart.js not loaded - cannot render chart');
        showError('Chart.js library not loaded');
        return;
      }

      const ctx = document.getElementById('weightsChart');
      if (weightsChart) weightsChart.destroy();

      // Si current_weights disponible, afficher bar chart comparatif
      if (currentWeights && Object.keys(currentWeights).length > 0) {
        // Cr√©er union de tous les assets (optimal + current)
        const allAssets = new Set([
          ...Object.keys(weights || {}),
          ...Object.keys(currentWeights || {})
        ]);

        const labels = Array.from(allAssets).sort((a, b) => {
          const aWeight = (weights[a] || 0) + (currentWeights[a] || 0);
          const bWeight = (weights[b] || 0) + (currentWeights[b] || 0);
          return bWeight - aWeight;
        }).filter(asset => {
          return (weights[asset] || 0) > 0.001 || (currentWeights[asset] || 0) > 0.001;
        });

        const optimalData = labels.map(asset => (weights[asset] || 0) * 100);
        const currentData = labels.map(asset => (currentWeights[asset] || 0) * 100);

        weightsChart = new Chart(ctx, {
          type: 'bar',
          data: {
            labels,
            datasets: [
              {
                label: 'Allocation Actuelle',
                data: currentData,
                backgroundColor: 'rgba(255, 159, 64, 0.7)',
                borderColor: 'rgba(255, 159, 64, 1)',
                borderWidth: 1
              },
              {
                label: 'Optimal Allocation',
                data: optimalData,
                backgroundColor: 'rgba(54, 162, 235, 0.7)',
                borderColor: 'rgba(54, 162, 235, 1)',
                borderWidth: 1
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: {
                beginAtZero: true,
                title: { display: true, text: 'Weight (%)' },
                grid: { color: 'var(--theme-border)' }
              },
              x: {
                grid: { display: false }
              }
            },
            plugins: {
              legend: { display: true, position: 'top' },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    return `${context.dataset.label}: ${context.parsed.y.toFixed(2)}%`;
                  }
                }
              }
            }
          }
        });
      } else {
        // Sinon, afficher doughnut chart classique
        const entries = Object.entries(weights || {})
          .filter(([_, w]) => w > 0.001)
          .sort((a, b) => b[1] - a[1]);

        const labels = entries.map(e => e[0]);
        const data = entries.map(e => e[1] * 100);
        const colors = labels.map((_, i) => `hsl(${(i * 137.5) % 360} 70% 55%)`);

        weightsChart = new Chart(ctx, {
          type: 'doughnut',
          data: {
            labels,
            datasets: [{
              data,
              backgroundColor: colors,
              borderWidth: 2,
              borderColor: getComputedStyle(document.documentElement).getPropertyValue('--theme-surface')
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                position: 'bottom',
                labels: {
                  usePointStyle: true,
                  padding: 15
                }
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    return `${context.label}: ${context.parsed.toFixed(1)}%`;
                  }
                }
              }
            }
          }
        });
      }
    }

    function renderWeightsTable(weights, currentWeights) {
      // Validation robuste
      if (!weights || typeof weights !== 'object') {
        (window.debugLogger || console).warn('renderWeightsTable: weights is invalid', weights);
        return;
      }

      // Union de tous les assets
      const allAssets = new Set([
        ...Object.keys(weights || {}),
        ...Object.keys(currentWeights || {})
      ]);

      const entries = Array.from(allAssets)
        .filter(asset => (weights[asset] || 0) > 0.001 || (currentWeights?.[asset] || 0) > 0.001)
        .map(asset => ({
          symbol: asset,
          optimal: weights[asset] || 0,
          current: currentWeights?.[asset] || 0,
          delta: (weights[asset] || 0) - (currentWeights?.[asset] || 0)
        }))
        .sort((a, b) => b.optimal - a.optimal);

      const table = document.getElementById('weightsTable');
      const hasCurrent = currentWeights && Object.keys(currentWeights).length > 0;

      const headers = hasCurrent
        ? '<tr><th>Asset</th><th>Actuel</th><th>Optimal</th><th>Delta</th></tr>'
        : '<tr><th>Asset</th><th>Allocation</th></tr>';

      const rows = entries.map(entry => {
        if (hasCurrent) {
          const deltaClass = entry.delta > 0 ? 'pos' : entry.delta < 0 ? 'neg' : '';
          const deltaSign = entry.delta > 0 ? '+' : '';
          return `<tr>
            <td>${entry.symbol}</td>
            <td>${formatPct(entry.current)}</td>
            <td>${formatPct(entry.optimal)}</td>
            <td style="color: var(--${deltaClass})">${deltaSign}${formatPct(entry.delta)}</td>
          </tr>`;
        } else {
          return `<tr><td>${entry.symbol}</td><td>${formatPct(entry.optimal)}</td></tr>`;
        }
      }).join('');

      table.innerHTML = `
        <thead>${headers}</thead>
        <tbody>${rows}</tbody>
      `;
    }

    function renderKPIs(result, algorithm) {
      const kpis = document.getElementById('kpis');
      const baseKPIs = [
        { label: 'Expected Return', value: formatPct(result.expected_return) },
        { label: 'Volatility', value: formatPct(result.volatility) },
        { label: 'Sharpe Ratio', value: formatNum(result.sharpe_ratio) },
        { label: 'Diversification Ratio', value: formatNum(result.diversification_ratio) },
        { label: 'Optimization Score', value: formatNum(result.optimization_score) },
        { label: 'Constraints OK', value: result.constraints_satisfied ? '‚úÖ' : '‚ö†Ô∏è' }
      ];

      // KPIs sp√©cifiques par algorithme
      const additionalKPIs = [];
      if (result.max_drawdown) {
        additionalKPIs.push({ label: 'Max Drawdown', value: formatPct(Math.abs(result.max_drawdown)) });
      }
      if (result.var_95) {
        additionalKPIs.push({ label: 'VaR 95%', value: formatPct(Math.abs(result.var_95)) });
      }
      if (result.cvar_95) {
        additionalKPIs.push({ label: 'CVaR 95%', value: formatPct(Math.abs(result.cvar_95)) });
      }

      const allKPIs = [...baseKPIs, ...additionalKPIs];
      kpis.innerHTML = allKPIs.map(kpi =>
        `<div class="kpi">
          <div class="label">${kpi.label}</div>
          <div class="value">${kpi.value}</div>
        </div>`
      ).join('');

      // Metrics additionnelles
      const additionalDiv = document.getElementById('additional-metrics');
      let additionalHTML = '';

      if (result.risk_contributions) {
        const topRisks = Object.entries(result.risk_contributions)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 5);

        additionalHTML += `
          <h4 style="margin: 1rem 0 0.5rem 0;">üéØ Top 5 Risk Contributions</h4>
          <div class="grid-3">
            ${topRisks.map(([asset, contrib]) =>
              `<div class="kpi">
                <div class="label">${asset}</div>
                <div class="value">${formatPct1(contrib)}</div>
              </div>`
            ).join('')}
          </div>
        `;
      }

      if (result.sector_exposures) {
        additionalHTML += `
          <h4 style="margin: 1rem 0 0.5rem 0;">üè¢ Sector Exposures</h4>
          <div class="grid-3">
            ${Object.entries(result.sector_exposures).map(([sector, expo]) =>
              `<div class="kpi">
                <div class="label">${sector}</div>
                <div class="value">${formatPct1(expo)}</div>
              </div>`
            ).join('')}
          </div>
        `;
      }

      additionalDiv.innerHTML = additionalHTML;
    }

    function renderTrades(trades) {
      const table = document.getElementById('tradesTable');
      if (!trades || !trades.length) {
        table.innerHTML = '<tr><td colspan="4" style="text-align: center; color: var(--theme-text-muted);">No rebalancing needed</td></tr>';
        return;
      }

      const rows = trades.map(trade => {
        const deltaField = trade.delta || trade.weight_change || 0;
        const actionClass = deltaField > 0 ? 'pos' : deltaField < 0 ? 'neg' : '';

        return `<tr>
          <td>${trade.symbol || trade.asset || '-'}</td>
          <td>${trade.action || (deltaField > 0 ? 'Buy' : 'Sell')}</td>
          <td style="color: var(--${actionClass})">${formatPct1(Math.abs(deltaField))}</td>
          <td>${trade.amount_usd ? '$' + trade.amount_usd.toLocaleString() : '-'}</td>
        </tr>`;
      }).join('');

      table.innerHTML = `
        <thead>
          <tr><th>Asset</th><th>Action</th><th>Delta</th><th>Amount</th></tr>
        </thead>
        <tbody>${rows}</tbody>
      `;
    }

    function renderFrontierChart(frontierData) {
      // Check Chart.js disponible
      if (typeof Chart === 'undefined') {
        console.error('Chart.js not loaded - cannot render chart');
        showError('Chart.js library not loaded');
        return;
      }

      const ctx = document.getElementById('frontierChart');

      if (frontierChart) frontierChart.destroy();
      frontierChart = new Chart(ctx, {
        type: 'scatter',
        data: {
          datasets: [{
            label: 'Efficient Frontier',
            data: frontierData.risks.map((risk, i) => ({
              x: risk * 100,
              y: frontierData.returns[i] * 100
            })),
            borderColor: 'var(--brand-primary)',
            backgroundColor: 'var(--brand-primary)',
            borderWidth: 2,
            pointRadius: 4
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              title: { display: true, text: 'Volatility (%)' },
              grid: { color: 'var(--theme-border)' }
            },
            y: {
              title: { display: true, text: 'Expected Return (%)' },
              grid: { color: 'var(--theme-border)' }
            }
          },
          plugins: {
            legend: { display: true },
            tooltip: {
              callbacks: {
                label: function(context) {
                  return `Vol: ${context.parsed.x.toFixed(1)}%, Ret: ${context.parsed.y.toFixed(1)}%`;
                }
              }
            }
          }
        }
      });
    }

    // Comparaison d'algorithmes
    async function compareAlgorithms() {
      // Loading state
      const compareBtn = document.getElementById('compareBtn');
      const runBtn = document.getElementById('runBtn');
      const resetBtn = document.getElementById('resetBtn');

      compareBtn.disabled = true;
      compareBtn.innerHTML = '‚è≥ Comparison in progress...';
      runBtn.disabled = true;
      resetBtn.disabled = true;

      setStatus('Comparing algorithms...');
      document.getElementById('comparison-container').style.display = 'block';

      const compareList = ['max_sharpe', 'risk_parity', 'max_diversification'];
      const results = {};

      try {
        for (const algo of compareList) {
          try {
            const baseParams = {
              source: document.getElementById('source').value,
              min_usd: parseFloat(document.getElementById('minusd').value),
              lookback_days: parseInt(document.getElementById('lookback').value)
            };

            const requestBody = {
              objective: algorithms[algo].endpoint,
              expected_return_method: 'mean_reversion',
              include_current_weights: true
            };

            const params = new URLSearchParams(baseParams);
            const url = `${API_BASE}/api/portfolio/optimization/optimize-advanced?${params.toString()}`;

            const activeUser = localStorage.getItem('activeUser') || 'demo';

            const response = await fetch(url, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'X-User': activeUser
              },
              body: JSON.stringify(requestBody)
            });

            if (response.ok) {
              const result = await response.json();
              if (result.success) {
                results[algo] = result;
              }
            }
          } catch (e) {
            (window.debugLogger || console).warn(`Failed to optimize ${algo}:`, e);
          }
        }

        renderComparisonTable(results);
        setStatus('‚úÖ Comparison completed');
      } finally {
        // R√©activer boutons
        compareBtn.disabled = false;
        compareBtn.innerHTML = 'üìä Compare Algorithms';
        runBtn.disabled = false;
        resetBtn.disabled = false;
      }
    }

    function renderComparisonTable(results) {
      const table = document.getElementById('comparisonTable');
      const metrics = ['expected_return', 'volatility', 'sharpe_ratio', 'diversification_ratio'];

      let html = `
        <thead>
          <tr>
            <th>Metric</th>
            ${Object.keys(results).map(algo => `<th>${algorithms[algo].name}</th>`).join('')}
          </tr>
        </thead>
        <tbody>
      `;

      metrics.forEach(metric => {
        html += '<tr>';
        html += `<td><strong>${getMetricLabel(metric)}</strong></td>`;

        Object.keys(results).forEach(algo => {
          const value = results[algo][metric];
          const formattedValue = metric.includes('ratio') ? formatNum(value) : formatPct(value);
          html += `<td>${formattedValue}</td>`;
        });

        html += '</tr>';
      });

      html += '</tbody>';
      table.innerHTML = html;
    }

    function getMetricLabel(metric) {
      const labels = {
        expected_return: 'Expected Return',
        volatility: 'Volatility',
        sharpe_ratio: 'Sharpe Ratio',
        diversification_ratio: 'Diversification Ratio'
      };
      return labels[metric] || metric;
    }

    // Export r√©sultats
    function exportResults(format) {
      const activeTab = document.querySelector('.tab-btn.active');
      const algorithm = activeTab.dataset.algorithm;
      const result = currentResults[algorithm];

      if (!result) {
        showError('No results to export. Run an optimization first.');
        return;
      }

      const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
      const filename = `optimization_${algorithm}_${timestamp}`;

      if (format === 'json') {
        const blob = new Blob([JSON.stringify(result, null, 2)], { type: 'application/json' });
        downloadBlob(blob, `${filename}.json`);
      } else if (format === 'csv') {
        const csv = convertToCSV(result);
        const blob = new Blob([csv], { type: 'text/csv' });
        downloadBlob(blob, `${filename}.csv`);
      }
    }

    function convertToCSV(result) {
      let csv = 'Asset,Weight,Current Weight,Delta\n';

      // Allocation
      if (result.weights) {
        Object.entries(result.weights).forEach(([asset, weight]) => {
          const current = result.current_weights?.[asset] || 0;
          const delta = weight - current;
          csv += `${asset},${weight.toFixed(4)},${current.toFixed(4)},${delta.toFixed(4)}\n`;
        });
      }

      // Metrics
      csv += '\n\nMetrics\n';
      csv += `Expected Return,${result.expected_return || 0}\n`;
      csv += `Volatility,${result.volatility || 0}\n`;
      csv += `Sharpe Ratio,${result.sharpe_ratio || 0}\n`;
      csv += `Diversification Ratio,${result.diversification_ratio || 0}\n`;

      return csv;
    }

    function downloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    // Fonctions utilitaires
    function showError(message) {
      const errorDiv = document.createElement('div');
      errorDiv.className = 'error';
      errorDiv.textContent = message;

      const actions = document.querySelector('.actions');
      actions.parentNode.insertBefore(errorDiv, actions.nextSibling);

      setTimeout(() => errorDiv.remove(), 5000);
    }

    function resetForm() {
      // Reset form values
      document.getElementById('source').value = 'cointracking';
      document.getElementById('lookback').value = '365';
      document.getElementById('minusd').value = '100';
      document.getElementById('risk-free-rate').value = '2.0';

      // Reset algorithm-specific fields
      document.getElementById('max-weight-sharpe').value = '35';
      document.getElementById('market-views').value = '{"BTC": 0.15, "ETH": 0.12, "SOL": 0.20}';
      document.getElementById('view-confidence').value = '{"BTC": 0.8, "ETH": 0.6, "SOL": 0.7}';

      // Hide results
      document.getElementById('results-container').style.display = 'none';
      document.getElementById('frontier-container').style.display = 'none';
      document.getElementById('comparison-container').style.display = 'none';

      // Reset charts
      if (weightsChart) weightsChart.destroy();
      if (frontierChart) frontierChart.destroy();

      setStatus('');
      currentResults = {};
    }

    // Persistence param√®tres
    function saveParameters() {
      const params = {
        source: document.getElementById('source').value,
        lookback: document.getElementById('lookback').value,
        minusd: document.getElementById('minusd').value,
        riskFreeRate: document.getElementById('risk-free-rate').value,
        maxWeightSharpe: document.getElementById('max-weight-sharpe').value,
        maxSectorSharpe: document.getElementById('max-sector-sharpe').value,
        // Black-Litterman
        marketViews: document.getElementById('market-views').value,
        viewConfidence: document.getElementById('view-confidence').value,
        // Risk Parity
        targetVolRp: document.getElementById('target-vol-rp').value,
        // Max Diversification
        minDivRatio: document.getElementById('min-div-ratio').value,
        maxCorrExp: document.getElementById('max-corr-exp').value,
        // CVaR
        confidenceLevel: document.getElementById('confidence-level').value,
        cvarWeight: document.getElementById('cvar-weight').value,
        // Efficient Frontier
        frontierPoints: document.getElementById('frontier-points').value,
        showCurrent: document.getElementById('show-current').value
      };
      localStorage.setItem('optimization_params', JSON.stringify(params));
    }

    function loadParameters() {
      const saved = localStorage.getItem('optimization_params');
      if (!saved) return;

      try {
        const params = JSON.parse(saved);

        // Parameters de base
        if (params.source) document.getElementById('source').value = params.source;
        if (params.lookback) document.getElementById('lookback').value = params.lookback;
        if (params.minusd) document.getElementById('minusd').value = params.minusd;
        if (params.riskFreeRate) document.getElementById('risk-free-rate').value = params.riskFreeRate;

        // Max Sharpe
        if (params.maxWeightSharpe) document.getElementById('max-weight-sharpe').value = params.maxWeightSharpe;
        if (params.maxSectorSharpe) document.getElementById('max-sector-sharpe').value = params.maxSectorSharpe;

        // Black-Litterman
        if (params.marketViews) document.getElementById('market-views').value = params.marketViews;
        if (params.viewConfidence) document.getElementById('view-confidence').value = params.viewConfidence;

        // Risk Parity
        if (params.targetVolRp) document.getElementById('target-vol-rp').value = params.targetVolRp;

        // Max Diversification
        if (params.minDivRatio) document.getElementById('min-div-ratio').value = params.minDivRatio;
        if (params.maxCorrExp) document.getElementById('max-corr-exp').value = params.maxCorrExp;

        // CVaR
        if (params.confidenceLevel) document.getElementById('confidence-level').value = params.confidenceLevel;
        if (params.cvarWeight) document.getElementById('cvar-weight').value = params.cvarWeight;

        // Efficient Frontier
        if (params.frontierPoints) document.getElementById('frontier-points').value = params.frontierPoints;
        if (params.showCurrent) document.getElementById('show-current').value = params.showCurrent;

        (window.debugLogger || console).log('Parameters charg√©s depuis localStorage');
      } catch (e) {
        (window.debugLogger || console).warn('√âchec du chargement des param√®tres:', e);
      }
    }

    // Event listeners
    document.addEventListener('DOMContentLoaded', () => {
      setupAlgorithmTabs();

      // Charger param√®tres sauvegard√©s
      loadParameters();

      // Event listeners boutons
      document.getElementById('runBtn').addEventListener('click', runOptimization);
      document.getElementById('compareBtn').addEventListener('click', compareAlgorithms);
      document.getElementById('resetBtn').addEventListener('click', resetForm);
      document.getElementById('exportJsonBtn').addEventListener('click', () => exportResults('json'));
      document.getElementById('exportCsvBtn').addEventListener('click', () => exportResults('csv'));

      // Sauvegarder param√®tres √† chaque modification
      const inputs = document.querySelectorAll('input, select, textarea');
      inputs.forEach(input => {
        input.addEventListener('change', saveParameters);
      });

      // Validation JSON temps r√©el
      const jsonTextareas = ['market-views', 'view-confidence'];
      jsonTextareas.forEach(id => {
        const textarea = document.getElementById(id);
        if (textarea) {
          textarea.addEventListener('input', (e) => {
            try {
              JSON.parse(e.target.value);
              e.target.style.borderColor = 'var(--pos)';
              e.target.style.borderWidth = '2px';
            } catch {
              e.target.style.borderColor = 'var(--danger)';
              e.target.style.borderWidth = '2px';
            }
          });
        }
      });

      // Auto-run demo
      if (new URLSearchParams(location.search).get('autorun') === '1') {
        setTimeout(runOptimization, 1000);
      }
    });
  </script>
</body>

</html>