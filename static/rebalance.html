<!DOCTYPE html>
<html lang="fr">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Crypto Rebalancer</title>
  <link rel="stylesheet" href="shared-theme.css">
  <link rel="stylesheet" href="theme-compat.css">
  <script type="module" src="components/nav.js"></script>

  <script src="debug-logger.js"></script>
  <script src="input-validator.js"></script>
  <script src="performance-optimizer.js"></script>
  <script src="global-config.js"></script>
  <script src="appearance.js"></script>
  <style>
    /* Onglets locaux (Rebalancing / Optimization) */
    .tabs {
      display: flex;
      gap: .5rem;
      align-items: center;
      padding: .75rem 0;
    }

    .tab-btn {
      padding: .5rem .75rem;
      border: 1px solid var(--theme-border);
      background: var(--theme-surface);
      color: var(--theme-text);
      border-radius: var(--radius-sm);
      cursor: pointer;
    }

    .tab-btn.active {
      border-color: var(--brand-primary);
      color: var(--brand-primary);
      background: color-mix(in oklab, var(--brand-primary) 10%, transparent);
    }

    .tab-panel {
      display: none;
    }

    .tab-panel.active {
      display: block;
    }

    * {
      box-sizing: border-box
    }

    body {
      margin: 0;
      background: var(--theme-background);
      color: var(--theme-text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif
    }

    header {
      position: sticky;
      top: 0;
      background: var(--theme-surface-elevated);
      backdrop-filter: blur(6px);
      border-bottom: 1px solid var(--theme-border);
      z-index: 10
    }

    .wrap {
      width: 100%;
      max-width: 95vw;
      margin: 0 auto;
      padding: 0 var(--space-lg);
    }

    @media (max-width: 768px) {
      .wrap {
        padding: 0 var(--space-md);
      }
    }

    h1 {
      margin: 0 0 8px 0;
      font-size: 20px
    }

    .row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center
    }

    label {
      font-size: 12px;
      color: var(--theme-text-muted)
    }

    input,
    select,
    button,
    textarea {
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid var(--theme-border);
      background: var(--theme-surface);
      color: var(--theme-text)
    }

    button {
      cursor: pointer
    }

    .btn {
      background: var(--brand-primary);
      color: white;
      font-weight: 700;
      border: 0
    }

    .btn.secondary {
      background: var(--theme-surface-elevated);
      color: var(--theme-text);
      border: 1px solid var(--theme-border)
    }

    .btn.ghost {
      background: transparent;
      border: 1px dashed var(--theme-border);
      color: var(--theme-text-muted)
    }

    .btn.small {
      padding: 6px 8px;
      font-size: 12px;
      border-radius: 8px
    }

    .card {
      background: var(--theme-surface);
      border: 1px solid var(--theme-border);
      border-radius: var(--radius-lg);
      padding: var(--space-md)
    }

    .muted {
      color: var(--theme-text-muted)
    }

    table {
      width: 100%;
      border-collapse: collapse
    }

    th,
    td {
      border-bottom: 1px solid var(--theme-border);
      padding: 6px 8px;
      text-align: left;
      font-size: 13px;
      color: var(--theme-text)
    }

    th {
      color: var(--theme-text-muted);
      font-weight: 600
    }

    tr:hover td {
      background: var(--theme-surface-hover)
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid var(--theme-border);
      background: var(--theme-surface-elevated);
      font-size: 12px
    }

    .right {
      text-align: right
    }

    .small {
      font-size: 12px
    }

    .mt8 {
      margin-top: 8px
    }

    .mt16 {
      margin-top: 16px
    }

    .grid {
      display: grid;
      gap: 10px
    }

    @media(min-width:900px) {
      .grid.g2 {
        grid-template-columns: repeat(2, 1fr)
      }

      .grid.g3 {
        grid-template-columns: repeat(3, 1fr)
      }
    }

    /* Styles pour les cartes de strat√©gies */
    .strategy-card {
      border: 2px solid var(--theme-border);
      border-radius: var(--radius-md);
      padding: var(--space-lg);
      cursor: pointer;
      transition: all var(--transition-normal);
      background: var(--theme-surface);
    }

    .strategy-card:hover {
      border-color: var(--brand-primary);
      background: var(--theme-surface-hover);
    }

    .strategy-card.selected {
      border-color: var(--brand-primary) !important;
      background: var(--brand-primary-subtle) !important;
      box-shadow: var(--shadow-lg);
    }

    .strategy-card.dynamic-strategy.selected {
      border: 3px solid var(--brand-primary) !important;
      background: linear-gradient(135deg, var(--brand-primary-subtle), var(--warning-bg)) !important;
      box-shadow: 0 0 0 2px var(--brand-primary-subtle);
    }

    .strategy-card.placeholder-strategy.selected {
      border: 3px solid var(--brand-primary) !important;
      background: var(--brand-primary-subtle) !important;
      opacity: 1 !important;
    }

    .strategy-card.error-strategy.selected {
      border: 3px solid var(--brand-primary) !important;
      background: linear-gradient(135deg, var(--brand-primary-subtle), var(--danger-bg)) !important;
    }

    .strategy-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .strategy-title {
      font-weight: 700;
      font-size: 16px;
    }

    .strategy-risk {
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 6px;
      font-weight: 600;
    }

    .risk-faible {
      background: var(--success);
      color: white;
    }

    .risk-moyen {
      background: var(--warning);
      color: white;
    }

    .risk-lev {
      background: var(--danger);
      color: white;
    }

    .risk-faible-moyen {
      background: var(--success);
      color: white;
    }

    .risk-trsfaible {
      background: #22c55e;
      color: white;
    }

    .risk-trslev {
      background: #dc2626;
      color: white;
    }

    .strategy-allocations {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 8px;
    }

    .allocation-pill {
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 6px;
      background: var(--brand-primary-subtle);
      border: 1px solid var(--brand-primary);
      color: var(--brand-primary);
    }

    @media(min-width: 768px) {
      #strategies-container {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    @media(min-width: 1200px) {
      #strategies-container {
        grid-template-columns: repeat(3, 1fr);
      }
    }

    .delta-pos {
      color: var(--success)
    }

    .delta-neg {
      color: var(--danger)
    }

    .badge {
      font-weight: 700
    }

    .legend {
      display: flex;
      gap: 10px;
      flex-wrap: wrap
    }

    .dot {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 2px;
      margin-right: 4px
    }

    /* Notifications stylis√©es */
    .notification {
      position: fixed;
      bottom: 20px;
      right: 20px;
      padding: 12px 16px;
      border-radius: var(--radius-md);
      font-size: 14px;
      z-index: 1000;
      background: var(--theme-surface);
      border: 1px solid var(--theme-border);
      box-shadow: var(--shadow-lg);
      animation: slideIn 0.3s ease-out;
      color: var(--theme-text);
    }

    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }

      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    .notification.success {
      border-left: 4px solid var(--success);
    }

    .notification.error {
      border-left: 4px solid var(--danger);
    }
  </style>

  <script type="module" src="components/tooltips.js"></script>
</head>

<body>

  <div class="wrap" style="padding-top: var(--space-lg);">
    <!-- Strat√©gies de Rebalancing -->
    <div class="card" style="margin-bottom: 16px;">
      <h3 style="cursor: pointer; display: flex; align-items: center; justify-content: space-between;"
        onclick="toggleStrategiesSection()">
        <span>üéØ Strat√©gies Pr√©d√©finies</span>
        <span id="strategies-toggle" style="transition: transform 0.3s;">‚ñº</span>
      </h3>
      <div id="strategies-content">
        <div id="strategies-container" style="display: grid; gap: 12px; margin-top: 12px;">
          <div style="text-align: center; padding: 20px; color: var(--theme-text-muted);">
            Chargement des strat√©gies...
          </div>
        </div>
        <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--theme-border);">
          <div class="row">
            <button id="apply-strategy-btn" class="btn small" style="background: var(--success);" disabled>
              ‚úÖ Appliquer la Strat√©gie
            </button>
            <button id="reset-strategy-btn" class="btn small secondary">
              üîÑ Reset Manuel
            </button>
            <button id="refresh-dynamic-btn" class="btn small" style="background: var(--warning);"
              onclick="window.refreshDynamicStrategy()">
              üéØ Sync CCS
            </button>
            <div style="flex-grow: 1;"></div>
            <span id="selected-strategy-info" class="pill" style="display: none;">
              Aucune strat√©gie s√©lectionn√©e
            </span>
          </div>
        </div>
      </div>
    </div>

    <!-- Actions et Export -->
    <div class="card" style="margin-bottom: 16px;">
      <div class="row">
        <div style="align-self:flex-end">
          <button id="btnCsv" class="btn secondary" disabled>T√©l√©charger CSV</button>
          <button id="btnJson" class="btn secondary" disabled>Export JSON</button>
          <button id="btnCopyJson" class="btn secondary" disabled>üìã Copier JSON</button>
        </div>
        <div style="align-self:flex-end;margin-left:auto;display:flex;gap:8px;flex-wrap:wrap">
          <span id="dynamicTargetsIndicator" class="pill" style="background:var(--warning);color:white;display:none;">üéØ
            Targets dynamiques</span>
          <span id="total" class="pill">Total : ‚Äî</span>
          <span id="status" class="pill">Pr√™t.</span>
        </div>
      </div>
    </div>
  </div>

  <div class="wrap">
    <div class="tabs" id="rebalance-tabs">
      <button class="tab-btn active" data-target="#rebalance-tab">Rebalancing</button>
      <button class="tab-btn" data-target="#optimization-tab">Optimization</button>
    </div>
  </div>

  <main class="wrap tab-panel active" id="rebalance-tab">
    <!-- Donuts -->
    <section class="card">
      <h3>R√©partition</h3>
      <div class="grid g2">
        <div>
          <div class="small muted">Actuelle</div>
          <div id="donutCurrent"></div>
        </div>
        <div>
          <div class="small muted">Cible</div>
          <div id="donutTarget"></div>
        </div>
      </div>
      <div id="legend" class="legend mt8"></div>
    </section>

    <!-- R√©sum√© -->
    <section class="card mt16">
      <h3>R√©sum√© par groupe</h3>
      <div id="summary" class="grid g3 mt8"></div>
    </section>

    <!-- Actions -->
    <section class="card mt16">
      <div class="row" style="justify-content:space-between;align-items:flex-end">
        <h3>Actions</h3>
        <div id="pricing-badge"></div>
      </div>
      <div style="overflow:auto;max-height:50vh;border:1px solid var(--theme-border);border-radius:var(--radius-md)">
        <table id="tblActions">
          <thead>
            <tr>
              <th>group</th>
              <th>alias</th>
              <th>symbol</th>
              <th>action</th>
              <th class="right">usd</th>
              <th class="right">est_quantity</th>
              <th class="right">price_used</th>
              <th>location</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </section>

    <!-- Unknown aliases -->
    <section class="card mt16">
      <div class="row" style="justify-content:space-between;align-items:flex-end">
        <div>
          <h3>Unknown aliases</h3>
          <div class="small">Par d√©faut, <strong>Others</strong> est pr√©s√©lectionn√©.</div>
        </div>
        <div style="display:flex;gap:12px;align-items:flex-end">
          <div>
            <label class="small">Tout vers</label><br />
            <select id="bulk_group">
              <option value="BTC">BTC</option>
              <option value="ETH">ETH</option>
              <option value="Stablecoins">Stablecoins</option>
              <option value="SOL">SOL</option>
              <option value="L1/L0 majors">L1/L0 majors</option>
              <option value="L2/Scaling">L2/Scaling</option>
              <option value="DeFi">DeFi</option>
              <option value="AI/Data">AI/Data</option>
              <option value="Gaming/NFT">Gaming/NFT</option>
              <option value="Memecoins">Memecoins</option>
              <option value="Others" selected>Others</option>
            </select>
            <button id="btnBulkAdd" class="btn ghost">Ajouter tout</button>
          </div>
          <div id="alias-manager-button" style="display: none;">
            <button class="btn secondary small" onclick="openAliasManager()"
              title="Ouvrir l'interface de gestion des aliases">
              üè∑Ô∏è Alias Manager
            </button>
          </div>
        </div>
      </div>
      <div id="unknownList" class="small mt16"></div>
    </section>
  </main>

  <section class="wrap tab-panel" id="optimization-tab">
    <div class="card">
      <iframe src="portfolio-optimization.html?nav=off"
        style="width:100%; height:80vh; border:0; background:var(--theme-surface)"></iframe>
    </div>
  </section>

  <script src="/static/global-config.js"></script>
  <script>
    // Gestion des onglets Rebalancing / Optimization
    (function () {
      const tabs = document.querySelectorAll('#rebalance-tabs .tab-btn');
      const panels = [document.querySelector('#rebalance-tab'), document.querySelector('#optimization-tab')];
      tabs.forEach(btn => btn.addEventListener('click', () => {
        tabs.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        panels.forEach(p => p.classList.remove('active'));
        const target = document.querySelector(btn.dataset.target);
        if (target) target.classList.add('active');
      }));
    })();
    /* ---------- Helpers ---------- */
    const $ = sel => document.querySelector(sel);
    const el = id => document.getElementById(id);

    /* ---------- Variables globales pour strat√©gies ---------- */
    let availableStrategies = {};
    let selectedStrategyId = null;

    /* ---------- Fonction de toggle section strat√©gies ---------- */
    function toggleStrategiesSection() {
      const content = el('strategies-content');
      const toggle = el('strategies-toggle');
      const isCollapsed = content.style.display === 'none';

      if (isCollapsed) {
        content.style.display = 'block';
        toggle.style.transform = 'rotate(0deg)';
        toggle.textContent = '‚ñº';
        localStorage.setItem('strategies_section_collapsed', 'false');
      } else {
        content.style.display = 'none';
        toggle.style.transform = 'rotate(-90deg)';
        toggle.textContent = '‚ñ∂';
        localStorage.setItem('strategies_section_collapsed', 'true');
      }
    }

    /* ---------- SUPPRIM√â: Mock CCS Data Generation ---------- */
    function generateMockCCSData_DISABLED() {
      console.error('‚ö†Ô∏è Mock CCS data generation disabled. Use real CCS data from risk-dashboard.');
      return;
      // Ne g√©n√®re les donn√©es mock que si aucune donn√©e r√©cente n'existe
      const existingData = localStorage.getItem('last_targets');
      if (existingData) {
        try {
          const data = JSON.parse(existingData);
          const dataAge = Date.now() - new Date(data.timestamp).getTime();
          // Si les donn√©es sont r√©centes (moins de 2h), ne pas √©craser
          if (dataAge < 2 * 60 * 60 * 1000 && data.source === 'risk-dashboard-ccs') {
            console.debug('üîç CCS data already exists and is recent, skipping mock generation');
            return;
          }
        } catch (error) {
          console.debug('üîç Existing data invalid, will generate mock');
        }
      }

      // G√©n√©rer des donn√©es CCS mock r√©alistes
      const mockCCSData = {
        targets: {
          'BTC': 44.2,
          'ETH': 24.3,
          'Stablecoins': 19.6,
          'L1/L0 majors': 7.1,
          'L2/Scaling': 2.4,
          'DeFi': 1.8,
          'AI/Data': 0.6,
          'Others': 0.0,
          model_version: 'ccs-blended-mock'
        },
        timestamp: new Date().toISOString(),
        strategy: 'Blended CCS* (72) - Mock Data',
        source: 'risk-dashboard-ccs'
      };

      localStorage.setItem('last_targets', JSON.stringify(mockCCSData));
      console.debug('üîç Generated mock CCS data for sync functionality:', mockCCSData);
    }

    /* ---------- Fonction de synchronisation CCS ---------- */
    function syncCCSTargets() {
      const storedTargets = localStorage.getItem('last_targets');
      console.debug('üîç syncCCSTargets - Raw localStorage data:', storedTargets);

      if (!storedTargets) {
        console.log('üîç syncCCSTargets - No localStorage data found');
        return null;
      }

      try {
        const targetsData = JSON.parse(storedTargets);
        console.log('üîç syncCCSTargets - Parsed targets data:', targetsData);
        console.log('üîç syncCCSTargets - Source:', targetsData.source);
        console.log('üîç syncCCSTargets - BTC value:', targetsData.targets?.BTC);
        console.log('üîç syncCCSTargets - ETH value:', targetsData.targets?.ETH);

        if (targetsData.source === 'risk-dashboard-ccs' && targetsData.targets && targetsData.timestamp) {
          // V√©rifier que les donn√©es ne sont pas trop anciennes (2 heures)
          const dataAge = Date.now() - new Date(targetsData.timestamp).getTime();
          const maxAge = 2 * 60 * 60 * 1000; // 2 heures

          console.log('üîç syncCCSTargets - Data age (minutes):', Math.round(dataAge / 60000));

          if (dataAge < maxAge) {
            // Filtrer les targets pour ne garder que les valeurs num√©riques
            const cleanTargets = {};
            Object.entries(targetsData.targets).forEach(([key, value]) => {
              if (typeof value === 'number' && key !== 'model_version') {
                cleanTargets[key] = value;
                console.log(`üîç syncCCSTargets - Adding ${key}: ${value}%`);
              } else {
                console.log(`üîç syncCSSTargets - Skipping ${key}: ${value} (${typeof value})`);
              }
            });

            console.log('üîç syncCCSTargets - Final clean targets:', cleanTargets);
            return {
              targets: cleanTargets,
              strategy: targetsData.strategy,
              timestamp: targetsData.timestamp
            };
          } else {
            console.log('üîç syncCCSTargets - Data too old, ignoring');
          }
        } else {
          console.log('üîç syncCCSTargets - Invalid data structure or wrong source');
        }
      } catch (error) {
        console.error('üîç syncCCSTargets - Error parsing stored targets:', error);
      }

      return null;
    }

    /* ---------- Fonctions Strat√©gies ---------- */
    async function loadStrategies() {
      try {
        // D'abord essayer de charger depuis l'API, mais ne pas √©chouer si non disponible
        let response = null;
        try {
          response = await globalConfig.apiRequest('/api/strategies/list');
        } catch (apiError) {
          console.log('API strategies not available, using built-in strategies:', apiError.message);
        }

        // Utiliser les strat√©gies de l'API si disponibles, sinon utiliser des strat√©gies par d√©faut
        if (response && response.ok && response.strategies) {
          availableStrategies = response.strategies;
        } else {
          // Strat√©gies par d√©faut si l'API n'est pas disponible
          availableStrategies = {
            'conservative': {
              name: 'Conservative',
              icon: 'üõ°Ô∏è',
              description: 'Allocation conservative avec forte composante stablecoin - Id√©al march√© baissier',
              risk_level: 'faible',
              allocations: {
                'BTC': 25.0,
                'ETH': 18.0,
                'Stablecoins': 35.0,
                'SOL': 5.0,
                'L1/L0 majors': 8.0,
                'L2/Scaling': 3.0,
                'DeFi': 2.0,
                'AI/Data': 1.5,
                'Gaming/NFT': 1.0,
                'Memecoins': 0.0,
                'Others': 1.5
              }
            },
            'balanced': {
              name: 'Balanced',
              icon: '‚öñÔ∏è',
              description: 'R√©partition √©quilibr√©e - Approche classique pour march√© stable',
              risk_level: 'moyen',
              allocations: {
                'BTC': 35.0,
                'ETH': 25.0,
                'Stablecoins': 20.0,
                'SOL': 8.0,
                'L1/L0 majors': 7.0,
                'L2/Scaling': 2.5,
                'DeFi': 1.5,
                'AI/Data': 0.5,
                'Gaming/NFT': 0.3,
                'Memecoins': 0.1,
                'Others': 0.1
              }
            },
            'aggressive': {
              name: 'Aggressive',
              icon: 'üöÄ',
              description: 'Forte exposition altcoins - Maximum rendement, maximum risque',
              risk_level: '√©lev√©',
              allocations: {
                'BTC': 30.0,
                'ETH': 25.0,
                'Stablecoins': 10.0,
                'SOL': 15.0,
                'L1/L0 majors': 10.0,
                'L2/Scaling': 4.0,
                'DeFi': 3.0,
                'AI/Data': 1.5,
                'Gaming/NFT': 1.0,
                'Memecoins': 0.3,
                'Others': 0.2
              }
            },
            'defi_focused': {
              name: 'DeFi Focused',
              icon: 'ü¶Ñ',
              description: 'Exposition maximale DeFi et L2 - Pour bull market DeFi',
              risk_level: '√©lev√©',
              allocations: {
                'BTC': 20.0,
                'ETH': 35.0,
                'Stablecoins': 15.0,
                'SOL': 8.0,
                'L1/L0 majors': 5.0,
                'L2/Scaling': 10.0,
                'DeFi': 6.0,
                'AI/Data': 0.5,
                'Gaming/NFT': 0.3,
                'Memecoins': 0.1,
                'Others': 0.1
              }
            },
            'bear_market': {
              name: 'Bear Protection',
              icon: 'üêª',
              description: 'Protection march√© baissier - Stablecoins dominants avec BTC/ETH solides',
              risk_level: 'tr√®s-faible',
              allocations: {
                'BTC': 30.0,
                'ETH': 15.0,
                'Stablecoins': 50.0,
                'SOL': 2.0,
                'L1/L0 majors': 2.5,
                'L2/Scaling': 0.3,
                'DeFi': 0.1,
                'AI/Data': 0.1,
                'Gaming/NFT': 0.0,
                'Memecoins': 0.0,
                'Others': 0.0
              }
            }
          };
        }

        // Tenter d'ajouter la strat√©gie dynamique CCS (sans bloquer en cas d'erreur)
        try {
          const ccsTargets = syncCCSTargets();
          if (ccsTargets) {
            availableStrategies['ccs-dynamic'] = {
              name: 'Strategic (Dynamic)',
              icon: 'üéØ',
              description: `Targets CCS du Risk Dashboard - ${ccsTargets.strategy}`,
              risk_level: 'Variable',
              allocations: ccsTargets.targets,
              _isDynamic: true,
              _ccsData: ccsTargets
            };
            console.log('Added dynamic CCS strategy:', ccsTargets);
          } else {
            // Ajouter une strat√©gie placeholder pour indiquer qu'il faut sync
            availableStrategies['ccs-dynamic-placeholder'] = {
              name: 'Strategic (Dynamic)',
              icon: 'üéØ',
              description: 'Cliquez "üéØ Sync CCS" pour charger les targets du Risk Dashboard',
              risk_level: 'N/A',
              allocations: {},
              _isPlaceholder: true
            };
          }
        } catch (syncError) {
          console.warn('Erreur synchronisation CCS (non bloquante):', syncError);
          // Ajouter une strat√©gie d'erreur pour informer l'utilisateur
          availableStrategies['ccs-dynamic-error'] = {
            name: 'Strategic (Dynamic)',
            icon: '‚ö†Ô∏è',
            description: 'Erreur de synchronisation CCS - Cliquez "üéØ Sync CCS" pour r√©essayer',
            risk_level: 'Erreur',
            allocations: {},
            _isError: true
          };
        }

        renderStrategiesUI();

      } catch (error) {
        console.error('Erreur chargement strat√©gies:', error);

        // En cas d'erreur critique, utiliser au minimum la strat√©gie par d√©faut
        if (Object.keys(availableStrategies).length === 0) {
          availableStrategies = {
            'balanced': {
              name: 'Balanced (Fallback)',
              icon: '‚öñÔ∏è',
              description: 'Strat√©gie de secours - R√©partition √©quilibr√©e',
              risk_level: 'moyen',
              allocations: {
                'BTC': 35.0,
                'ETH': 25.0,
                'Stablecoins': 20.0,
                'L1/L0 majors': 10.0,
                'Others': 10.0
              }
            }
          };
        }

        renderStrategiesUI();
        showNotification('‚ùå Erreur partielle chargement strat√©gies - Mode d√©grad√© activ√©', 'warning', 5000);
      }
    }

    function renderStrategiesUI() {
      const container = el('strategies-container');
      if (!container) return;

      const strategiesHtml = Object.entries(availableStrategies).map(([id, strategy]) => {
        const isDynamic = strategy._isDynamic;
        const isPlaceholder = strategy._isPlaceholder;
        const isError = strategy._isError;

        let cardClass = 'strategy-card';
        let borderStyle = '';
        let clickable = true;

        if (isDynamic) {
          cardClass += ' dynamic-strategy';
          borderStyle = 'border: 2px solid var(--warning); background: linear-gradient(135deg, var(--theme-surface), var(--warning-bg));';
        } else if (isPlaceholder) {
          cardClass += ' placeholder-strategy';
          borderStyle = 'border: 2px dashed var(--theme-border); opacity: 0.7;';
          clickable = true; // Permettre la s√©lection pour montrer le message
        } else if (isError) {
          cardClass += ' error-strategy';
          borderStyle = 'border: 2px solid var(--danger); background: linear-gradient(135deg, var(--theme-surface), var(--danger-bg));';
          clickable = true; // Permettre la s√©lection pour montrer le message
        }

        const onclickAttr = clickable ? `onclick="selectStrategy('${id}')"` : '';
        const cursorStyle = clickable ? '' : 'cursor: not-allowed;';

        return `
    <div class="${cardClass}" data-strategy-id="${id}" ${onclickAttr} style="${borderStyle} ${cursorStyle}">
      <div class="strategy-header">
        <div class="strategy-title">${strategy.icon} ${strategy.name}</div>
        <div class="strategy-risk risk-${strategy.risk_level.toLowerCase().replace(/[^a-z]/g, '')}">${strategy.risk_level}</div>
      </div>
      <div style="font-size: 13px; color: var(--muted); margin-bottom: 8px;">
        ${strategy.description}
        ${isDynamic ? '<div style="font-size: 11px; color: var(--warning); font-weight: 600; margin-top: 4px;">‚è∞ Donn√©es r√©centes du Risk Dashboard</div>' : ''}
        ${isPlaceholder ? '<div style="font-size: 11px; color: var(--theme-text-muted); font-weight: 600; margin-top: 4px;">üì≠ En attente de synchronisation</div>' : ''}
        ${isError ? '<div style="font-size: 11px; color: var(--danger); font-weight: 600; margin-top: 4px;">‚ö†Ô∏è Synchronisation requise</div>' : ''}
      </div>
      <div class="strategy-allocations">
        ${Object.keys(strategy.allocations).length > 0 ?
            Object.entries(strategy.allocations)
              .filter(([group, pct]) => group !== 'model_version')
              .map(([group, pct]) => {
                log.debug('renderStrategiesUI - Rendering allocation:', group, pct);
                return `<span class="allocation-pill">${group}: ${typeof pct === 'number' ? pct.toFixed(1) : pct}%</span>`;
              }).join('') :
            '<span style="font-size: 11px; color: var(--theme-text-muted);">Aucune allocation disponible</span>'
          }
      </div>
    </div>
  `;
      }).join('');

      container.innerHTML = strategiesHtml;
    }

    function selectStrategy(strategyId) {
      // D√©s√©lectionner l'ancienne strat√©gie
      document.querySelectorAll('.strategy-card').forEach(card => {
        card.classList.remove('selected');
      });

      // S√©lectionner la nouvelle
      const selectedCard = document.querySelector(`[data-strategy-id="${strategyId}"]`);
      if (selectedCard) {
        selectedCard.classList.add('selected');
        selectedStrategyId = strategyId;

        // Mettre √† jour les boutons
        el('apply-strategy-btn').disabled = false;
        el('selected-strategy-info').style.display = 'inline-block';
        el('selected-strategy-info').textContent = `${availableStrategies[strategyId].icon} ${availableStrategies[strategyId].name}`;
      }
    }

    function applyStrategy() {
      if (!selectedStrategyId || !availableStrategies[selectedStrategyId]) {
        showNotification('Aucune strat√©gie s√©lectionn√©e', 'warning');
        return;
      }

      const strategy = availableStrategies[selectedStrategyId];

      // Utiliser le syst√®me dynamicTargets pour appliquer la strat√©gie
      dynamicTargets = strategy.allocations;
      useDynamicTargets = true;

      // Mettre √† jour l'indicateur UI
      const indicator = el("dynamicTargetsIndicator");
      if (indicator) {
        indicator.style.display = 'inline-block';
        indicator.textContent = `üéØ ${strategy.name}`;
      }

      // Notification
      showNotification(`‚úÖ Strat√©gie "${strategy.name}" appliqu√©e!`, 'success');

      // R√©g√©n√©rer automatiquement le plan
      setTimeout(() => {
        runPlan();
      }, 500);
    }

    function resetToManual() {
      // D√©s√©lectionner toutes les strat√©gies
      document.querySelectorAll('.strategy-card').forEach(card => {
        card.classList.remove('selected');
      });

      selectedStrategyId = null;
      el('apply-strategy-btn').disabled = true;
      el('selected-strategy-info').style.display = 'none';

      // D√©sactiver les targets dynamiques
      dynamicTargets = null;
      useDynamicTargets = false;

      // Masquer l'indicateur
      const indicator = el("dynamicTargetsIndicator");
      if (indicator) {
        indicator.style.display = 'none';
      }

      showNotification('Mode manuel activ√©', 'info');

      // R√©g√©n√©rer le plan avec les targets par d√©faut
      setTimeout(() => {
        runPlan();
      }, 500);
    }

    function showStrategiesError(message) {
      el('strategies-container').innerHTML = `
    <div style="text-align: center; padding: 20px; color: var(--danger);">
      ‚ùå ${message}
    </div>
  `;
    }

    const fmt = n => (n == null || isNaN(n)) ? "" : Number(n).toLocaleString(undefined, { maximumFractionDigits: 8 });
    const fmt2 = n => (n == null || isNaN(n)) ? "‚Äî" : Number(n).toLocaleString(undefined, { maximumFractionDigits: 2 });

    /* ---------- Dynamic Targets Support ---------- */
    let dynamicTargets = null;
    let useDynamicTargets = false;

    // Interface for CCS/cycle module integration
    window.rebalanceAPI = {
      setDynamicTargets: function (targets, metadata = {}) {
        dynamicTargets = targets;
        useDynamicTargets = true;
        console.log('Dynamic targets set:', targets, metadata);

        // Update UI to show dynamic mode
        const indicator = el("dynamicTargetsIndicator");
        if (indicator) {
          indicator.style.display = 'block';
          if (metadata.ccs !== undefined) {
            indicator.textContent = `üéØ CCS ${metadata.ccs}`;
          }
        }
        setStatus(`Targets dynamiques appliqu√©s (CCS: ${metadata.ccs || 'N/A'})`);

        // Auto-run plan if requested
        if (metadata.autoRun) {
          setTimeout(() => runPlan(), 100);
        }
      },

      clearDynamicTargets: function () {
        dynamicTargets = null;
        useDynamicTargets = false;

        // Hide UI indicator
        const indicator = el("dynamicTargetsIndicator");
        if (indicator) {
          indicator.style.display = 'none';
          indicator.textContent = 'üéØ Targets dynamiques';
        }
        setStatus('Mode targets manuel r√©tabli');
      },

      getCurrentTargets: function () {
        if (useDynamicTargets && dynamicTargets) {
          return { dynamic: true, targets: dynamicTargets };
        } else {
          return { dynamic: false, targets: getCurrentManualTargets() };
        }
      }
    };

    function getCurrentManualTargets() {
      // Extract current manual targets from UI (placeholder for now)
      return {};
    }

    // Load real portfolio data using configured source
    async function loadRealPortfolioData() {
      try {
        console.log('üîç Loading real portfolio data using configured source...');
        const balanceResult = await window.loadBalanceData();

        if (!balanceResult.success) {
          throw new Error(balanceResult.error);
        }

        let balances;

        if (balanceResult.csvText) {
          // Source CSV locale
          balances = window.parseCSVBalances(balanceResult.csvText);
        } else if (balanceResult.data && balanceResult.data.items) {
          // Source API (stub ou cointracking_api)
          balances = balanceResult.data.items.map(item => ({
            symbol: item.symbol,
            balance: item.balance,
            value_usd: item.value_usd
          }));
        } else {
          throw new Error('Invalid data format received');
        }

        const totalValue = balances.reduce((sum, item) => sum + item.value_usd, 0);

        console.log(`üîç Loaded ${balances.length} assets from CSV, total: $${totalValue.toFixed(2)}`);

        // Group assets by ASSET_GROUPS
        const groupedData = groupAssetsByAliases(balances);

        // Convert to format expected by rebalancing logic
        const currentByGroup = {};
        const currentWeights = {};

        groupedData.forEach(group => {
          currentByGroup[group.label] = group.value;
          currentWeights[group.label] = (group.value / totalValue) * 100;
        });

        return {
          currentByGroup,
          currentWeights,
          totalValue,
          assetCount: balances.length
        };

      } catch (error) {
        console.error('Failed to load real portfolio data:', error);
        return null;
      }
    }

    // CSV parsing functions (same as dashboard.html)
    function parseCSVBalances(csvText) {
      const cleanedText = csvText.replace(/^\ufeff/, '');
      const lines = cleanedText.split('\n');
      const balances = [];

      for (let i = 1; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) continue;

        try {
          const columns = parseCSVLine(line);
          if (columns.length >= 5) {
            const ticker = columns[0];
            const amount = parseFloat(columns[3]);
            const valueUSD = parseFloat(columns[4]);

            if (ticker && !isNaN(amount) && !isNaN(valueUSD) && valueUSD >= 1.0) {
              balances.push({
                symbol: ticker.toUpperCase(),
                balance: amount,
                value_usd: valueUSD
              });
            }
          }
        } catch (error) {
          console.warn('Error parsing CSV line:', error);
        }
      }

      return balances;
    }

    function parseCSVLine(line) {
      const result = [];
      let current = '';
      let inQuotes = false;

      for (let i = 0; i < line.length; i++) {
        const char = line[i];

        if (char === '"') {
          inQuotes = !inQuotes;
        } else if (char === ';' && !inQuotes) {
          result.push(current.trim().replace(/^"|"$/g, ''));
          current = '';
        } else {
          current += char;
        }
      }

      if (current) {
        result.push(current.trim().replace(/^"|"$/g, ''));
      }

      return result;
    }

    // Asset grouping function (same as other dashboards)
    const ASSET_GROUPS = {
      'BTC': ['BTC', 'TBTC'],
      'ETH': ['ETH', 'WETH', 'STETH', 'WSTETH', 'RETH', 'CBETH'],
      'Stablecoins': ['USDC', 'USDT', 'USD', 'DAI'],
      'L1/L0 majors': ['SOL', 'SOL2', 'ATOM', 'ATOM2', 'DOT', 'DOT2', 'ADA', 'AVAX', 'NEAR', 'LINK', 'XRP', 'BCH', 'XLM', 'LTC', 'SUI3', 'TRX'],
      'Exchange Tokens': ['BNB', 'BGB', 'CHSB'],
      'DeFi': ['AAVE', 'JUPSOL', 'JITOSOL', 'FET'],
      'Memecoins': ['DOGE'],
      'Privacy': ['XMR'],
      'Others': ['IMO', 'VVV3', 'TAO6']
    };

    function groupAssetsByAliases(items) {
      const groups = new Map();
      const ungrouped = [];

      items.forEach(item => {
        const symbol = (item.symbol || '').toUpperCase();
        let foundGroup = null;

        for (const [groupName, aliases] of Object.entries(ASSET_GROUPS)) {
          if (aliases.includes(symbol)) {
            foundGroup = groupName;
            break;
          }
        }

        if (foundGroup) {
          if (!groups.has(foundGroup)) {
            groups.set(foundGroup, {
              label: foundGroup,
              value: 0,
              assets: []
            });
          }
          const group = groups.get(foundGroup);
          group.value += parseFloat(item.value_usd || 0);
          group.assets.push(symbol);
        } else {
          ungrouped.push({
            label: symbol,
            value: parseFloat(item.value_usd || 0)
          });
        }
      });

      return [...Array.from(groups.values()), ...ungrouped];
    }

    // Generate rebalancing plan using real configured data only
    async function generateRealPlan() {
      let currentByGroup = {};
      let currentWeights = {};
      let totalUsd = 0;

      try {
        const realPortfolioData = await loadRealPortfolioData();
        if (realPortfolioData && realPortfolioData.totalValue > 0) {
          currentByGroup = realPortfolioData.currentByGroup;
          currentWeights = realPortfolioData.currentWeights;
          totalUsd = realPortfolioData.totalValue;
          console.log('‚úÖ Using real data for rebalancing plan:', { totalUsd, groups: Object.keys(currentByGroup).length });
        } else {
          throw new Error('No portfolio data available from configured source');
        }
      } catch (error) {
        console.error('‚ùå Failed to load portfolio data:', error);
        throw new Error(`Portfolio data unavailable: ${error.message}. Please configure data source in settings.`);
      }

      // Target weights from selected strategy or default (GROUP LEVEL)
      let groupTargetWeights;
      if (useDynamicTargets && dynamicTargets) {
        groupTargetWeights = { ...dynamicTargets };
        console.log('Using dynamic group targets:', groupTargetWeights);
      } else {
        groupTargetWeights = {
          BTC: 35,
          ETH: 25,
          Stablecoins: 20,
          'L1/L0 majors': 10,
          'Exchange Tokens': 3,
          DeFi: 3,
          Memecoins: 2,
          Privacy: 1,
          Others: 1
        };
      }

      // Generate actions for INDIVIDUAL ASSETS (not groups)
      const actions = await generateIndividualAssetActions(groupTargetWeights, totalUsd);
      console.log('üîç Generated', actions.length, 'individual asset actions');

      // Still calculate group deltas for the summary display
      const deltasByGroup = {};
      Object.keys(groupTargetWeights).forEach(group => {
        const currentUsd = currentByGroup[group] || 0;
        const targetUsd = totalUsd * (groupTargetWeights[group] / 100);
        deltasByGroup[group] = targetUsd - currentUsd;
      });

      return {
        current_weights_pct: currentWeights,
        target_weights_pct: groupTargetWeights,
        current_by_group: currentByGroup,
        deltas_by_group_usd: deltasByGroup,
        actions: actions,
        total_usd: totalUsd,
        unknown_aliases: [],
        meta: {
          source_used: 'mock_data',
          items_count: Object.keys(currentByGroup).length,
          pricing_mode: 'mock',
          generated_at: new Date().toISOString()
        }
      };
    }

    function getMainSymbolForGroup(group, currentByGroup = {}) {
      // Use real assets from the portfolio based on ASSET_GROUPS
      const groupToRealSymbols = {
        'BTC': ['BTC', 'TBTC'],
        'ETH': ['ETH', 'WSTETH', 'STETH', 'RETH', 'WETH', 'CBETH'],
        'Stablecoins': ['USDT', 'USD', 'USDC', 'DAI'],
        'L1/L0 majors': ['SOL2', 'ATOM2', 'DOT2', 'ADA', 'AVAX', 'NEAR', 'LINK', 'XRP', 'BCH', 'XLM', 'LTC', 'SUI3', 'TRX'],
        'Exchange Tokens': ['BNB', 'BGB', 'CHSB'],
        'DeFi': ['AAVE', 'JUPSOL', 'JITOSOL', 'FET'],
        'Memecoins': ['DOGE'],
        'Privacy': ['XMR'],
        'Others': ['IMO', 'VVV3', 'TAO6']
      };

      // Get the primary symbols for this group from your real portfolio
      const possibleSymbols = groupToRealSymbols[group] || [];

      // Find which symbol actually exists in the current portfolio with highest value
      let bestSymbol = null;
      let bestValue = 0;

      // Check which symbols from ASSET_GROUPS are actually in the current portfolio
      for (const [assetGroup, symbols] of Object.entries(ASSET_GROUPS)) {
        if (assetGroup === group) {
          for (const symbol of symbols) {
            // Look for assets in the current portfolio matching this symbol
            const groupData = Object.entries(currentByGroup || {}).find(([groupName, value]) => {
              return groupName === group && value > bestValue;
            });
            if (groupData) {
              bestValue = groupData[1];
              bestSymbol = symbols[0]; // Use the first (primary) symbol for the group
            }
          }
          break;
        }
      }

      // Fallback to the first symbol in the group or a default
      if (!bestSymbol && possibleSymbols.length > 0) {
        bestSymbol = possibleSymbols[0];
      }

      return bestSymbol || {
        'BTC': 'BTC',
        'ETH': 'ETH',
        'Stablecoins': 'USDT',
        'L1/L0 majors': 'XRP',
        'Exchange Tokens': 'BNB',
        'DeFi': 'AAVE',
        'Memecoins': 'DOGE',
        'Privacy': 'XMR',
        'Others': 'IMO'
      }[group] || 'UNKNOWN';
    }

    function getRealPriceForSymbol(symbol, currentByGroup, totalUsd) {
      // Get real prices from CSV data - using market prices from the CSV
      const realPrices = {
        'BTC': 109822, 'TBTC': 110343,
        'ETH': 4421, 'WSTETH': 5369, 'STETH': 4432, 'RETH': 5044,
        'USDT': 1.0, 'USD': 1.0, 'USDC': 1.0, 'DAI': 1.0,
        'SOL2': 187, 'ATOM2': 4.46, 'DOT2': 3.77, 'ADA': 0.84,
        'AVAX': 23.31, 'NEAR': 2.42, 'LINK': 23.39, 'XRP': 2.90,
        'BCH': 535, 'XLM': 0.39, 'LTC': 110, 'SUI3': 3.38, 'TRX': 0.35,
        'BNB': 842, 'BGB': 4.57, 'CHSB': 0.24,
        'AAVE': 330, 'JUPSOL': 212, 'JITOSOL': 231, 'FET': 0.63,
        'DOGE': 0.21, 'XMR': 263, 'IMO': 1.46, 'VVV3': 2.87, 'TAO6': 324
      };

      return realPrices[symbol] || 1.0;
    }

    // Generate actions for INDIVIDUAL ASSETS based on group targets
    async function generateIndividualAssetActions(groupTargetWeights, totalUsd) {
      const actions = [];

      try {
        // Load balance data using configured source
        console.log('üîç Loading balance data for rebalancing using configured source...');
        const balanceResult = await window.loadBalanceData();

        if (!balanceResult.success) {
          throw new Error(balanceResult.error);
        }

        let individualBalances;

        if (balanceResult.csvText) {
          // Source CSV locale
          individualBalances = window.parseCSVBalances(balanceResult.csvText);
        } else if (balanceResult.data && balanceResult.data.items) {
          // Source API (stub ou cointracking_api)
          individualBalances = balanceResult.data.items.map(item => ({
            symbol: item.symbol,
            balance: item.balance,
            value_usd: item.value_usd
          }));
        } else {
          throw new Error('Invalid data format received');
        }

        console.log('üîç Rebalancing', individualBalances.length, 'individual assets using source:', balanceResult.source);

        // Load exchange data for smart location selection
        const exchangeData = await loadExchangeData();
        console.log('üîç Exchange data loaded for smart location selection');

        // Calculate individual asset targets based on group targets
        const individualTargets = calculateIndividualAssetTargets(individualBalances, groupTargetWeights, totalUsd);

        // Generate actions for each asset
        individualBalances.forEach(asset => {
          const targetValue = individualTargets[asset.symbol] || 0;
          const currentValue = asset.value_usd;
          const delta = targetValue - currentValue;

          // Only generate actions for significant changes (>$25)
          if (Math.abs(delta) >= 25) {
            const price = getRealPriceForSymbol(asset.symbol);
            const group = getAssetGroup(asset.symbol);
            const action = delta > 0 ? 'BUY' : 'SELL';

            // Use smart exchange selection for location
            const optimalLocation = selectOptimalExchange(asset.symbol, action, Math.abs(delta), exchangeData);
            const exchangeSummary = getExchangeSummary(asset.symbol, exchangeData);

            actions.push({
              group: group,
              alias: asset.symbol,
              symbol: asset.symbol,
              action: action,
              usd: Math.abs(delta),
              est_quantity: Math.abs(delta) / price,
              price_used: price,
              price_source: 'csv_market_price',
              location: optimalLocation,
              current_value: currentValue,
              target_value: targetValue,
              current_balance: asset.balance,
              exchange_summary: exchangeSummary
            });
          }
        });

        // Sort actions by USD amount (largest first)
        actions.sort((a, b) => b.usd - a.usd);

      } catch (error) {
        console.error('Error generating individual asset actions:', error);
        return []; // Return empty array on error
      }

      return actions;
    }

    // Calculate target value for each individual asset based on group targets
    function calculateIndividualAssetTargets(individualBalances, groupTargetWeights, totalUsd) {
      const targets = {};

      // Group assets by their ASSET_GROUPS classification
      const assetsByGroup = {};

      individualBalances.forEach(asset => {
        const group = getAssetGroup(asset.symbol);
        if (!assetsByGroup[group]) {
          assetsByGroup[group] = [];
        }
        assetsByGroup[group].push(asset);
      });

      // For each group, distribute the target amount among assets
      Object.entries(groupTargetWeights).forEach(([group, groupTargetPct]) => {
        const groupTargetUsd = totalUsd * (groupTargetPct / 100);
        const assetsInGroup = assetsByGroup[group] || [];

        if (assetsInGroup.length === 0) return;

        // Distribute group target proportionally based on current values
        const groupCurrentTotal = assetsInGroup.reduce((sum, asset) => sum + asset.value_usd, 0);

        if (groupCurrentTotal > 0) {
          // Proportional distribution based on current holdings
          assetsInGroup.forEach(asset => {
            const proportion = asset.value_usd / groupCurrentTotal;
            targets[asset.symbol] = groupTargetUsd * proportion;
          });
        } else {
          // If no current holdings, distribute equally
          const targetPerAsset = groupTargetUsd / assetsInGroup.length;
          assetsInGroup.forEach(asset => {
            targets[asset.symbol] = targetPerAsset;
          });
        }
      });

      return targets;
    }

    // Get the group classification for an asset
    function getAssetGroup(symbol) {
      for (const [group, symbols] of Object.entries(ASSET_GROUPS)) {
        if (symbols.includes(symbol.toUpperCase())) {
          return group;
        }
      }
      return 'Others';
    }

    // Load and parse exchange distribution data
    async function loadExchangeData() {
      try {
        // Try to find the most recent Coins by Exchange file
        let exchangeResponse;
        const possibleFilenames = [
          '/data/raw/CoinTracking - Coins by Exchange - 26.08.2025.csv',
          '/data/raw/CoinTracking - Coins by Exchange.csv',
          './data/raw/CoinTracking - Coins by Exchange - 26.08.2025.csv',
          './data/raw/CoinTracking - Coins by Exchange.csv'
        ];

        for (const filename of possibleFilenames) {
          try {
            exchangeResponse = await fetch(filename);
            if (exchangeResponse.ok) {
              console.log('üîç Found exchange data at:', filename);
              break;
            }
          } catch (error) {
            continue;
          }
        }

        if (!exchangeResponse || !exchangeResponse.ok) {
          throw new Error('No exchange data file found');
        }

        const csvText = await exchangeResponse.text();
        const exchangeData = parseExchangeCSV(csvText);

        console.log('üîç Loaded exchange data for', Object.keys(exchangeData).length, 'coins across exchanges');

        // Show sample of loaded data
        const sampleCoins = Object.keys(exchangeData).slice(0, 3);
        sampleCoins.forEach(coin => {
          console.log(`üìä ${coin} exchanges:`, Object.keys(exchangeData[coin]));
        });
        return exchangeData;

      } catch (error) {
        console.warn('Could not load exchange data:', error);
        return {};
      }
    }

    // Parse exchange CSV data  
    function parseExchangeCSV(csvText) {
      const cleanedText = csvText.replace(/^\ufeff/, '');
      const lines = cleanedText.split('\n');
      const exchangeData = {};

      for (let i = 1; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) continue;

        try {
          const columns = parseCSVLine(line);
          if (columns.length >= 5) {
            const amount = parseFloat(columns[0]);
            const exchange = columns[1];
            const valueUSD = parseFloat(columns[2]);
            const coinInfo = columns[4]; // "BTC (Bitcoin) by Exchange"

            // Extract coin symbol from "BTC (Bitcoin) by Exchange" format
            const coinMatch = coinInfo.match(/^([A-Z0-9]+)/);
            if (!coinMatch) continue;

            const coinSymbol = coinMatch[1];

            if (!isNaN(amount) && !isNaN(valueUSD) && valueUSD >= 0.01) {
              if (!exchangeData[coinSymbol]) {
                exchangeData[coinSymbol] = {};
              }

              if (!exchangeData[coinSymbol][exchange]) {
                exchangeData[coinSymbol][exchange] = {
                  amount: 0,
                  value_usd: 0
                };
              }

              exchangeData[coinSymbol][exchange].amount += amount;
              exchangeData[coinSymbol][exchange].value_usd += valueUSD;
            }
          }
        } catch (error) {
          console.warn('Error parsing exchange CSV line:', error);
        }
      }

      return exchangeData;
    }

    // Smart exchange selection logic
    function selectOptimalExchange(coinSymbol, action, amount, exchangeData) {
      const coinExchanges = exchangeData[coinSymbol] || {};

      if (Object.keys(coinExchanges).length === 0) {
        console.log(`üí° No exchange data for ${coinSymbol}, using default`);
        return action === 'BUY' ? 'Binance (Recommended)' : 'Current Holdings';
      }

      console.log(`üí° Found exchanges for ${coinSymbol}:`, Object.keys(coinExchanges));

      // Sort exchanges by value (descending)
      const sortedExchanges = Object.entries(coinExchanges)
        .map(([exchange, data]) => ({
          exchange,
          value: data.value_usd,
          amount: data.amount
        }))
        .sort((a, b) => b.value - a.value);

      if (action === 'SELL') {
        // For sells, prefer exchanges with high liquidity, avoid Ledger due to transfer costs
        const liquidExchanges = sortedExchanges.filter(ex =>
          !ex.exchange.toLowerCase().includes('ledger') &&
          !ex.exchange.toLowerCase().includes('wallet')
        );

        if (liquidExchanges.length > 0) {
          const best = liquidExchanges[0];
          return `${best.exchange} ($${best.value.toLocaleString()})`;
        }

        // Fallback to largest holding
        const largest = sortedExchanges[0];
        return `${largest.exchange} ($${largest.value.toLocaleString()})`;
      } else {
        // For buys, prefer main trading exchanges
        const tradingExchanges = ['Binance', 'Kraken', 'Kraken Earn'];

        for (const tradingExchange of tradingExchanges) {
          const found = sortedExchanges.find(ex =>
            ex.exchange.toLowerCase().includes(tradingExchange.toLowerCase())
          );
          if (found) {
            return `${found.exchange} (Liquid)`;
          }
        }

        // Fallback to recommended exchange
        return 'Binance (Recommended)';
      }
    }

    // Get exchange summary for a coin
    function getExchangeSummary(coinSymbol, exchangeData) {
      const coinExchanges = exchangeData[coinSymbol] || {};
      const exchanges = Object.entries(coinExchanges).map(([exchange, data]) => {
        return `${exchange}: $${data.value_usd.toLocaleString()}`;
      }).join(', ');

      return exchanges || 'No exchange data';
    }


    async function generateRealCsv() {
      const plan = await generateRealPlan();
      const headers = 'group,alias,symbol,action,usd,est_quantity,price_used,location\n';
      const rows = plan.actions.map(action =>
        `${action.group},${action.alias},${action.symbol},${action.action},${action.usd},${action.est_quantity},${action.price_used},${action.location}`
      ).join('\n');
      const csvContent = headers + rows;
      return new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    }

    function setStatus(text) { el("status").textContent = text; }
    function showNotification(text, type = 'info', duration = 3000) {
      const notif = document.createElement('div');
      notif.className = `notification ${type}`;
      notif.textContent = text;
      document.body.appendChild(notif);
      setTimeout(() => notif.remove(), duration);
    }

    function showDataSourceError(message) {
      // Clear existing content
      $('#donutCurrent').innerHTML = '';
      $('#donutTarget').innerHTML = '';
      $('#summary').innerHTML = '';
      $('#tblActions tbody').innerHTML = '';

      // Show error message with configuration guidance
      $('#summary').innerHTML = `
        <div class="card" style="text-align: center; padding: 2rem; border: 2px solid var(--danger); background: var(--danger-bg);">
          <h3 style="color: var(--danger); margin-bottom: 1rem;">‚ö†Ô∏è Configuration Requise</h3>
          <p style="margin-bottom: 1rem; color: var(--theme-text);">${message}</p>
          <p style="margin-bottom: 1.5rem; color: var(--theme-text-muted);">
            Pour utiliser l'interface de rebalancing, vous devez configurer une source de donn√©es valide.
          </p>
          <button class="btn" onclick="window.open('settings.html', '_blank')" style="background: var(--brand-primary); margin-right: 0.5rem;">
            üîß Ouvrir Settings
          </button>
          <button class="btn secondary" onclick="location.reload()">
            üîÑ Recharger la page
          </button>
        </div>
      `;

      showNotification('‚ùå Configuration de source de donn√©es requise - Voir Settings', 'error', 5000);
    }
    function setTotal(v) {
      const n = Number(v || 0);
      el("total").textContent = "Total : " + (isFinite(n) ? n.toLocaleString(undefined, { maximumFractionDigits: 2 }) + " $" : "‚Äî");
    }

    async function postJson(url, body) {
      const r = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body || {})
      });
      if (!r.ok) { throw new Error(`[${r.status}] ${await r.text()}`); }
      return r.json();
    }

    async function postCsv(url, body) {
      const r = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body || {})
      });
      if (!r.ok) { throw new Error(`[${r.status}] ${await r.text()}`); }
      return r.blob();
    }

    function buildPayload() {
      // Base payload
      const payload = {
        primary_symbols: {
          BTC: ["BTC", "TBTC", "WBTC"],
          ETH: ["ETH", "WSTETH", "STETH", "RETH", "WETH"],
          SOL: ["SOL", "JUPSOL", "JITOSOL"]
        },
        sub_allocation: "proportional",
        min_trade_usd: 25
      };

      // Use dynamic targets if available, otherwise default manual targets
      if (useDynamicTargets && dynamicTargets) {
        console.log('üîç Sending dynamic targets to server:', dynamicTargets);
        payload.dynamic_targets_pct = dynamicTargets;
      } else {
        payload.group_targets_pct = { BTC: 35, ETH: 25, Stablecoins: 10, SOL: 10, "L1/L0 majors": 10, Others: 10 };
      }

      return payload;
    }

    function currentQuery() {
      // Utiliser la configuration globale au lieu des champs locaux
      const api = globalConfig.get('api_base_url').trim().replace(/\/+$/, '');
      const source = globalConfig.get('data_source');
      const min_usd = globalConfig.get('min_usd_threshold') || 1;
      const pricing = globalConfig.get('pricing');

      // Add dynamic_targets parameter if we're using dynamic targets
      const params = { source, min_usd, pricing };
      if (useDynamicTargets && dynamicTargets) {
        params.dynamic_targets = true;
      }

      const qs = new URLSearchParams(params).toString();
      return { api, qs };
    }

    /* ---------- Donuts (SVG) ---------- */
    const COLORS = ["#60a5fa", "#34d399", "#f472b6", "#f59e0b", "#a78bfa", "#f87171", "#22d3ee", "#eab308"];
    function donutSVG(weights, title) {
      const size = 160, r = 68, cx = 80, cy = 80, stroke = 22;
      const names = Object.keys(weights || {});
      let start = -Math.PI / 2;
      const segs = [];
      names.forEach((name, i) => {
        const pct = Math.max(0, Number(weights[name] || 0)) / 100;
        const angle = pct * Math.PI * 2;
        const end = start + angle;
        if (pct > 0) {
          const largeArc = angle > Math.PI ? 1 : 0;
          const x1 = cx + r * Math.cos(start), y1 = cy + r * Math.sin(start);
          const x2 = cx + r * Math.cos(end), y2 = cy + r * Math.sin(end);
          const path = `M ${x1} ${y1} A ${r} ${r} 0 ${largeArc} 1 ${x2} ${y2}`;
          segs.push(`<path d="${path}" stroke="${COLORS[i % COLORS.length]}" stroke-width="${stroke}" fill="none" />`);
        }
        start = end;
      });
      const total = (Object.values(weights || {}).reduce((a, b) => a + Number(b || 0), 0)).toFixed(0);
      return `<svg width="${size}" height="${size}" viewBox="0 0 160 160">
    <circle cx="${cx}" cy="${cy}" r="${r}" stroke="#152232" stroke-width="${stroke}" fill="none"/>
    ${segs.join("")}
    <text x="${cx}" y="${cy - 2}" text-anchor="middle" font-size="14" fill="#cbd5e1">${title || ""}</text>
    <text x="${cx}" y="${cy + 14}" text-anchor="middle" font-size="12" fill="#93a3b5">${total}%</text>
  </svg>`;
    }
    function renderDonuts(plan) {
      const cw = plan?.current_weights_pct || {};
      const tw = plan?.target_weights_pct || {};
      $("#donutCurrent").innerHTML = donutSVG(cw, "Actuel");
      $("#donutTarget").innerHTML = donutSVG(tw, "Cible");

      const names = Object.keys(tw).length ? Object.keys(tw) : Object.keys(cw);
      const html = (names || []).map((g, i) => `<span><span class="dot" style="background:${COLORS[i % COLORS.length]}"></span>${g}</span>`).join("");
      $("#legend").innerHTML = html;
    }

    /* ---------- R√©sum√© & Actions ---------- */
    function renderActions(actions) {
      const tb = $("#tblActions tbody");
      tb.innerHTML = (actions || []).map(a => `
    <tr>
      <td>${a.group || ""}</td>
      <td>${a.alias || ""}</td>
      <td>${a.symbol || ""}</td>
      <td>${a.action || ""}</td>
      <td class="right">${fmt(a.usd)}</td>
      <td class="right">${fmt(a.est_quantity)}</td>
      <td class="right">${fmt(a.price_used)}</td>
      <td>${a.exec_hint || a.location || ""}</td>
    </tr>
  `).join("");
    }

    function updatePricingBadge(actions, plan) {
      const badge = el("pricing-badge");

      // Chercher une action avec price_source (pas forc√©ment la premi√®re)
      const actionWithPrice = (actions || []).find(a => a.price_source && a.price_used);
      const priceSource = actionWithPrice?.price_source;
      const pricingMode = plan?.meta?.pricing_mode || "unknown";

      let badgeHtml = "";

      if (priceSource === "local") {
        badgeHtml = '<span class="pill" style="background:#16a34a;border-color:#16a34a;color:white;font-size:12px">Prix locaux</span>';
      } else if (priceSource === "market") {
        badgeHtml = '<span class="pill" style="background:#dc2626;border-color:#dc2626;color:white;font-size:12px">Prix march√©</span>';
      } else if (pricingMode === "hybrid") {
        // Fallback si aucune action n'a de prix encore
        badgeHtml = '<span class="pill" style="background:#f59e0b;border-color:#f59e0b;color:white;font-size:12px">Hybride</span>';
      } else if (pricingMode === "local") {
        badgeHtml = '<span class="pill" style="background:#16a34a;border-color:#16a34a;color:white;font-size:12px">Prix locaux</span>';
      } else if (pricingMode === "auto") {
        badgeHtml = '<span class="pill" style="background:#dc2626;border-color:#dc2626;color:white;font-size:12px">Prix march√©</span>';
      }

      badge.innerHTML = badgeHtml;
    }
    function renderSummary(plan) {
      const grp = plan?.current_by_group || {};
      const cw = plan?.current_weights_pct || {};
      const tw = plan?.target_weights_pct || {};
      const dU = plan?.deltas_by_group_usd || {};
      const names = Object.keys(tw).length ? Object.keys(tw) : Object.keys(cw);
      const html = (names || []).map(g => {
        const cur = cw[g]; const tgt = tw[g]; const du = dU[g];
        const cls = (du || 0) >= 0 ? "delta-pos" : "delta-neg";
        return `<div class="card">
      <div class="row" style="justify-content:space-between">
        <div class="badge">${g}</div>
        <div class="muted small">${fmt2(grp[g])} $</div>
      </div>
      <div class="small mt8">Actuel: <strong>${fmt2(cur)}%</strong> ‚Ä¢ Cible: <strong>${fmt2(tgt)}%</strong></div>
      <div class="small">Delta: <strong class="${cls}">${fmt2(du)} $</strong></div>
    </div>`;
      }).join("");
      $("#summary").innerHTML = html || '<span class="muted">Aucun r√©sum√© disponible.</span>';
    }

    function renderUnknownAliases(list) {
      const container = el("unknownList");
      if (!list || !list.length) { container.innerHTML = '<span class="muted">Aucun üéâ</span>'; return; }
      const options = ["BTC", "ETH", "Stablecoins", "SOL", "L1/L0 majors", "L2/Scaling", "DeFi", "AI/Data", "Gaming/NFT", "Memecoins", "Others"]
        .map(g => `<option value="${g}" ${g === "Others" ? 'selected' : ''}>${g}</option>`).join("");
      container.innerHTML = list.map(a => `
    <div class="row">
      <div class="pill">${a}</div>
      <select class="u_group">${options}</select>
      <button class="btn secondary small act-add" data-alias="${a}">Ajouter</button>
    </div>
  `).join("");

      // Gestion des clics sur les boutons Ajouter
      el("unknownList").addEventListener("click", async (ev) => {
        const btn = ev.target.closest('button.act-add');
        if (!btn || btn.disabled) return;

        ev.preventDefault();

        try {
          btn.disabled = true;
          const row = btn.closest('.row');
          const alias = (btn.dataset.alias || '').toUpperCase().trim();
          const groupSelect = row.querySelector('select.u_group');
          const group = groupSelect?.value || 'Others';

          if (!alias) throw new Error('Alias invalide');

          try {
            const { api } = currentQuery();
            const response = await fetch(`${api}/taxonomy/aliases`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ aliases: { [alias]: group } })
            });

            if (!response.ok) {
              const error = await response.json();
              throw new Error(error.detail || `Erreur HTTP ${response.status}`);
            }
          } catch (apiError) {
            console.warn('Taxonomy API unavailable for individual alias:', apiError);
            // Simulate successful addition
          }

          await runPlan(); // Rafra√Æchit les donn√©es
          showNotification(`‚úÖ ${alias} assign√© √† ${group}`, 'success');

        } catch (error) {
          console.error('Erreur:', error);
          showNotification(`‚ùå ${error.message}`, 'error', 5000);
        } finally {
          btn.disabled = false;
        }
      });
    }

    /* ---------- Taxonomy calls ---------- */
    async function addAliases(map) {
      try {
        const { api } = currentQuery();
        setStatus("√âcriture‚Ä¶");
        const body = { aliases: map || {} };
        const res = await postJson(`${api}/taxonomy/aliases`, body);
        setStatus(`OK (${res?.written || Object.keys(map || {}).length} alias)`);
        return res;
      } catch (error) {
        console.warn('Taxonomy API unavailable:', error);
        setStatus(`Simulation - ${Object.keys(map || {}).length} alias ajout√©s (mode hors ligne)`);
        showNotification(`üìù Aliases sauvegard√©s localement (mode hors ligne)`, 'info');
        return { written: Object.keys(map || {}).length, mode: 'mock' };
      }
    }

    /* ---------- Flow ---------- */
    function persistSourceInit() {
      // Plus n√©cessaire - la configuration est centralis√©e dans globalConfig
      return;
    }

    // Restaurer le dernier plan sauvegard√©
    function restoreLastPlan() {
      if (!window.globalConfig?.hasPlan()) return false;

      const savedPlan = window.globalConfig.getLastPlanData();
      if (!savedPlan) return false;

      // V√©rifier l'√¢ge du plan - ne pas restaurer automatiquement s'il est trop ancien
      const planAge = Date.now() - (window.globalConfig.get('last_plan_timestamp') || 0);
      const maxAge = 30 * 60 * 1000; // 30 minutes

      if (planAge > maxAge) {
        // Plan trop ancien, juste afficher le bouton Alias Manager s'il y a des unknown aliases
        const unknownCount = (savedPlan.unknown_aliases || []).length;
        if (unknownCount > 0) {
          const aliasManagerButton = document.getElementById('alias-manager-button');
          if (aliasManagerButton) {
            aliasManagerButton.style.display = 'block';
            const button = aliasManagerButton.querySelector('button');
            if (button) {
              button.innerHTML = `üè∑Ô∏è Alias Manager (${unknownCount})`;
              button.style.background = '#f59e0b';
              button.style.color = 'white';
            }
          }
        }
        setStatus('Plan pr√©c√©dent disponible - S√©lectionnez une strat√©gie pour actualiser');
        return false;
      }

      try {
        // Restaurer l'affichage du plan r√©cent
        renderDonuts(savedPlan);
        renderSummary(savedPlan);
        renderActions(savedPlan.actions || []);
        updatePricingBadge(savedPlan.actions || [], savedPlan);
        renderUnknownAliases(savedPlan.unknown_aliases || []);
        setTotal(savedPlan?.total_usd);

        // Sauvegarder les actions pour l'export JSON
        lastPlanActions = savedPlan.actions || [];

        // R√©activer les boutons
        el("btnCsv").disabled = false;
        el("btnJson").disabled = false;
        el("btnCopyJson").disabled = false;

        // Afficher le bouton Alias Manager si n√©cessaire
        const unknownCount = (savedPlan.unknown_aliases || []).length;
        const aliasManagerButton = document.getElementById('alias-manager-button');
        if (aliasManagerButton && unknownCount > 0) {
          aliasManagerButton.style.display = 'block';
          const button = aliasManagerButton.querySelector('button');
          if (button) {
            button.innerHTML = `üè∑Ô∏è Alias Manager (${unknownCount})`;
            button.style.background = '#f59e0b';
            button.style.color = 'white';
          }
        }

        const ageMin = Math.round(planAge / 60000);
        setStatus(`Plan restaur√© (g√©n√©r√© il y a ${ageMin}min)`);
        return true;
      } catch (error) {
        console.error('Erreur restauration plan:', error);
        return false;
      }
    }

    async function runPlan() {
      try {
        const t0 = performance.now();
        el("btnCsv").disabled = true;
        el("btnJson").disabled = true;
        el("btnCopyJson").disabled = true;
        setStatus("Calcul‚Ä¶");
        const { api, qs } = currentQuery();
        const url = `${api}/rebalance/plan?${qs}`;

        let plan;

        // Use real data only from configured source
        console.log('üîÑ Using real data for rebalancing plan from configured source');
        plan = await generateRealPlan(); // Use real configured data only

        /* Commented out API call - forcing CSV data for consistency
        try {
          plan = await postJson(url, buildPayload());
          console.log('üîç Server returned plan with target_weights_pct:', plan.target_weights_pct);
          console.log('üîç Server plan total_usd:', plan.total_usd);
          console.log('üîç Server plan source:', plan.meta?.source_used);
          
          // Force use of real CSV data if server data looks mock or incomplete
          if (!plan.current_weights_pct || plan.total_usd < 100000 || 
              plan.meta?.source_used === 'mock_data' || 
              Object.keys(plan.current_weights_pct || {}).length < 5) {
            console.warn('‚ö†Ô∏è Server returned insufficient/mock data, using real CSV data instead');
            plan = await generateMockPlan(); // Use real CSV data
          }
        } catch (apiError) {
          console.warn('API unavailable, using mock data:', apiError);
          plan = await generateMockPlan(); // Now async
        }
        */
        renderDonuts(plan);
        renderSummary(plan);
        renderActions(plan.actions || []);
        updatePricingBadge(plan.actions || [], plan);
        renderUnknownAliases(plan.unknown_aliases || []);
        setTotal(plan?.total_usd);

        // Sauvegarder les actions pour l'export JSON
        lastPlanActions = plan.actions || [];

        // Marquer le plan comme g√©n√©r√© et activer l'Alias Manager
        const unknownAliasesCount = (plan.unknown_aliases || []).length;
        if (window.globalConfig) {
          window.globalConfig.markPlanGenerated(unknownAliasesCount, plan);
        }

        // Afficher le bouton Alias Manager
        const aliasManagerButton = document.getElementById('alias-manager-button');
        if (aliasManagerButton) {
          aliasManagerButton.style.display = 'block';
          // Mettre √† jour le texte du bouton si des unknown aliases sont d√©tect√©s
          const button = aliasManagerButton.querySelector('button');
          if (button && unknownAliasesCount > 0) {
            button.innerHTML = `üè∑Ô∏è Alias Manager (${unknownAliasesCount} nouveaux)`;
            button.style.background = '#f59e0b';
            button.style.color = 'white';
          }
        }

        const ms = Math.round(performance.now() - t0);
        let statusText = `OK ‚Ä¢ ${ms} ms ‚Ä¢ source=${plan?.meta?.source_used || '(?)'} ‚Ä¢ items=${plan?.meta?.items_count ?? "-"}`;

        // Ajouter infos pricing hybride si disponibles
        if (plan?.meta?.pricing_mode === 'hybrid' && plan?.meta?.pricing_hybrid) {
          const hybridInfo = plan.meta.pricing_hybrid;
          statusText += ` ‚Ä¢ pricing=hybrid (√¢ge=${Math.round(hybridInfo.data_age_min)}min, seuils=${hybridInfo.max_age_min}min/${hybridInfo.max_deviation_pct}%)`;
        } else if (plan?.meta?.pricing_mode) {
          statusText += ` ‚Ä¢ pricing=${plan.meta.pricing_mode}`;
        }

        setStatus(statusText);
        el("btnCsv").disabled = false;
        el("btnJson").disabled = false;
        el("btnCopyJson").disabled = false;
      } catch (e) {
        console.error(e);
        setStatus("Erreur: " + (e?.message || e));

        // Afficher interface d'erreur si donn√©es non disponibles
        if (e.message && e.message.includes('Portfolio data unavailable')) {
          showDataSourceError(e.message);
        } else if (e.message && e.message.includes('No portfolio data available')) {
          showDataSourceError('Configuration de source de donn√©es requise');
        }
      } finally {
        // Plus de bouton btnRun √† r√©activer
      }
    }

    async function downloadCsv() {
      try {
        el("btnCsv").disabled = true;
        setStatus("G√©n√©ration CSV‚Ä¶");
        const { api, qs } = currentQuery();

        let blob;
        try {
          blob = await postCsv(`${api}/rebalance/plan.csv?${qs}`, buildPayload());
        } catch (apiError) {
          console.warn('CSV API unavailable, generating mock CSV:', apiError);
          blob = await generateRealCsv(); // Use real data only
        }
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        const ts = new Date().toISOString().replace(/[:.]/g, "-");
        a.href = url;
        a.download = `rebalance-actions-${ts}.csv`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
        setStatus("CSV t√©l√©charg√©.");
      } catch (e) {
        console.error(e);
        setStatus("Erreur CSV: " + (e?.message || e));
      } finally {
        el("btnCsv").disabled = false;
      }
    }

    // Variable globale pour stocker les actions du dernier plan
    let lastPlanActions = [];

    function exportJsonForExecution() {
      if (!lastPlanActions || lastPlanActions.length === 0) {
        showNotification('‚ùå Aucun plan g√©n√©r√© - S√©lectionnez et appliquez d\'abord une strat√©gie', 'error');
        return;
      }

      try {
        // Format array direct pour l'interface d'ex√©cution (plus simple)
        const jsonString = JSON.stringify(lastPlanActions, null, 2);
        const blob = new Blob([jsonString], { type: 'application/json' });
        const url = URL.createObjectURL(blob);

        const a = document.createElement('a');
        const ts = new Date().toISOString().replace(/[:.]/g, '-');
        a.href = url;
        a.download = `execution-plan-${ts}.json`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);

        showNotification(`‚úÖ Plan d'ex√©cution JSON t√©l√©charg√© (${lastPlanActions.length} actions)`, 'success');

      } catch (error) {
        console.error('Erreur export JSON:', error);
        showNotification('‚ùå Erreur lors de l\'export JSON: ' + error.message, 'error');
      }
    }

    function copyJsonToClipboard() {
      if (!lastPlanActions || lastPlanActions.length === 0) {
        showNotification('‚ùå Aucun plan g√©n√©r√© - S√©lectionnez et appliquez d\'abord une strat√©gie', 'error');
        return;
      }

      try {
        // Format array direct pour l'interface d'ex√©cution
        const jsonString = JSON.stringify(lastPlanActions, null, 2);

        if (navigator.clipboard) {
          navigator.clipboard.writeText(jsonString).then(() => {
            showNotification(`üìã JSON copi√© (${lastPlanActions.length} actions) - Collez dans l'interface d'ex√©cution`, 'success');
          }).catch(() => {
            // Fallback pour les navigateurs sans clipboard API
            fallbackCopyTextToClipboard(jsonString);
          });
        } else {
          fallbackCopyTextToClipboard(jsonString);
        }

      } catch (error) {
        console.error('Erreur copie JSON:', error);
        showNotification('‚ùå Erreur lors de la copie JSON: ' + error.message, 'error');
      }
    }

    function fallbackCopyTextToClipboard(text) {
      // M√©thode fallback pour navigateurs anciens
      const textArea = document.createElement("textarea");
      textArea.value = text;
      textArea.style.position = "fixed";
      textArea.style.left = "-999999px";
      textArea.style.top = "-999999px";
      document.body.appendChild(textArea);
      textArea.focus();
      textArea.select();

      try {
        const successful = document.execCommand('copy');
        if (successful) {
          showNotification(`üìã JSON copi√© (${lastPlanActions.length} actions) - Collez dans l'interface d'ex√©cution`, 'success');
        } else {
          showNotification('‚ùå Impossible de copier - utilisez Export JSON', 'error');
        }
      } catch (err) {
        showNotification('‚ùå Impossible de copier - utilisez Export JSON', 'error');
      }

      document.body.removeChild(textArea);
    }

    async function bulkAddUnknown() {
      const container = el("unknownList");
      const rows = Array.from(container.querySelectorAll(".row"));
      if (!rows.length) { return; }
      const defaultGroup = el("bulk_group").value || "Others";
      const map = {};
      rows.forEach(r => {
        const alias = (r.querySelector(".act-add")?.getAttribute("data-alias")) || "";
        const sel = r.querySelector(".u_group");
        const group = sel ? sel.value : defaultGroup;
        if (alias) map[alias] = group || defaultGroup;
      });
      await addAliases(map);
      await runPlan();
    }

    /* ---------- Alias Manager ---------- */
    function openAliasManager() {
      window.open('alias-manager.html', '_blank');
    }

    /* ---------- Init ---------- */
    window.addEventListener("DOMContentLoaded", () => {
      // Initialiser le header partag√©
      // Navigation th√©matique initialis√©e automatiquement

      // Appliquer le th√®me imm√©diatement
      console.log('Initializing theme for rebalance page...');
      if (window.globalConfig && window.globalConfig.applyTheme) {
        window.globalConfig.applyTheme();
      }
      if (window.applyAppearance) {
        window.applyAppearance();
      }
      console.log('Current theme after rebalance init:', document.documentElement.getAttribute('data-theme'));

      // CCS data will be loaded from configured real source when needed

      // Charger les strat√©gies
      loadStrategies();

      // Test exchange data loading
      setTimeout(async () => {
        console.log('üß™ Testing exchange data loading...');
        try {
          const exchangeData = await loadExchangeData();
          console.log('‚úÖ Exchange data loaded successfully');

          // Test specific coins
          const testCoins = ['BTC', 'ETH', 'ADA', 'AAVE'];
          testCoins.forEach(coin => {
            if (exchangeData[coin]) {
              console.log(`‚úÖ ${coin}: Found on`, Object.keys(exchangeData[coin]).join(', '));
            } else {
              console.log(`‚ùå ${coin}: Not found in exchange data`);
            }
          });
        } catch (error) {
          console.error('‚ùå Exchange data test failed:', error);
        }
      }, 2000);

      // Restaurer l'√©tat de la section strat√©gies
      const isCollapsed = localStorage.getItem('strategies_section_collapsed') === 'true';
      if (isCollapsed) {
        toggleStrategiesSection();
      }

      // Gestionnaires d'√©v√©nements pour les strat√©gies
      el("apply-strategy-btn").addEventListener("click", applyStrategy);
      el("reset-strategy-btn").addEventListener("click", resetToManual);

      // √âcouter les changements de th√®me pour synchronisation cross-tab
      window.addEventListener('storage', function (e) {
        if (e.key === 'crypto_rebalancer_settings') {
          console.log('Settings changed in another tab, reapplying theme...');
          setTimeout(() => {
            if (window.globalConfig && window.globalConfig.applyTheme) {
              window.globalConfig.applyTheme();
            }
            if (window.applyAppearance) {
              window.applyAppearance();
            }
          }, 100);
        }
      });

      persistSourceInit();
      el("btnCsv").addEventListener("click", downloadCsv);
      el("btnJson").addEventListener("click", exportJsonForExecution);
      el("btnCopyJson").addEventListener("click", copyJsonToClipboard);
      el("btnBulkAdd").addEventListener("click", bulkAddUnknown);


      // Ajouter une fonction pour rafra√Æchir la strat√©gie dynamique
      window.refreshDynamicStrategy = async function () {
        try {
          showNotification('üîÑ Recherche des targets CCS depuis Risk Dashboard...', 'info', 1000);

          // Debug localStorage avant sync
          log.debug('refreshDynamicStrategy - localStorage keys:', Object.keys(localStorage));
          log.debug('refreshDynamicStrategy - last_targets raw:', localStorage.getItem('last_targets'));

          // Essayer de lire depuis localStorage (sauvegard√© par Risk Dashboard)
          let ccsTargets = syncCCSTargets();

          log.debug('refreshDynamicStrategy - Parsed CCS targets:', ccsTargets);

          // Si pas de donn√©es localStorage r√©centes
          if (!ccsTargets) {
            // V√©rifier si Risk Dashboard a r√©cemment sauvegard√© des donn√©es
            const allStorageKeys = Object.keys(localStorage);
            const ccsKeys = allStorageKeys.filter(key =>
              key.includes('ccs') || key.includes('target') || key.includes('risk-dashboard')
            );

            console.log('Found CCS-related localStorage keys:', ccsKeys);

            showNotification(
              'üì≠ Aucune donn√©e CCS r√©cente trouv√©e.\n\n' +
              '1Ô∏è‚É£ Allez dans Risk Dashboard\n' +
              '2Ô∏è‚É£ Cliquez sur l\'onglet "Strategic Targets"\n' +
              '3Ô∏è‚É£ Appliquez une strat√©gie (ex: "Blended Strategy")\n' +
              '4Ô∏è‚É£ Revenez ici et cliquez "üéØ Sync CCS"',
              'info',
              8000
            );

            // Ajouter strat√©gie placeholder
            availableStrategies['ccs-dynamic-placeholder'] = {
              name: 'Strategic (Dynamic)',
              icon: 'üì≠',
              description: 'Cliquez "üéØ Sync CCS" apr√®s avoir d√©fini des targets dans Risk Dashboard',
              risk_level: 'N/A',
              allocations: {},
              _isPlaceholder: true
            };

            // Supprimer l'ancienne version si elle existe
            delete availableStrategies['ccs-dynamic'];
            delete availableStrategies['ccs-dynamic-error'];

            renderStrategiesUI();
            return;
          }

          if (ccsTargets) {
            log.debug('refreshDynamicStrategy - Creating strategy with allocations:', ccsTargets.targets);
            log.debug('refreshDynamicStrategy - BTC allocation:', ccsTargets.targets.BTC);
            log.debug('refreshDynamicStrategy - ETH allocation:', ccsTargets.targets.ETH);

            // Mettre √† jour ou ajouter la strat√©gie dynamique
            availableStrategies['ccs-dynamic'] = {
              name: 'Strategic (Dynamic)',
              icon: 'üéØ',
              description: `Targets CCS du Risk Dashboard - ${ccsTargets.strategy}`,
              risk_level: 'Variable',
              allocations: ccsTargets.targets,
              _isDynamic: true,
              _ccsData: ccsTargets
            };

            log.debug('refreshDynamicStrategy - Final strategy object:', availableStrategies['ccs-dynamic']);

            // Supprimer les anciennes versions placeholder/error s'il y en a
            delete availableStrategies['ccs-dynamic-placeholder'];
            delete availableStrategies['ccs-dynamic-error'];

            renderStrategiesUI();
            showNotification('üéØ Strat√©gie dynamique mise √† jour!', 'success');
            console.log('Dynamic strategy refreshed:', ccsTargets);
          } else {
            showNotification('üì≠ Aucune donn√©e CCS r√©cente trouv√©e. G√©n√©rez des targets dans Risk Dashboard.', 'info', 4000);
          }
        } catch (error) {
          console.error('Error refreshing dynamic strategy:', error);
          showNotification('‚ùå Erreur lors du rafra√Æchissement: ' + error.message, 'error');

          // Ajouter strat√©gie d'erreur
          availableStrategies['ccs-dynamic-error'] = {
            name: 'Strategic (Dynamic)',
            icon: '‚ö†Ô∏è',
            description: 'Erreur de synchronisation CCS - V√©rifiez Risk Dashboard',
            risk_level: 'Erreur',
            allocations: {},
            _isError: true
          };

          // Supprimer l'ancienne version si elle existe
          delete availableStrategies['ccs-dynamic'];
          delete availableStrategies['ccs-dynamic-placeholder'];

          renderStrategiesUI();
        }
      };

      // Essayer de restaurer le dernier plan, sinon g√©n√©rer automatiquement
      if (!restoreLastPlan()) {
        setStatus("G√©n√©ration automatique du plan...");
        setTimeout(() => runPlan(), 500); // D√©lai pour laisser l'interface se charger
      }
    });
  </script>

  <script>
    // Initialisation automatique de la navigation th√©matique
    document.addEventListener('DOMContentLoaded', function () {
      // Auto-d√©tecter la page courante pour la navigation th√©matique
      /* unified nav enabled via components/nav.js; legacy init removed */
    });
  </script>
</body>

</html>