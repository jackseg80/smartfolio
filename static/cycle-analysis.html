<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Bitcoin Cycle Analysis - Precision Model</title>

  <!-- Th√®me & apparence unifi√©s -->
  <link rel="stylesheet" href="css/tokens.css">
  <link rel="stylesheet" href="shared-theme.css">
  <link rel="stylesheet" href="theme-compat.css">
  <link rel="stylesheet" href="css/view-modes.css">
  <script src="global-config.js"></script>

  <!-- View Mode System (Feb 2026) -->
  <script type="module" src="components/view-toggle.js"></script>
  <script type="module" src="components/domain-nav.js"></script>

  <!-- Navigation unifi√©e (conditionnelle) -->
  <script type="module">
    // ===== AUTH GUARD (Dec 2025) =====
    import { checkAuth } from './core/auth-guard.js';
    await checkAuth();  // V√©rifie authentification + redirect si n√©cessaire
    // =================================

    // ===== VIEW MODE MANAGER (Feb 2026) =====
    import { ViewModeManager } from './core/view-mode-manager.js';
    ViewModeManager.init();
    // ========================================

    if (new URLSearchParams(window.location.search).get('nav') !== 'off') {
      import('./components/nav.js');
    }
  </script>

  <style>
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      margin: 0;
      background: var(--theme-background);
      color: var(--theme-text);
    }

    .wrap {
      max-width: 95vw;
      margin: 0 auto;
      padding: var(--space-lg);
    }

    .card {
      background: var(--theme-surface);
      border: 1px solid var(--theme-border);
      border-radius: var(--radius-lg);
      padding: 2rem;
      margin: 1rem 0;
      box-shadow: var(--shadow-md);
      color: var(--theme-text);
    }

    /* Modern Controls Section (Compact & Sticky) */
    .controls-card {
      position: sticky;
      top: calc(var(--header-height) + 50px);
      z-index: 90;
      background: var(--theme-surface);
      border: 1px solid var(--theme-border);
      padding: 0.75rem 1rem;
      box-shadow: var(--shadow-lg);
      opacity: 0.98;
      backdrop-filter: blur(8px);
      margin-bottom: 1.5rem;
      display: grid;
      grid-template-columns: 1fr;
      gap: 0.75rem;
    }

    .controls-left h2 {
      margin: 0;
      font-size: 1.1rem;
      line-height: 1.3;
    }

    .controls-left p {
      color: var(--theme-text-muted);
      margin: 0.25rem 0 0;
      font-size: 0.8em;
    }

    .controls-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }

    @media (min-width: 900px) {
      .controls-card {
        grid-template-columns: auto 1fr;
        padding: 0.75rem 1.25rem;
      }
    }

    .control-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      padding: 0.5rem 1rem;
      font-size: 0.9rem;
      font-weight: 600;
      border-radius: var(--radius-md);
      border: 1px solid transparent;
      transition: all 0.2s ease;
      min-width: auto;
      box-shadow: var(--shadow-sm);
      margin: 0 !important;
      white-space: nowrap;
    }

    .control-btn:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
    }

    .control-btn .icon {
      font-size: 1.1em;
    }

    /* Terminal style output */
    .term {
      background: #0a0a0a;
      border: 1px solid #1a3a1a;
      border-radius: var(--radius-card);
      font-family: 'Cascadia Code', 'Fira Code', 'JetBrains Mono', 'Consolas', monospace;
      font-size: 0.8rem;
      line-height: 1.6;
      max-height: 280px;
      overflow-y: auto;
      padding: 0.75rem 1rem;
      scrollbar-width: thin;
      scrollbar-color: #1a3a1a transparent;
    }
    .term::-webkit-scrollbar { width: 6px; }
    .term::-webkit-scrollbar-track { background: transparent; }
    .term::-webkit-scrollbar-thumb { background: #1a3a1a; border-radius: 3px; }
    .term:empty::before {
      content: '$ awaiting command...';
      color: #1a3a1a;
    }
    .term .line { white-space: pre-wrap; word-break: break-word; }
    .term .line .ts { color: #555; }
    .term .line .ok { color: #22c55e; }
    .term .line .warn { color: #eab308; }
    .term .line .err { color: #ef4444; }
    .term .line .dim { color: #666; }
    .term .line .val { color: #67e8f9; }

    .chart-container {
      height: 400px;
      margin: 2rem 0;
      position: relative;
    }

    button {
      padding: 0.8rem 1.5rem;
      margin: 0.5rem;
      border: 1px solid var(--theme-border);
      border-radius: var(--radius-md);
      cursor: pointer;
      font-weight: 600;
      background: var(--theme-surface);
      color: var(--theme-text);
      transition: all 0.2s ease;
    }

    button:hover {
      background: var(--theme-surface-hover);
      transform: translateY(-1px);
    }

    .btn-primary {
      background: var(--brand-primary);
      color: var(--on-primary);
      border-color: var(--brand-primary);
    }

    .btn-success {
      background: var(--success);
      color: white;
      border-color: var(--success);
    }

    .btn-warning {
      background: var(--warning);
      color: var(--on-warning);
      border-color: var(--warning);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin: 1rem 0;
    }

    th,
    td {
      padding: 0.8rem;
      text-align: left;
      border-bottom: 1px solid var(--theme-border);
      color: var(--theme-text);
    }

    th {
      background: var(--theme-surface-elevated);
      font-weight: 600;
      color: var(--theme-text-muted);
    }

    .score-cell {
      font-weight: bold;
      padding: 0.5rem;
      border-radius: 4px;
      text-align: center;
    }

    /* Responsive Grid for Metrics & Indicators */
    .metrics-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 1rem;
    }

    .metrics-grid .metric {
      margin: 0;
      /* Let grid gap handle spacing */
      height: 100%;
      /* Uniform height */
      box-sizing: border-box;
    }

    @media (min-width: 992px) {
      .metrics-grid {
        grid-template-columns: 1fr 1fr;
      }
    }

    /* Cycle Position Timeline */
    .phase-timeline { display: flex; flex-direction: column; gap: 0.5rem; }
    .phase-item { display: flex; align-items: center; gap: 0.75rem; }
    .phase-dot {
      width: 22px; height: 22px; border-radius: 50%; display: flex;
      align-items: center; justify-content: center; font-size: 0.65rem;
      font-weight: 700; flex-shrink: 0; border: 2px solid;
    }
    .phase-dot.done { background: color-mix(in srgb, var(--success) 15%, transparent); color: var(--success); border-color: var(--success); }
    .phase-dot.active { background: color-mix(in srgb, var(--danger) 15%, transparent); color: var(--danger); border-color: var(--danger); }
    .phase-dot.future { color: var(--theme-text-muted); border-color: var(--theme-border); }
    .phase-info { flex: 1; }
    .phase-label { font-size: 0.85rem; }
    .phase-label.done { color: var(--success); }
    .phase-label.active { color: var(--danger); font-weight: 700; }
    .phase-label.future { color: var(--theme-text-muted); }
    .phase-time { font-size: 0.75rem; color: var(--theme-text-muted); }
    .phase-bar { height: 3px; background: var(--theme-border); border-radius: 2px; margin-top: 4px; overflow: hidden; }
    .phase-fill { height: 100%; border-radius: 2px; }
    .phase-fill.done { background: var(--success); }
    .phase-fill.active { background: linear-gradient(90deg, var(--danger), transparent); }

    /* Cycle Chart Tabs */
    .cycle-tabs { display: flex; gap: 0.5rem; flex-wrap: wrap; }
    .cycle-tab {
      padding: 0.5rem 1rem; border-radius: var(--radius-md);
      border: 1px solid var(--theme-border); background: var(--theme-surface);
      color: var(--theme-text-muted); cursor: pointer; font-size: 0.85rem; font-weight: 600;
    }
    .cycle-tab:hover { background: var(--theme-surface-hover); }
    .cycle-tab.active { background: var(--brand-primary); color: var(--on-primary); border-color: var(--brand-primary); }

    /* Anatomy Table */
    #cycle-anatomy-table td:first-child { font-weight: 600; color: var(--theme-text-muted); font-size: 0.85em; white-space: nowrap; }
    #cycle-anatomy-table td:last-child { color: var(--warning); font-weight: 600; }
  </style>
  <!-- Navigation unifi√©e (conditionnelle) -->
  <!-- Note: navigation is conditionally loaded above; avoid duplicate wrong path -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/luxon@3.4.4/build/global/luxon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.3.1/dist/chartjs-adapter-luxon.umd.min.js"></script>

  <script type="module" src="components/tooltips.js"></script>
</head>

<body>

  <main class="wrap">
    <!-- Page Header (Feb 2026) -->
    <div class="page-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
      <h1 style="margin: 0;">Bitcoin Cycle Analysis</h1>
      <view-toggle></view-toggle>
    </div>

    <!-- Navigation contextuelle Risk Domain (Feb 2026) -->
    <domain-nav domain="risk"></domain-nav>

    <!-- Contr√¥les + Terminal -->
    <div class="card controls-card">
      <div class="controls-left">
        <h2>Analysis Controls</h2>
        <p>Cycle model execution &amp; calibration</p>
        <div class="controls-actions">
          <button class="btn-primary control-btn" onclick="runFullAnalysis()">
            <span class="icon">üöÄ</span><span>Full Analysis</span>
          </button>
          <button class="btn-success control-btn" onclick="calibrateModel()">
            <span class="icon">‚öôÔ∏è</span><span>Calibrate</span>
          </button>
          <button class="btn-warning control-btn" onclick="testAlternatives()">
            <span class="icon">üß™</span><span>Alternatives</span>
          </button>
          <button class="btn-primary control-btn" onclick="generateReport()">
            <span class="icon">üìä</span><span>Report</span>
          </button>
        </div>
      </div>
      <div id="analysis-results" class="term"></div>
    </div>

    <!-- M√©triques de Pr√©cision -->
    <div class="card">
      <h2>üìä Model Precision Metrics</h2>
      <div id="precision-metrics" class="metrics-grid"></div>
    </div>

    <!-- Cycle Position Indicator -->
    <div class="card">
      <h2>üìç Position in Cycle 4</h2>
      <p style="color: var(--theme-text-muted); font-size: 0.85em; margin-bottom: 1rem;">
        Based on the ~4-year halving cycle. Historical pattern: halving ‚Üí peak ‚âà 546 days, peak ‚Üí bottom ‚âà 12 months.
      </p>
      <div id="cycle-position" class="phase-timeline"></div>
    </div>

    <!-- Graphique Historique Bitcoin avec Halvings -->
    <div class="card">
      <h2>üìà Bitcoin Historical Price & Cycle Score</h2>
      <p style="color: var(--theme-text-muted); font-size: 0.9em; margin-bottom: 1rem;">
        Bitcoin historical price (log scale) with computed cycle score.
        Vertical lines indicate halvings.
      </p>
      <div class="chart-container" style="height: 500px;">
        <canvas id="bitcoin-cycle-chart"></canvas>
      </div>
      <div id="bitcoin-chart-status"
        style="text-align: center; margin-top: 0.5rem; color: var(--theme-text-muted); font-size: 0.85em;">
        Loading chart...
      </div>
    </div>

    <!-- Cycle Comparison Charts -->
    <div class="card">
      <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 0.5rem; margin-bottom: 0.5rem;">
        <h2 style="margin: 0;">üìä Cycle-over-Cycle Comparison</h2>
        <div class="cycle-tabs">
          <button class="cycle-tab active" onclick="switchCycleTab('compare')" aria-label="Normalized performance view">üîÑ Normalized</button>
          <button class="cycle-tab" onclick="switchCycleTab('drawdown')" aria-label="Drawdown comparison view">üìâ Drawdown</button>
        </div>
      </div>
      <div id="compare-panel">
        <p style="color: var(--theme-text-muted); font-size: 0.85em; margin-bottom: 0.5rem;">
          Performance normalized to 100 at halving. Diminishing returns pattern: Cycle 2 x30, Cycle 3 x8, Cycle 4 x2.
        </p>
        <div class="chart-container"><canvas id="comparison-chart"></canvas></div>
      </div>
      <div id="drawdown-panel" style="display: none;">
        <p style="color: var(--theme-text-muted); font-size: 0.85em; margin-bottom: 0.5rem;">
          Drawdown from cycle peak. Previous bears bottomed at M+12 around -78% to -84%.
        </p>
        <div class="chart-container"><canvas id="drawdown-chart"></canvas></div>
      </div>
    </div>

    <!-- Cycle Anatomy Table -->
    <div class="card">
      <h2>‚è± Cycle Anatomy ‚Äî Historical Comparison</h2>
      <div style="overflow-x: auto;">
        <table id="cycle-anatomy-table">
          <thead>
            <tr>
              <th scope="col"></th>
              <th scope="col">Cycle 2</th>
              <th scope="col">Cycle 3</th>
              <th scope="col">Cycle 4 (current)</th>
            </tr>
          </thead>
          <tbody>
            <tr><td>Halving</td><td>Jul 2016</td><td>May 2020</td><td>Apr 2024</td></tr>
            <tr><td>Halving price</td><td>$650</td><td>$9,500</td><td>$64,000</td></tr>
            <tr><td>Peak</td><td>Dec 2017</td><td>Nov 2021</td><td>TBD</td></tr>
            <tr><td>Peak price</td><td>$19,700</td><td>$69,000</td><td>TBD</td></tr>
            <tr><td>Return halving‚Üípeak</td><td>+2,930%</td><td>+702%</td><td>TBD</td></tr>
            <tr><td>Halving ‚Üí Peak</td><td>526 days</td><td>546 days</td><td>~546 days?</td></tr>
            <tr><td>Bottom</td><td>Dec 2018</td><td>Nov 2022</td><td>?</td></tr>
            <tr><td>Bottom price</td><td>$3,200</td><td>$16,500</td><td>?</td></tr>
            <tr><td>Max drawdown</td><td>-84%</td><td>-78%</td><td>In progress</td></tr>
            <tr><td>Peak ‚Üí Bottom</td><td>~12 months</td><td>~12 months</td><td>?</td></tr>
          </tbody>
        </table>
      </div>
      <p style="color: var(--theme-text-muted); font-size: 0.8em; margin-top: 0.5rem;">
        Cycle 4 peak/bottom not yet confirmed. Approximate monthly prices used for comparison charts.
      </p>
    </div>

    <!-- Graphique de Validation -->
    <div class="card">
      <h2>üìä Visual Validation - Predictions vs Reality</h2>
      <div class="chart-container">
        <canvas id="validation-chart"></canvas>
      </div>
    </div>

    <!-- Analyse des Erreurs -->
    <div class="card">
      <h2>üîç Error Analysis by Cycle</h2>
      <table id="error-analysis-table">
        <thead>
          <tr>
            <th scope="col">Cycle</th>
            <th scope="col">Halving</th>
            <th scope="col">Actual Peak</th>
            <th scope="col">Predicted Peak</th>
            <th scope="col">Error</th>
            <th scope="col">Actual Score</th>
            <th scope="col">Model Score</th>
            <th scope="col">Accuracy</th>
          </tr>
        </thead>
        <tbody id="error-table-body"></tbody>
      </table>
    </div>

    <!-- Indicateurs Compl√©mentaires -->
    <div class="card">
      <h2>üåü Recommended On-Chain Indicators</h2>
      <div id="indicators-suggestions" class="metrics-grid"></div>
    </div>

  </main>

  <script src="debug-logger.js"></script>
  <script type="module">
    // Variables globales pour les modules
    let cycleScoreFromMonths, getCycleParams, calibrateCycleParams, getCurrentCycleMonths;
    let moduleLoaded = false;

    // Import Bitcoin cycle chart functions
    import { createBitcoinCycleChart, fetchBitcoinHistoricalData } from './modules/risk-cycles-tab.js';

    // Bitcoin halvings data (needed for chart)
    window.BITCOIN_HALVINGS = [
      { date: '2012-11-28', block: 210000, reward: 25, estimated: false },
      { date: '2016-07-09', block: 420000, reward: 12.5, estimated: false },
      { date: '2020-05-11', block: 630000, reward: 6.25, estimated: false },
      { date: '2024-04-20', block: 840000, reward: 3.125, estimated: false },
      { date: '2028-04-01', block: 1050000, reward: 1.5625, estimated: true }
    ];

    // Initialize Bitcoin cycle chart
    async function initBitcoinCycleChart() {
      const statusEl = document.getElementById('bitcoin-chart-status');
      try {
        // Import store if available
        try {
          const { store } = await import('./core/risk-dashboard-store.js');
          window.store = store;
        } catch (e) {
          // Fallback: create minimal store
          window.store = {
            snapshot: () => ({ cycle: { months: 0, ccs_star: 50 } })
          };
        }

        // Provide cache helpers
        window.getCachedData = (key) => {
          try {
            const cached = localStorage.getItem(`cache_${key}`);
            return cached ? JSON.parse(cached) : null;
          } catch { return null; }
        };
        window.setCachedData = (key, data) => {
          try {
            localStorage.setItem(`cache_${key}`, JSON.stringify(data));
          } catch { }
        };

        await createBitcoinCycleChart('bitcoin-cycle-chart', true);
        if (statusEl) {
          statusEl.textContent = '‚úÖ Chart loaded successfully';
          statusEl.style.color = 'var(--success)';
        }
      } catch (error) {
        console.error('Failed to create Bitcoin cycle chart:', error);
        if (statusEl) {
          statusEl.textContent = `‚ùå Error: ${error.message}`;
          statusEl.style.color = 'var(--danger)';
        }
      }
    }

    // Donn√©es historiques des cycles Bitcoin
    const HISTORICAL_CYCLES = [
      {
        id: 1,
        halving: '2012-11-28',
        peak: '2013-11-30',
        peakPrice: 1177,
        bottom: '2015-01-14',
        bottomPrice: 152,
        cycleHigh: 1177,
        cycleLow: 65
      },
      {
        id: 2,
        halving: '2016-07-09',
        peak: '2017-12-17',
        peakPrice: 19783,
        bottom: '2018-12-15',
        bottomPrice: 3122,
        cycleHigh: 19783,
        cycleLow: 365
      },
      {
        id: 3,
        halving: '2020-05-11',
        peak: '2021-11-10',
        peakPrice: 68789,
        bottom: '2022-11-21',
        bottomPrice: 15460,
        cycleHigh: 68789,
        cycleLow: 3850
      },
      {
        id: 4,
        halving: '2024-04-20',
        peak: null, // En cours
        peakPrice: null,
        bottom: null,
        bottomPrice: null,
        // Prix actuel r√©cup√©r√© dynamiquement (voir fetchCurrentBTCPrice())
        currentPrice: null,
        cycleHigh: null,
        cycleLow: null
      }
    ];

    // --- Fallback local si le module ne se charge pas ---
    // Double-sigmo√Øde (coh√©rente avec cycle-navigator.js) - cloche 0‚Üí100
    function _fallbackCycleScoreFromMonths(m) {
      // Param√®tres CALIBR√âS IDENTIQUES au module principal (synchronis√©s)
      // Ces valeurs sont le r√©sultat de la calibration sur les 3 complete cycles
      const m48 = m % 48;
      const m_rise_center = 5.0;  // Calibr√© (depuis 7.0)
      const m_fall_center = 24.0; // Calibr√© (depuis 30.0)
      const k_rise = 0.8;         // Calibr√© (depuis 1.0)
      const k_fall = 1.2;         // Calibr√© (depuis 0.9)
      const p_shape = 1.15;       // Calibr√© (depuis 0.9)

      const rise = 1 / (1 + Math.exp(-k_rise * (m48 - m_rise_center)));
      const fall = 1 / (1 + Math.exp(-k_fall * (m_fall_center - m48)));
      const base = rise * fall;
      const score = Math.pow(base, p_shape) * 100;

      return Math.max(0, Math.min(100, score));
    }
    function _fallbackGetCycleParams() {
      // Param√®tres CALIBR√âS (synchronis√©s avec cycle-navigator.js)
      return { m_rise_center: 5.0, m_fall_center: 24.0, k_rise: 0.8, k_fall: 1.2, p_shape: 1.15 };
    }
    function _fallbackCalibrate() { return { score: 0, params: _fallbackGetCycleParams() }; }
    function _fallbackGetCurrentCycleMonths() {
      const lastHalving = new Date('2024-04-20');
      const now = new Date();
      const months = (now - lastHalving) / (1000 * 60 * 60 * 24 * 30.44);
      return Math.max(0, months);
    }


    // Persistance des param√®tres calibr√©s
    // IMPORTANT: Version must match CALIBRATION_VERSION in cycle-navigator.js
    const CALIBRATION_VERSION = '2.0';

    function saveCalibrationParams(params) {
      try {
        localStorage.setItem('bitcoin_cycle_params', JSON.stringify({
          params: params,
          timestamp: Date.now(),
          version: CALIBRATION_VERSION
        }));
        console.debug('‚úÖ Param√®tres calibr√©s sauvegard√©s', params);
      } catch (error) {
        debugLogger.error('‚ùå Erreur sauvegarde param√®tres:', error);
      }
    }

    function loadCalibrationParams() {
      try {
        const saved = localStorage.getItem('bitcoin_cycle_params');
        if (saved) {
          const data = JSON.parse(saved);
          // V√©rifier que les donn√©es ne sont pas trop anciennes (24h)
          if (Date.now() - data.timestamp < 24 * 60 * 60 * 1000) {
            console.debug('‚úÖ Param√®tres calibr√©s charg√©s depuis localStorage', data.params);
            return data.params;
          }
        }
      } catch (error) {
        debugLogger.error('‚ùå Erreur chargement param√®tres:', error);
      }
      return null;
    }

    // Chargement des modules
    async function loadModules() {
      try {
        console.debug('üîÑ Tentative de chargement du module cycle-navigator...');
        const module = await import('./modules/cycle-navigator.js');

        // V√©rifier que les fonctions sont disponibles
        if (!module.cycleScoreFromMonths) {
          throw new Error('cycleScoreFromMonths function not available in module');
        }

        cycleScoreFromMonths = module.cycleScoreFromMonths;
        getCycleParams = module.getCycleParams;
        calibrateCycleParams = module.calibrateCycleParams;
        getCurrentCycleMonths = module.getCurrentCycleMonths;

        // Test de la fonction
        const testScore = cycleScoreFromMonths(18);
        console.debug('üß™ Test cycleScoreFromMonths(18):', testScore);

        if (isNaN(testScore) || testScore < 0 || testScore > 100) {
          throw new Error('Function test failed - invalid score: ' + testScore);
        }

        // Charger les param√®tres sauvegard√©s si disponibles
        const savedParams = loadCalibrationParams();
        if (savedParams) {
          module.setCycleParams(savedParams);
          addResult('üîÑ Auto-Load', 'Previous calibrated parameters applied', 'good');
        }

        moduleLoaded = true;
        console.debug('‚úÖ Cycle navigator module loaded successfully');
        return true;
      } catch (error) {
        debugLogger.error('‚ùå Failed to load cycle navigator:', error);
        // üîÅ Fallback local pour que le graphe fonctionne quand m√™me
        cycleScoreFromMonths = _fallbackCycleScoreFromMonths;
        getCycleParams = _fallbackGetCycleParams;
        calibrateCycleParams = _fallbackCalibrate;
        getCurrentCycleMonths = _fallbackGetCurrentCycleMonths;
        moduleLoaded = true; // on passe √† true pour ne pas bloquer la suite
        addResult('‚ö†Ô∏è Degraded mode', 'Module non charg√© ‚Äî utilisation d\'un mod√®le local par d√©faut', 'warning');
        console.debug('üîÑ Utilisation du fallback, test:', _fallbackCycleScoreFromMonths(18));
        return true;
      }
    }


    // R√©cup√©ration du prix BTC actuel depuis l'API
    async function fetchCurrentBTCPrice() {
      try {
        // Essayer CoinGecko d'abord (pas de rate limit strict)
        const response = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd');
        if (response.ok) {
          const data = await response.json();
          const price = data?.bitcoin?.usd;
          if (typeof price === 'number' && price > 0) {
            console.debug('‚úÖ Prix BTC r√©cup√©r√©:', price);
            return price;
          }
        }
      } catch (e) {
        debugLogger.warn('CoinGecko fetch failed, trying fallback:', e.message);
      }

      // Fallback: essayer via le store (qui peut avoir des donn√©es r√©centes)
      try {
        const state = window.store?.snapshot();
        const btcPrice = state?.prices?.BTC;
        if (typeof btcPrice === 'number' && btcPrice > 0) {
          console.debug('‚úÖ Prix BTC depuis store:', btcPrice);
          return btcPrice;
        }
      } catch (e) {
        debugLogger.warn('Store price fetch failed:', e.message);
      }

      // Dernier fallback: estimation raisonnable bas√©e sur la date
      const defaultPrice = 100000; // Estimation conservatrice jan 2026
      console.debug('‚ö†Ô∏è Prix BTC par d√©faut utilis√©:', defaultPrice);
      return defaultPrice;
    }

    function parseISODateStrict(value) {
      if (value instanceof Date) return value;
      if (typeof value === 'string') {
        // Parse YYYY-MM-DD de fa√ßon robuste (UTC) pour √©viter les √©carts de locale
        const m = value.trim().match(/^(\d{4})-(\d{2})-(\d{2})$/);
        if (m) {
          const y = Number(m[1]);
          const mo = Number(m[2]);
          const d = Number(m[3]);
          return new Date(Date.UTC(y, mo - 1, d));
        }
      }
      // Fallback parsing
      const dt = new Date(value);
      return isNaN(dt.getTime()) ? null : dt;
    }

    function monthsBetween(dateA, dateB) {
      const a = parseISODateStrict(dateA);
      const b = parseISODateStrict(dateB);
      if (!a || !b) {
        debugLogger.warn('monthsBetween: invalid date(s)', { dateA, dateB });
        return NaN;
      }

      // Calcul pr√©cis des mois entre deux dates
      const years = b.getUTCFullYear() - a.getUTCFullYear();
      const months = b.getUTCMonth() - a.getUTCMonth();
      const days = b.getUTCDate() - a.getUTCDate();

      let totalMonths = years * 12 + months;

      // Ajuster pour les jours
      if (days > 0) {
        totalMonths += days / 30.44; // Moyenne des jours par mois
      } else if (days < 0) {
        totalMonths -= Math.abs(days) / 30.44;
      }

      return totalMonths;
    }

    function addResult(title, content, type = 'info') {
      const term = document.getElementById('analysis-results');
      const cls = type === 'good' ? 'ok' : type === 'warning' ? 'warn' : type === 'error' ? 'err' : 'dim';
      const prefix = type === 'good' ? '  OK ' : type === 'warning' ? 'WARN ' : type === 'error' ? ' ERR ' : 'INFO ';
      const ts = new Date().toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
      const line = document.createElement('div');
      line.className = 'line';
      line.innerHTML = `<span class="ts">[${ts}]</span> <span class="${cls}">${prefix}</span>${title}  <span class="val">${content}</span>`;
      term.appendChild(line);
      term.scrollTop = term.scrollHeight;
    }

    // Calcul des m√©triques accuracy
    function calculatePrecisionMetrics() {
      if (!moduleLoaded || !cycleScoreFromMonths) {
        debugLogger.error('cycleScoreFromMonths function not available');
        return { avgPeakError: 0, avgBottomError: 0, overallAccuracy: 0, completedCycles: [] };
      }

      const completedCycles = HISTORICAL_CYCLES.filter(c => c.peak && c.bottom);
      let totalError = 0;
      let peakErrors = [];
      let bottomErrors = [];

      const metrics = document.getElementById('precision-metrics');
      if (!metrics) {
        debugLogger.error('precision-metrics element not found');
        return { avgPeakError: 0, avgBottomError: 0, overallAccuracy: 0, completedCycles: [] };
      }

      metrics.innerHTML = '';

      completedCycles.forEach(cycle => {
        const monthsToPeak = monthsBetween(cycle.halving, cycle.peak);
        const monthsToBottom = monthsBetween(cycle.halving, cycle.bottom);

        const predictedPeakScore = cycleScoreFromMonths(monthsToPeak);
        const predictedBottomScore = cycleScoreFromMonths(monthsToBottom);

        // On s'attend √† peak ‚âà 100, bottom ‚âà 10
        const peakError = Math.abs(100 - predictedPeakScore);
        const bottomError = Math.abs(10 - predictedBottomScore);

        peakErrors.push(peakError);
        bottomErrors.push(bottomError);
        totalError += peakError + bottomError;
      });

      // M√©triques globales
      const avgPeakError = peakErrors.reduce((a, b) => a + b, 0) / peakErrors.length;
      const avgBottomError = bottomErrors.reduce((a, b) => a + b, 0) / bottomErrors.length;
      const overallAccuracy = Math.max(0, 100 - (totalError / completedCycles.length / 2));

      // Calculer le score actuel (aujourd'hui)
      const currentCycleData = getCurrentCycleMonths();
      const currentMonths = typeof currentCycleData === 'object' ? currentCycleData.months : currentCycleData;
      const currentScore = cycleScoreFromMonths(currentMonths);
      const today = new Date().toLocaleDateString('en-US');

      // Affichage des m√©triques
      metrics.innerHTML = `
        <div class="metric good" style="background: linear-gradient(135deg, var(--success-bg) 0%, var(--info-bg) 100%); border: 2px solid var(--success);">
          <span style="font-weight: 700;">Current Score (${today}):</span>
          <span style="font-size: 1.3em; font-weight: 800;">${currentScore.toFixed(1)}/100</span>
        </div>
        <div class="metric good" style="border-left: 4px solid var(--info);">
          <span>Months since Halving:</span>
          <span>${currentMonths.toFixed(1)} months (since April 20, 2024)</span>
        </div>
        <div class="metric ${avgPeakError < 15 ? 'good' : avgPeakError < 30 ? 'warning' : 'error'}">
          <span>Avg Peak Error:</span>
          <span>${avgPeakError.toFixed(1)} points</span>
        </div>
        <div class="metric ${avgBottomError < 20 ? 'good' : avgBottomError < 35 ? 'warning' : 'error'}">
          <span>Average Bottom Error:</span>
          <span>${avgBottomError.toFixed(1)} points</span>
        </div>
        <div class="metric ${overallAccuracy > 80 ? 'good' : overallAccuracy > 60 ? 'warning' : 'error'}">
          <span>Overall Accuracy:</span>
          <span>${overallAccuracy.toFixed(1)}%</span>
        </div>
        <div class="metric good">
          <span>Cycles Analyzed:</span>
          <span>${completedCycles.length}/3 complete cycles</span>
        </div>
      `;

      return { avgPeakError, avgBottomError, overallAccuracy, completedCycles };
    }

    // Graphique de validation
    function createValidationChart() {
      if (!moduleLoaded || !cycleScoreFromMonths) {
        debugLogger.error('cycleScoreFromMonths function not available');
        return;
      }

      const canvas = document.getElementById('validation-chart');
      const ctx = canvas.getContext('2d');

      // V√©rifier que Chart.js est charg√©
      if (typeof Chart === 'undefined') {
        debugLogger.error('Chart.js not loaded');
        return;
      }

      // G√©n√©rer les donn√©es du mod√®le
      const modelData = [];
      for (let months = 0; months <= 48; months++) {
        modelData.push({
          x: months,
          y: cycleScoreFromMonths(months)
        });
      }

      // Points historiques r√©els
      const historicalPoints = [];
      HISTORICAL_CYCLES.forEach(cycle => {
        if (cycle.peak) {
          const monthsToPeak = monthsBetween(cycle.halving, cycle.peak);
          if (Number.isFinite(monthsToPeak)) historicalPoints.push({
            x: Number(monthsToPeak),
            y: 100, // On consid√®re le pic comme score 100
            label: `Cycle ${cycle.id} Peak`,
            color: '#dc2626'
          });
        }
        if (cycle.bottom) {
          const monthsToBottom = monthsBetween(cycle.halving, cycle.bottom);
          if (Number.isFinite(monthsToBottom)) historicalPoints.push({
            x: Number(monthsToBottom),
            y: 10, // On consid√®re le creux comme score 10
            label: `Cycle ${cycle.id} Bottom`,
            color: '#059669'
          });
        }
      });

      // Point courant (mois depuis le dernier halving)
      try {
        const currentCycle = HISTORICAL_CYCLES.find(c => c.id === 4);
        if (currentCycle && currentCycle.halving) {
          const now = new Date();
          const mNow = monthsBetween(currentCycle.halving, now);
          if (Number.isFinite(mNow)) {
            historicalPoints.push({
              x: Number(mNow),
              y: cycleScoreFromMonths(Number(mNow)),
              label: 'Cycle 4 Current',
              color: '#0ea5e9'
            });
          }
        }
      } catch (_) { /* ignore */ }

      // D√©truire chart existant si n√©cessaire
      const existingChart = Chart.getChart(ctx);
      if (existingChart) {
        existingChart.destroy();
      }

      const chart = new Chart(ctx, {
        type: 'line',
        data: {
          datasets: [
            {
              label: 'Sigmoid Model',
              data: modelData,
              borderColor: '#3b82f6',
              backgroundColor: 'rgba(59, 130, 246, 0.1)',
              borderWidth: 3,
              fill: false,
              pointRadius: 0
            },
            {
              label: 'Actual Historical Points',
              data: historicalPoints,
              pointBackgroundColor: historicalPoints.map(p => p.color),
              pointBorderColor: historicalPoints.map(p => p.color),
              pointRadius: 8,
              pointHoverRadius: 10,
              showLine: false
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              type: 'linear',
              title: { display: true, text: 'Months after Halving' },
              min: 0,
              max: 48,
              ticks: { stepSize: 6 }
            },
            y: {
              title: { display: true, text: 'Cycle Score (0-100)' },
              min: 0,
              max: 100
            }
          },
          plugins: {
            tooltip: {
              callbacks: {
                label: function (context) {
                  const point = context.raw;
                  return point.label || `Score: ${context.parsed.y}`;
                }
              }
            }
          }
        }
      });
    }

    // Tableau d'analyse des erreurs
    function populateErrorTable() {
      if (!moduleLoaded || !cycleScoreFromMonths) {
        debugLogger.error('cycleScoreFromMonths function not available');
        return;
      }

      const tbody = document.getElementById('error-table-body');
      if (!tbody) {
        debugLogger.error('error-table-body element not found');
        return;
      }

      tbody.innerHTML = '';

      HISTORICAL_CYCLES.forEach(cycle => {
        if (!cycle.peak) return;

        const monthsToPeak = monthsBetween(cycle.halving, cycle.peak);
        const predictedScore = cycleScoreFromMonths(monthsToPeak);
        const error = Math.abs(100 - predictedScore);
        const accuracy = Math.max(0, 100 - error);

        const row = document.createElement('tr');
        row.innerHTML = `
          <td>Cycle ${cycle.id}</td>
          <td>${new Date(cycle.halving).toLocaleDateString('en-US')}</td>
          <td>${new Date(cycle.peak).toLocaleDateString('en-US')}</td>
          <td>${monthsToPeak.toFixed(1)} mois</td>
          <td class="score-cell ${error < 15 ? 'good' : error < 30 ? 'warning' : 'error'}">${error.toFixed(1)}</td>
          <td>100 (pic)</td>
          <td>${predictedScore.toFixed(1)}</td>
          <td class="score-cell ${accuracy > 80 ? 'good' : accuracy > 60 ? 'warning' : 'error'}">${accuracy.toFixed(1)}%</td>
        `;
        tbody.appendChild(row);
      });
    }

    // Suggestions d'indicateurs on-chain
    function showIndicatorsSuggestions() {
      const container = document.getElementById('indicators-suggestions');

      const indicators = [
        {
          name: "MVRV Ratio",
          description: "Market Value to Realized Value - Detects over/undervaluation",
          api: "Glassnode, CoinMetrics",
          priority: "üî• Haute",
          reason: "Strongly correlates with market cycles"
        },
        {
          name: "NVT Ratio",
          description: "Network Value to Transactions - Bitcoin P/E ratio",
          api: "Blockchain.info, Messari",
          priority: "üî• High",
          reason: "Indicates real usage vs speculation"
        },
        {
          name: "Puell Multiple",
          description: "Mining revenue vs 365d average - Precise historical timing",
          api: "Glassnode",
          priority: "üü° Medium",
          reason: "Reveals accumulation/distribution zones"
        },
        {
          name: "RHODL Ratio",
          description: "Realized HODL Ratio - HODLer behavior",
          api: "Glassnode",
          priority: "üî• High",
          reason: "Predicts market movements via cohort analysis"
        },
        {
          name: "Stock-to-Flow Deviation",
          description: "Deviation between actual price and S2F model",
          api: "Custom calculation",
          priority: "üü° Medium",
          reason: "Complement to the scarcity model"
        },
        {
          name: "Fear & Greed Index",
          description: "Aggregated market sentiment",
          api: "Alternative.me",
          priority: "üü¢ Low",
          reason: "Contrarian indicator for extremes"
        }
      ];

      container.innerHTML = indicators.map(ind => `
        <div class="metric good" style="display: block;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
            <strong>${ind.name}</strong>
            <span style="font-size: 0.9em;">${ind.priority}</span>
          </div>
          <div style="font-size: 0.9em; margin: 0.3rem 0;">
            üìä ${ind.description}
          </div>
          <div style="font-size: 0.8em; color: #666;">
            üîó API: ${ind.api} | üí° ${ind.reason}
          </div>
        </div>
      `).join('');
    }

    // ========== CYCLE COMPARISON DATA ==========
    // Cycles 2 & 3: historical (fixed). Cycle 4: loaded dynamically from CoinGecko.
    const CYCLE_COMPARE = {
      months: [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30],
      cycle2: {
        label: 'Cycle 2 (Jul 2016)',
        halvingPrice: 650,
        prices: [650, 700, 780, 970, 1250, 2500, 4700, 8200, 14000, 19700, 10000, 7000, 6400, 4000, 3500, 3800],
        color: '#a855f7'
      },
      cycle3: {
        label: 'Cycle 3 (May 2020)',
        halvingPrice: 9500,
        prices: [9500, 9100, 10800, 19700, 33000, 59000, 37000, 42000, 61000, 69000, 38000, 40000, 20000, 19300, 16500, 23000],
        color: '#3b82f6'
      },
      cycle4: {
        label: 'Cycle 4 CURRENT (Apr 2024)',
        halvingPrice: 64000,
        prices: [], // Filled dynamically
        color: '#f59e0b'
      }
    };

    const DRAWDOWN_COMPARE = {
      months: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12],
      cycle2: {
        label: 'Cycle 2 (bottom -84%)',
        peakPrice: 19700,
        prices: [19700, 10000, 10500, 6900, 9200, 7500, 6400, 8200, 7000, 6600, 6300, 4000, 3200],
        color: '#a855f7'
      },
      cycle3: {
        label: 'Cycle 3 (bottom -76%)',
        peakPrice: 69000,
        prices: [69000, 47000, 38000, 44000, 45000, 40000, 31800, 20000, 23000, 20000, 19300, 20500, 16500],
        color: '#3b82f6'
      },
      cycle4: {
        label: 'Cycle 4 (loading...)',
        peakPrice: 0,
        prices: [], // Filled dynamically
        color: '#f43f5e'
      }
    };

    // Dynamic state for cycle 4 ‚Äî updated from live data
    let cycle4State = {
      currentPrice: 0, ath: 0, athDate: null,
      drawdown: 0, trend30d: 0, monthsSinceHalving: 0,
      cycleScore: 50, currentPhase: 4
    };

    const HALVING_DATE = new Date('2024-04-20');

    // ========== DYNAMIC DATA LOADING ==========
    async function fetchBTCPriceHistory() {
      const cacheKey = 'btc_cycle_history';
      try {
        const cached = localStorage.getItem(cacheKey);
        if (cached) {
          const data = JSON.parse(cached);
          if (Date.now() - data.ts < 3600000) { // 1h cache
            console.debug('‚úÖ BTC cycle prices from cache');
            return data.prices;
          }
        }
      } catch (e) { /* ignore */ }

      try {
        const days = Math.ceil((Date.now() - HALVING_DATE.getTime()) / 86400000) + 30;
        const resp = await fetch(
          `https://api.coingecko.com/api/v3/coins/bitcoin/market_chart?vs_currency=usd&days=${days}`
        );
        if (!resp.ok) throw new Error(`CoinGecko ${resp.status}`);
        const data = await resp.json();
        if (!data.prices?.length) throw new Error('No price data');
        try {
          localStorage.setItem(cacheKey, JSON.stringify({ prices: data.prices, ts: Date.now() }));
        } catch (e) { /* full */ }
        console.debug(`‚úÖ BTC price history: ${data.prices.length} points`);
        return data.prices;
      } catch (e) {
        console.warn('CoinGecko historical fetch failed:', e);
        return null;
      }
    }

    function processHistoricalData(rawPrices) {
      const halvingTs = HALVING_DATE.getTime();
      const cyclePrices = rawPrices.filter(([ts]) => ts >= halvingTs - 86400000 * 7);
      if (cyclePrices.length < 10) return null;

      const allP = cyclePrices.map(([_, p]) => p);
      const currentPrice = allP[allP.length - 1];
      const ath = Math.max(...allP);
      const athIdx = allP.indexOf(ath);
      const athDate = new Date(cyclePrices[athIdx][0]);
      const drawdown = (currentPrice - ath) / ath;
      const idx30d = Math.max(0, allP.length - 30);
      const trend30d = (currentPrice - allP[idx30d]) / allP[idx30d];
      const now = new Date();
      const monthsSinceHalving = (now - HALVING_DATE) / (1000 * 60 * 60 * 24 * 30.44);

      // Extract bimonthly closes from halving (for comparison chart)
      const bimonthly = [];
      for (let m = 0; m <= 30; m += 2) {
        const targetDate = new Date(HALVING_DATE);
        targetDate.setMonth(targetDate.getMonth() + m);
        if (targetDate > now) break;
        const targetTs = targetDate.getTime();
        let closest = cyclePrices[0], minDist = Infinity;
        for (const dp of cyclePrices) {
          const dist = Math.abs(dp[0] - targetTs);
          if (dist < minDist) { minDist = dist; closest = dp; }
        }
        bimonthly.push(Math.round(closest[1]));
      }

      // Extract monthly closes from peak (for drawdown chart)
      const postPeak = cyclePrices.filter(([ts]) => ts >= cyclePrices[athIdx][0]);
      const peakMonthly = [];
      for (let m = 0; m <= 12; m++) {
        const targetDate = new Date(athDate);
        targetDate.setMonth(targetDate.getMonth() + m);
        if (targetDate > now) break;
        const targetTs = targetDate.getTime();
        let closest = postPeak[0], minDist = Infinity;
        for (const dp of postPeak) {
          const dist = Math.abs(dp[0] - targetTs);
          if (dist < minDist) { minDist = dist; closest = dp; }
        }
        peakMonthly.push(Math.round(closest[1]));
      }

      return {
        currentPrice: Math.round(currentPrice), ath: Math.round(ath), athDate,
        drawdown, trend30d, monthsSinceHalving, bimonthly, peakMonthly
      };
    }

    function detectCyclePhase(data, cycleScore) {
      const { drawdown, trend30d, monthsSinceHalving } = data;
      // Phase 6: Bottom / Re-accumulation
      if (cycleScore < 15 && trend30d > 0.02) return 6;
      // Phase 5: Bear Market / Capitulation
      if (drawdown < -0.40 && trend30d < -0.05) return 5;
      // Phase 4: Distribution / Early Bear
      if (drawdown < -0.15 && trend30d < 0) return 4;
      // Phase 3: Bull Run / Blow-off Top
      if (cycleScore > 50 && trend30d > 0.03) return 3;
      // Phase 2: Post-halving Consolidation
      if (monthsSinceHalving >= 0 && monthsSinceHalving < 8 && Math.abs(trend30d) < 0.10) return 2;
      // Phase 1: Pre-halving Rally
      if (monthsSinceHalving < 0 && trend30d > 0) return 1;
      // Phase 0: Accumulation
      return 0;
    }

    async function loadDynamicCycleData() {
      const raw = await fetchBTCPriceHistory();
      if (!raw) {
        console.warn('‚ö†Ô∏è Using empty cycle 4 data (API unavailable)');
        return false;
      }
      const data = processHistoricalData(raw);
      if (!data) return false;

      // Update comparison data
      CYCLE_COMPARE.cycle4.prices = data.bimonthly;
      CYCLE_COMPARE.cycle4.halvingPrice = data.bimonthly[0] || 64000;

      // Update drawdown data
      DRAWDOWN_COMPARE.cycle4.peakPrice = data.ath;
      DRAWDOWN_COMPARE.cycle4.prices = data.peakMonthly;
      DRAWDOWN_COMPARE.cycle4.label = `Cycle 4 (${Math.round(data.drawdown * 100)}% so far)`;

      // Compute cycle score
      const score = moduleLoaded ? cycleScoreFromMonths(data.monthsSinceHalving) : 50;
      const phase = detectCyclePhase(data, score);

      cycle4State = { ...data, cycleScore: score, currentPhase: phase };

      // Update anatomy table with live data
      updateAnatomyTable(data);

      console.debug('‚úÖ Dynamic cycle 4 loaded', {
        price: `$${data.currentPrice.toLocaleString()}`,
        ath: `$${data.ath.toLocaleString()}`,
        dd: `${(data.drawdown * 100).toFixed(1)}%`,
        trend: `${(data.trend30d * 100).toFixed(1)}%`,
        phase, months: data.monthsSinceHalving.toFixed(1)
      });
      return true;
    }

    function updateAnatomyTable(data) {
      const tbody = document.querySelector('#cycle-anatomy-table tbody');
      if (!tbody) return;
      const fmtDate = d => d.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
      const daysToATH = Math.round((data.athDate - HALVING_DATE) / 86400000);
      const retHalvPeak = Math.round((data.ath / (data.bimonthly[0] || 64000) - 1) * 100);
      const monthsPostPeak = ((Date.now() - data.athDate.getTime()) / (1000 * 60 * 60 * 24 * 30.44)).toFixed(0);

      tbody.innerHTML = `
        <tr><td>Halving</td><td>Jul 2016</td><td>May 2020</td><td>Apr 2024</td></tr>
        <tr><td>Halving price</td><td>$650</td><td>$9,500</td><td>$${(data.bimonthly[0] || 64000).toLocaleString()}</td></tr>
        <tr><td>Peak</td><td>Dec 2017</td><td>Nov 2021</td><td>${fmtDate(data.athDate)}</td></tr>
        <tr><td>Peak price</td><td>$19,700</td><td>$69,000</td><td>$${data.ath.toLocaleString()}</td></tr>
        <tr><td>Return halving‚Üípeak</td><td>+2,930%</td><td>+702%</td><td>+${retHalvPeak}%</td></tr>
        <tr><td>Halving ‚Üí Peak</td><td>526 days</td><td>546 days</td><td>${daysToATH} days</td></tr>
        <tr><td>Current price</td><td>‚Äî</td><td>‚Äî</td><td>$${data.currentPrice.toLocaleString()}</td></tr>
        <tr><td>Drawdown from peak</td><td>-84% (final)</td><td>-76% (final)</td><td>${Math.round(data.drawdown * 100)}% (M+${monthsPostPeak})</td></tr>
        <tr><td>Bottom</td><td>Dec 2018</td><td>Nov 2022</td><td style="color: var(--theme-text-muted);">?</td></tr>
        <tr><td>Peak ‚Üí Bottom</td><td>~12 months</td><td>~12 months</td><td style="color: var(--theme-text-muted);">In progress</td></tr>
      `;
    }

    // ========== CYCLE COMPARISON RENDERING ==========
    function renderCyclePosition() {
      const container = document.getElementById('cycle-position');
      if (!container) return;

      const fmtDate = d => d ? d.toLocaleDateString('en-US', { month: 'short', year: 'numeric' }) : '?';
      const athDate = cycle4State.athDate || new Date();
      // Estimate future phases based on historical pattern (bottom ~12 months post-peak)
      const estBearEnd = new Date(athDate); estBearEnd.setMonth(estBearEnd.getMonth() + 10);
      const estBottom = new Date(athDate); estBottom.setMonth(estBottom.getMonth() + 12);
      const estReaccum = new Date(athDate); estReaccum.setMonth(estReaccum.getMonth() + 15);

      const phases = [
        { phase: 'Accumulation', time: 'Nov 2022 ‚Üí Mar 2024' },
        { phase: 'Pre-halving Rally', time: 'Jan ‚Üí Apr 2024' },
        { phase: 'Post-halving Consolidation', time: 'Apr ‚Üí Oct 2024' },
        { phase: 'Bull Run / Blow-off Top', time: `Nov 2024 ‚Üí ${fmtDate(athDate)}` },
        { phase: 'Distribution / Early Bear', time: `${fmtDate(athDate)} ‚Üí now` },
        { phase: 'Bear Market / Capitulation', time: `est. ‚Üí ~${fmtDate(estBearEnd)}` },
        { phase: 'Bottom / Re-accumulation', time: `est. ~${fmtDate(estBottom)} ‚Üí ${fmtDate(estReaccum)}` },
      ];

      const active = cycle4State.currentPhase;

      container.innerHTML = phases.map((p, i) => {
        const status = i < active ? 'done' : i === active ? 'active' : 'future';
        const icon = status === 'done' ? '‚úì' : status === 'active' ? '‚ñ∏' : '‚óã';
        const suffix = status === 'active' ? ' ‚Üê HERE' : '';
        const pct = status === 'done' ? 100 : status === 'active' ? 50 : 0;
        return `
          <div class="phase-item">
            <div class="phase-dot ${status}">${icon}</div>
            <div class="phase-info">
              <div style="display: flex; justify-content: space-between; align-items: baseline; flex-wrap: wrap; gap: 0.25rem;">
                <span class="phase-label ${status}">${p.phase}${suffix}</span>
                <span class="phase-time">${p.time}</span>
              </div>
              <div class="phase-bar">
                <div class="phase-fill ${status}" style="width: ${pct}%"></div>
              </div>
            </div>
          </div>`;
      }).join('');
    }

    function createComparisonChart() {
      const ctx = document.getElementById('comparison-chart');
      if (!ctx) return;
      const existing = Chart.getChart(ctx);
      if (existing) existing.destroy();

      const datasets = ['cycle2', 'cycle3', 'cycle4'].map(key => {
        const c = CYCLE_COMPARE[key];
        if (!c.prices.length) return null;
        return {
          label: c.label,
          data: c.prices.map((p, i) => ({ x: CYCLE_COMPARE.months[i], y: Math.round(p / c.halvingPrice * 100) })),
          borderColor: c.color,
          borderWidth: key === 'cycle4' ? 3 : 2,
          pointRadius: key === 'cycle4' ? 4 : 3,
          pointBackgroundColor: c.color,
          fill: false, tension: 0.3
        };
      }).filter(Boolean);

      new Chart(ctx, {
        type: 'line',
        data: { datasets },
        options: {
          responsive: true, maintainAspectRatio: false,
          scales: {
            x: { type: 'linear', title: { display: true, text: 'Months after Halving' }, min: 0, max: 30, ticks: { stepSize: 2, callback: v => `M+${v}` } },
            y: { title: { display: true, text: 'Performance (base 100 at halving)' }, min: 0 }
          },
          plugins: { tooltip: { callbacks: { label: c => `${c.dataset.label}: ${c.parsed.y}%` } } }
        }
      });
    }

    function createDrawdownComparisonChart() {
      const ctx = document.getElementById('drawdown-chart');
      if (!ctx) return;
      const existing = Chart.getChart(ctx);
      if (existing) existing.destroy();

      const datasets = ['cycle2', 'cycle3', 'cycle4'].map(key => {
        const c = DRAWDOWN_COMPARE[key];
        if (!c.prices.length) return null;
        return {
          label: c.label,
          data: c.prices.map((p, i) => ({ x: DRAWDOWN_COMPARE.months[i], y: Math.round((p - c.peakPrice) / c.peakPrice * 100) })),
          borderColor: c.color,
          borderWidth: key === 'cycle4' ? 3 : 2,
          pointRadius: key === 'cycle4' ? 4 : 3,
          pointBackgroundColor: c.color,
          fill: false, tension: 0.3
        };
      }).filter(Boolean);

      new Chart(ctx, {
        type: 'line',
        data: { datasets },
        options: {
          responsive: true, maintainAspectRatio: false,
          scales: {
            x: { type: 'linear', title: { display: true, text: 'Months after Peak' }, min: 0, max: 12, ticks: { stepSize: 1, callback: v => v === 0 ? 'Peak' : `M+${v}` } },
            y: { title: { display: true, text: 'Drawdown from Peak (%)' }, min: -90, max: 5 }
          },
          plugins: { tooltip: { callbacks: { label: c => `${c.dataset.label}: ${c.parsed.y}%` } } }
        }
      });
    }

    window.switchCycleTab = function(tab) {
      document.querySelectorAll('.cycle-tab').forEach(t => t.classList.remove('active'));
      document.querySelector(`[onclick="switchCycleTab('${tab}')"]`)?.classList.add('active');
      document.getElementById('compare-panel').style.display = tab === 'compare' ? '' : 'none';
      document.getElementById('drawdown-panel').style.display = tab === 'drawdown' ? '' : 'none';
      if (tab === 'drawdown' && !Chart.getChart(document.getElementById('drawdown-chart'))) {
        createDrawdownComparisonChart();
      }
    };

    async function initCycleComparisons() {
      // Show loading state
      const posEl = document.getElementById('cycle-position');
      if (posEl) posEl.innerHTML = '<div style="color: var(--theme-text-muted); font-size: 0.85em;">Loading live BTC data...</div>';

      // Fetch live data, then render
      await loadDynamicCycleData();
      renderCyclePosition();
      createComparisonChart();
    }

    // Fonctions principales
    window.runFullAnalysis = async function () {
      document.getElementById('analysis-results').innerHTML = '';
      addResult('Starting full analysis...', '', 'info');

      // Charger les modules si pas encore fait
      if (!moduleLoaded) {
        const loaded = await loadModules();
        if (!loaded) return;
      }

      setTimeout(() => {
        try {
          const metrics = calculatePrecisionMetrics();
          // Persist overall precision for other modules (0..1)
          try {
            const prec = Math.max(0, Math.min(100, metrics.overallAccuracy || 0)) / 100;
            localStorage.setItem('cycle_model_precision', String(prec.toFixed(3)));
            addResult('üíæ Cycle Precision Saved', `${(prec * 100).toFixed(1)}%`, 'good');
          } catch (e) {
            debugLogger.warn('Failed to persist cycle_model_precision:', e);
          }
          createValidationChart();
          populateErrorTable();
          showIndicatorsSuggestions();

          addResult('‚úÖ Analysis Complete', 'All metrics computed', 'good');
          addResult('üéØ Overall Accuracy', `${metrics.overallAccuracy.toFixed(1)}%`,
            metrics.overallAccuracy > 75 ? 'good' : 'warning');
          addResult('üìä Cycles Validated', `${metrics.completedCycles.length} historical cycles analyzed`, 'good');

          if (metrics.overallAccuracy < 70) {
            addResult('‚ö†Ô∏è Recommendation', 'Low accuracy - Consider recalibration', 'warning');
          }
        } catch (error) {
          debugLogger.error('Error in runFullAnalysis:', error);
          addResult('‚ùå Error', `Analysis error: ${error.message}`, 'error');
        }
      }, 500);
    };

    window.calibrateModel = async function () {
      addResult('‚öôÔ∏è Calibration', 'Model recalibration in progress...', 'warning');

      if (!moduleLoaded) {
        const loaded = await loadModules();
        if (!loaded) return;
      }

      setTimeout(() => {
        try {
          const result = calibrateCycleParams();
          addResult('‚úÖ Calibration OK', `Error score: ${result.score.toFixed(2)}`, 'good');

          // Saver les nouveaux param√®tres
          saveCalibrationParams(result.params);
          addResult('üíæ Save', 'Calibrated parameters saved automatically', 'good');

          // Recalculer les m√©triques apr√®s calibration
          const metrics = calculatePrecisionMetrics();
          addResult('üìà New Accuracy', `${metrics.overallAccuracy.toFixed(1)}%`, 'good');
          // Mettre √† jour la pr√©cision persist√©e
          try {
            const prec = Math.max(0, Math.min(100, metrics.overallAccuracy || 0)) / 100;
            localStorage.setItem('cycle_model_precision', String(prec.toFixed(3)));
            addResult('üíæ Cycle Precision Updated', `${(prec * 100).toFixed(1)}%`, 'good');
          } catch (e) {
            debugLogger.warn('Failed to persist cycle_model_precision after calibration:', e);
          }

          // Recr√©er le graphique
          createValidationChart();
          populateErrorTable();

          // Notifier les autres pages (si ouvertes)
          window.postMessage({
            type: 'CYCLE_PARAMS_UPDATED',
            params: result.params,
            timestamp: Date.now()
          }, '*');

        } catch (error) {
          addResult('‚ùå Error', `Calibration error: ${error.message}`, 'error');
        }
      }, 1000);
    };

    window.testAlternatives = function () {
      addResult('üß™ Test Alternatives', 'Testing alternative functions...', 'warning');

      // Simuler le test d'alternatives (Gompertz, Logistique modifi√©e, etc.)
      setTimeout(() => {
        const alternatives = [
          { name: 'Gompertz', precision: 78.5, params: 'a=100, b=0.8, c=0.15' },
          { name: 'Logistique Double', precision: 82.1, params: 'k1=1.2, k2=0.9, x0=18' },
          { name: 'Weibull Modifi√©e', precision: 79.3, params: 'Œ±=2.1, Œ≤=24, Œ≥=0.1' },
          { name: 'Sigmo√Øde Actuel', precision: moduleLoaded ? calculatePrecisionMetrics().overallAccuracy : 75.0, params: 'Current parameters' }
        ];

        const best = alternatives.reduce((a, b) => a.precision > b.precision ? a : b);

        alternatives.forEach(alt => {
          addResult(`üìä ${alt.name}`, `Pr√©cision: ${alt.precision.toFixed(1)}% (${alt.params})`,
            alt === best ? 'good' : 'info');
        });

        addResult('üèÜ Best Model', `${best.name} avec ${best.precision.toFixed(1)}% accuracy`, 'good');
      }, 1500);
    };

    window.generateReport = function () {
      const metrics = moduleLoaded ? calculatePrecisionMetrics() : { overallAccuracy: 0, completedCycles: [], avgPeakError: 0, avgBottomError: 0 };
      const report = `
# üìä Bitcoin Cycle Model Analysis Report

## Executive Summary
- **Overall Accuracy**: ${metrics.overallAccuracy.toFixed(1)}%
- **Cycles Analyzed**: ${metrics.completedCycles.length}/3 complete cycles
- **Average Peak Error**: ${metrics.avgPeakError.toFixed(1)} points
- **Average Bottom Error**: ${metrics.avgBottomError.toFixed(1)} points

## Recommendations
${metrics.overallAccuracy > 80 ? '‚úÖ Model performing well - Maintain current parameters' : '‚ö†Ô∏è Insufficient accuracy - Recalibration recommended'}

## Suggested Complementary Indicators
1. MVRV Ratio (High priority)
2. NVT Ratio (High priority) 
3. RHODL Ratio (High priority)

Report generated on ${new Date().toLocaleString('en-US')}
      `;

      // Cr√©er et t√©l√©charger le rapport
      const blob = new Blob([report], { type: 'text/markdown' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `bitcoin-cycle-analysis-${Date.now()}.md`;
      a.click();
      URL.revokeObjectURL(url);

      addResult('üìã Report Generated', 'Report downloaded successfully', 'good');
    };

    // Initialisation
    document.addEventListener('DOMContentLoaded', async () => {
      // R√©cup√©rer le prix BTC actuel en arri√®re-plan
      fetchCurrentBTCPrice().then(price => {
        const cycle4 = HISTORICAL_CYCLES.find(c => c.id === 4);
        if (cycle4) {
          cycle4.currentPrice = price;
          console.debug('‚úÖ Cycle 4 mis √† jour avec prix actuel:', price);
        }
      }).catch(e => debugLogger.warn('Failed to fetch BTC price:', e));

      // Charger les modules d'abord
      await loadModules();

      // CRITICAL: Force cache invalidation after loading modules
      // This ensures fresh cycle calculations on every page load
      try {
        const { estimateCyclePosition } = await import('./modules/cycle-navigator.js');
        // Force recalculation by calling it once (will cache fresh data)
        const cyclePos = estimateCyclePosition();
        console.debug('üîÑ Cycle position recalculated on page load:', cyclePos);
      } catch (e) {
        console.warn('Failed to recalculate cycle position:', e);
      }

      // Initialiser le graphique Bitcoin historique
      initBitcoinCycleChart();

      // Initialiser les comparaisons de cycles (position, charts)
      initCycleComparisons();

      // Puis lancer l'analyse si les modules sont charg√©s
      if (moduleLoaded) {
        setTimeout(runFullAnalysis, 1000);
      }
    });
  </script>

  <script>
    // Initialisation automatique de la navigation simple et du th√®me
    document.addEventListener('DOMContentLoaded', function () {
      // Initialiser le th√®me
      if (window.globalConfig && window.globalConfig.applyTheme) {
        window.globalConfig.applyTheme();
      }
      if (window.applyAppearance) {
        window.applyAppearance();
      }

      // Initialiser la navigation simple
      /* unified nav enabled via components/nav.js; legacy init removed */
    });
  </script>
</body>

</html>