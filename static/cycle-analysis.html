<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>Bitcoin Cycle Analysis - Mod√®le de Pr√©cision</title>

  <!-- Th√®me & apparence unifi√©s -->
  <link rel="stylesheet" href="css/tokens.css">
  <link rel="stylesheet" href="shared-theme.css">
  <link rel="stylesheet" href="theme-compat.css">
  <script src="global-config.js"></script>

  <!-- Navigation unifi√©e (conditionnelle) -->
  <script type="module">
    // ===== AUTH GUARD (Dec 2025) =====
    import { checkAuth } from './core/auth-guard.js';
    await checkAuth();  // V√©rifie authentification + redirect si n√©cessaire
    // =================================

    if (new URLSearchParams(window.location.search).get('nav') !== 'off') {
      import('./components/nav.js');
    }
  </script>

  <style>
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      margin: 0;
      background: var(--theme-background);
      color: var(--theme-text);
    }

    .wrap {
      max-width: 95vw;
      margin: 0 auto;
      padding: var(--space-lg);
    }

    .card {
      background: var(--theme-surface);
      border: 1px solid var(--theme-border);
      border-radius: var(--radius-lg);
      padding: 2rem;
      margin: 1rem 0;
      box-shadow: var(--shadow-md);
      color: var(--theme-text);
    }

    /* Modern Controls Section (Compact & Sticky) */
    .controls-card {
      position: sticky;
      top: calc(var(--header-height) + 50px);
      /* Offset: Header + WealthBar */
      z-index: 90;
      background: var(--theme-surface);
      border: 1px solid var(--theme-border);
      padding: 0.5rem 1rem;
      text-align: center;
      box-shadow: var(--shadow-lg);
      opacity: 0.98;
      backdrop-filter: blur(8px);
      margin-bottom: 1.5rem;
      /* Ensure space below when static */
    }

    .controls-header h2 {
      margin: 0;
      font-size: 1.1rem;
      line-height: 1.3;
    }

    .controls-header p {
      color: var(--theme-text-muted);
      margin: 0;
      font-size: 0.8em;
      display: none;
      /* Hidden on small mobile */
    }

    .controls-actions {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 0.5rem;
      margin-top: 0.25rem;
    }

    /* Desktop: Horizontal Layout */
    @media (min-width: 768px) {
      .controls-card {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0.4rem 1.5rem;
        text-align: left;
      }

      .controls-actions {
        margin-top: 0;
        justify-content: flex-end;
      }

      .controls-header p {
        display: block;
      }
    }

    .control-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      padding: 0.5rem 1rem;
      font-size: 0.9rem;
      font-weight: 600;
      border-radius: var(--radius-md);
      border: 1px solid transparent;
      transition: all 0.2s ease;
      min-width: auto;
      box-shadow: var(--shadow-sm);
      margin: 0 !important;
      white-space: nowrap;
    }

    .control-btn:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
    }

    .control-btn .icon {
      font-size: 1.1em;
    }

    .metric {
      display: flex;
      justify-content: space-between;
      margin: 1rem 0;
      padding: 0.5rem;
      border-radius: 8px;
    }

    .metric.good {
      background: var(--success-bg);
      color: var(--success);
    }

    .metric.warning {
      background: var(--warning-bg);
      color: var(--warning);
    }

    .metric.error {
      background: #f8d7da;
      color: #721c24;
    }

    .chart-container {
      height: 400px;
      margin: 2rem 0;
      position: relative;
    }

    button {
      padding: 0.8rem 1.5rem;
      margin: 0.5rem;
      border: 1px solid var(--theme-border);
      border-radius: var(--radius-md);
      cursor: pointer;
      font-weight: 600;
      background: var(--theme-surface);
      color: var(--theme-text);
      transition: all 0.2s ease;
    }

    button:hover {
      background: var(--theme-surface-hover);
      transform: translateY(-1px);
    }

    .btn-primary {
      background: var(--brand-primary);
      color: var(--on-primary);
      border-color: var(--brand-primary);
    }

    .btn-success {
      background: var(--success);
      color: white;
      border-color: var(--success);
    }

    .btn-warning {
      background: var(--warning);
      color: var(--on-warning);
      border-color: var(--warning);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin: 1rem 0;
    }

    th,
    td {
      padding: 0.8rem;
      text-align: left;
      border-bottom: 1px solid var(--theme-border);
      color: var(--theme-text);
    }

    th {
      background: var(--theme-surface-elevated);
      font-weight: 600;
      color: var(--theme-text-muted);
    }

    .score-cell {
      font-weight: bold;
      padding: 0.5rem;
      border-radius: 4px;
      text-align: center;
    }

    /* Responsive Grid for Metrics & Indicators */
    .metrics-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 1rem;
    }

    .metrics-grid .metric {
      margin: 0;
      /* Let grid gap handle spacing */
      height: 100%;
      /* Uniform height */
      box-sizing: border-box;
    }

    @media (min-width: 992px) {
      .metrics-grid {
        grid-template-columns: 1fr 1fr;
      }
    }
  </style>
  <!-- Navigation unifi√©e (conditionnelle) -->
  <!-- Note: navigation is conditionally loaded above; avoid duplicate wrong path -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/luxon@3.4.4/build/global/luxon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.3.1/dist/chartjs-adapter-luxon.umd.min.js"></script>

  <script type="module" src="components/tooltips.js"></script>
</head>

<body>

  <div class="wrap">
    <h1>Bitcoin Cycle Analysis - Validation du Mod√®le</h1>

    <!-- Contr√¥les -->
    <div class="card controls-card">
      <div class="controls-header">
        <h2>üîß Contr√¥les d'Analyse</h2>
        <p>G√©rez l'ex√©cution et la calibration du mod√®le de cycle</p>
      </div>
      <div class="controls-actions">
        <button class="btn-primary control-btn" onclick="runFullAnalysis()">
          <span class="icon">üöÄ</span>
          <span>Analyse Compl√®te</span>
        </button>
        <button class="btn-success control-btn" onclick="calibrateModel()">
          <span class="icon">‚öôÔ∏è</span>
          <span>Calibrer Mod√®le</span>
        </button>
        <button class="btn-warning control-btn" onclick="testAlternatives()">
          <span class="icon">üß™</span>
          <span>Tester Alternatives</span>
        </button>
        <button class="btn-primary control-btn" onclick="generateReport()">
          <span class="icon">üìä</span>
          <span>Rapport D√©taill√©</span>
        </button>
      </div>
    </div>

    <!-- M√©triques de Pr√©cision -->
    <div class="card">
      <h2>üìä M√©triques de Pr√©cision du Mod√®le</h2>
      <div id="precision-metrics" class="metrics-grid"></div>
    </div>

    <!-- Graphique Historique Bitcoin avec Halvings -->
    <div class="card">
      <h2>üìà Bitcoin Historical Price & Cycle Score</h2>
      <p style="color: var(--theme-text-muted); font-size: 0.9em; margin-bottom: 1rem;">
        Prix historique de Bitcoin (√©chelle log) avec le score de cycle calcul√©.
        Les lignes verticales indiquent les halvings.
      </p>
      <div class="chart-container" style="height: 500px;">
        <canvas id="bitcoin-cycle-chart"></canvas>
      </div>
      <div id="bitcoin-chart-status"
        style="text-align: center; margin-top: 0.5rem; color: var(--theme-text-muted); font-size: 0.85em;">
        Chargement du graphique...
      </div>
    </div>

    <!-- Graphique de Validation -->
    <div class="card">
      <h2>üìä Validation Visuelle - Pr√©dictions vs R√©alit√©</h2>
      <div class="chart-container">
        <canvas id="validation-chart"></canvas>
      </div>
    </div>

    <!-- Analyse des Erreurs -->
    <div class="card">
      <h2>üîç Analyse des Erreurs par Cycle</h2>
      <table id="error-analysis-table">
        <thead>
          <tr>
            <th scope="col">Cycle</th>
            <th scope="col">Halving</th>
            <th scope="col">Peak R√©el</th>
            <th scope="col">Peak Pr√©dit</th>
            <th scope="col">Erreur</th>
            <th scope="col">Score R√©el</th>
            <th scope="col">Score Mod√®le</th>
            <th scope="col">Pr√©cision</th>
          </tr>
        </thead>
        <tbody id="error-table-body"></tbody>
      </table>
    </div>

    <!-- Indicateurs Compl√©mentaires -->
    <div class="card">
      <h2>üåü Indicateurs On-Chain Recommand√©s</h2>
      <div id="indicators-suggestions" class="metrics-grid"></div>
    </div>

    <!-- R√©sultats -->
    <div class="card">
      <h2>üìã R√©sultats d'Analyse</h2>
      <div id="analysis-results"></div>
    </div>
  </div>

  <script src="debug-logger.js"></script>
  <script type="module">
    // Variables globales pour les modules
    let cycleScoreFromMonths, getCycleParams, calibrateCycleParams, getCurrentCycleMonths;
    let moduleLoaded = false;

    // Import Bitcoin cycle chart functions
    import { createBitcoinCycleChart, fetchBitcoinHistoricalData } from './modules/risk-cycles-tab.js';

    // Bitcoin halvings data (needed for chart)
    window.BITCOIN_HALVINGS = [
      { date: '2012-11-28', block: 210000, reward: 25, estimated: false },
      { date: '2016-07-09', block: 420000, reward: 12.5, estimated: false },
      { date: '2020-05-11', block: 630000, reward: 6.25, estimated: false },
      { date: '2024-04-20', block: 840000, reward: 3.125, estimated: false },
      { date: '2028-04-01', block: 1050000, reward: 1.5625, estimated: true }
    ];

    // Initialize Bitcoin cycle chart
    async function initBitcoinCycleChart() {
      const statusEl = document.getElementById('bitcoin-chart-status');
      try {
        // Import store if available
        try {
          const { store } = await import('./core/risk-dashboard-store.js');
          window.store = store;
        } catch (e) {
          // Fallback: create minimal store
          window.store = {
            snapshot: () => ({ cycle: { months: 0, ccs_star: 50 } })
          };
        }

        // Provide cache helpers
        window.getCachedData = (key) => {
          try {
            const cached = localStorage.getItem(`cache_${key}`);
            return cached ? JSON.parse(cached) : null;
          } catch { return null; }
        };
        window.setCachedData = (key, data) => {
          try {
            localStorage.setItem(`cache_${key}`, JSON.stringify(data));
          } catch { }
        };

        await createBitcoinCycleChart('bitcoin-cycle-chart', true);
        if (statusEl) {
          statusEl.textContent = '‚úÖ Graphique charg√© avec succ√®s';
          statusEl.style.color = 'var(--success)';
        }
      } catch (error) {
        console.error('Failed to create Bitcoin cycle chart:', error);
        if (statusEl) {
          statusEl.textContent = `‚ùå Erreur: ${error.message}`;
          statusEl.style.color = 'var(--danger)';
        }
      }
    }

    // Donn√©es historiques des cycles Bitcoin
    const HISTORICAL_CYCLES = [
      {
        id: 1,
        halving: '2012-11-28',
        peak: '2013-11-30',
        peakPrice: 1177,
        bottom: '2015-01-14',
        bottomPrice: 152,
        cycleHigh: 1177,
        cycleLow: 65
      },
      {
        id: 2,
        halving: '2016-07-09',
        peak: '2017-12-17',
        peakPrice: 19783,
        bottom: '2018-12-15',
        bottomPrice: 3122,
        cycleHigh: 19783,
        cycleLow: 365
      },
      {
        id: 3,
        halving: '2020-05-11',
        peak: '2021-11-10',
        peakPrice: 68789,
        bottom: '2022-11-21',
        bottomPrice: 15460,
        cycleHigh: 68789,
        cycleLow: 3850
      },
      {
        id: 4,
        halving: '2024-04-20',
        peak: null, // En cours
        peakPrice: null,
        bottom: null,
        bottomPrice: null,
        // Prix actuel r√©cup√©r√© dynamiquement (voir fetchCurrentBTCPrice())
        currentPrice: null,
        cycleHigh: null,
        cycleLow: null
      }
    ];

    // --- Fallback local si le module ne se charge pas ---
    // Double-sigmo√Øde (coh√©rente avec cycle-navigator.js) - cloche 0‚Üí100
    function _fallbackCycleScoreFromMonths(m) {
      // Param√®tres CALIBR√âS IDENTIQUES au module principal (synchronis√©s)
      // Ces valeurs sont le r√©sultat de la calibration sur les 3 cycles complets
      const m48 = m % 48;
      const m_rise_center = 5.0;  // Calibr√© (depuis 7.0)
      const m_fall_center = 24.0; // Calibr√© (depuis 30.0)
      const k_rise = 0.8;         // Calibr√© (depuis 1.0)
      const k_fall = 1.2;         // Calibr√© (depuis 0.9)
      const p_shape = 1.15;       // Calibr√© (depuis 0.9)

      const rise = 1 / (1 + Math.exp(-k_rise * (m48 - m_rise_center)));
      const fall = 1 / (1 + Math.exp(-k_fall * (m_fall_center - m48)));
      const base = rise * fall;
      const score = Math.pow(base, p_shape) * 100;

      return Math.max(0, Math.min(100, score));
    }
    function _fallbackGetCycleParams() {
      // Param√®tres CALIBR√âS (synchronis√©s avec cycle-navigator.js)
      return { m_rise_center: 5.0, m_fall_center: 24.0, k_rise: 0.8, k_fall: 1.2, p_shape: 1.15 };
    }
    function _fallbackCalibrate() { return { score: 0, params: _fallbackGetCycleParams() }; }
    function _fallbackGetCurrentCycleMonths() {
      const lastHalving = new Date('2024-04-20');
      const now = new Date();
      const months = (now - lastHalving) / (1000 * 60 * 60 * 24 * 30.44);
      return Math.max(0, months);
    }


    // Persistance des param√®tres calibr√©s
    // IMPORTANT: Version must match CALIBRATION_VERSION in cycle-navigator.js
    const CALIBRATION_VERSION = '2.0';

    function saveCalibrationParams(params) {
      try {
        localStorage.setItem('bitcoin_cycle_params', JSON.stringify({
          params: params,
          timestamp: Date.now(),
          version: CALIBRATION_VERSION
        }));
        console.debug('‚úÖ Param√®tres calibr√©s sauvegard√©s', params);
      } catch (error) {
        debugLogger.error('‚ùå Erreur sauvegarde param√®tres:', error);
      }
    }

    function loadCalibrationParams() {
      try {
        const saved = localStorage.getItem('bitcoin_cycle_params');
        if (saved) {
          const data = JSON.parse(saved);
          // V√©rifier que les donn√©es ne sont pas trop anciennes (24h)
          if (Date.now() - data.timestamp < 24 * 60 * 60 * 1000) {
            console.debug('‚úÖ Param√®tres calibr√©s charg√©s depuis localStorage', data.params);
            return data.params;
          }
        }
      } catch (error) {
        debugLogger.error('‚ùå Erreur chargement param√®tres:', error);
      }
      return null;
    }

    // Chargement des modules
    async function loadModules() {
      try {
        console.debug('üîÑ Tentative de chargement du module cycle-navigator...');
        const module = await import('./modules/cycle-navigator.js');

        // V√©rifier que les fonctions sont disponibles
        if (!module.cycleScoreFromMonths) {
          throw new Error('cycleScoreFromMonths function not available in module');
        }

        cycleScoreFromMonths = module.cycleScoreFromMonths;
        getCycleParams = module.getCycleParams;
        calibrateCycleParams = module.calibrateCycleParams;
        getCurrentCycleMonths = module.getCurrentCycleMonths;

        // Test de la fonction
        const testScore = cycleScoreFromMonths(18);
        console.debug('üß™ Test cycleScoreFromMonths(18):', testScore);

        if (isNaN(testScore) || testScore < 0 || testScore > 100) {
          throw new Error('Function test failed - invalid score: ' + testScore);
        }

        // Charger les param√®tres sauvegard√©s si disponibles
        const savedParams = loadCalibrationParams();
        if (savedParams) {
          module.setCycleParams(savedParams);
          addResult('üîÑ Auto-Chargement', 'Param√®tres calibr√©s pr√©c√©dents appliqu√©s', 'good');
        }

        moduleLoaded = true;
        console.debug('‚úÖ Cycle navigator module loaded successfully');
        return true;
      } catch (error) {
        debugLogger.error('‚ùå Failed to load cycle navigator:', error);
        // üîÅ Fallback local pour que le graphe fonctionne quand m√™me
        cycleScoreFromMonths = _fallbackCycleScoreFromMonths;
        getCycleParams = _fallbackGetCycleParams;
        calibrateCycleParams = _fallbackCalibrate;
        getCurrentCycleMonths = _fallbackGetCurrentCycleMonths;
        moduleLoaded = true; // on passe √† true pour ne pas bloquer la suite
        addResult('‚ö†Ô∏è Mode d√©grad√©', 'Module non charg√© ‚Äî utilisation d\'un mod√®le local par d√©faut', 'warning');
        console.debug('üîÑ Utilisation du fallback, test:', _fallbackCycleScoreFromMonths(18));
        return true;
      }
    }


    // R√©cup√©ration du prix BTC actuel depuis l'API
    async function fetchCurrentBTCPrice() {
      try {
        // Essayer CoinGecko d'abord (pas de rate limit strict)
        const response = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd');
        if (response.ok) {
          const data = await response.json();
          const price = data?.bitcoin?.usd;
          if (typeof price === 'number' && price > 0) {
            console.debug('‚úÖ Prix BTC r√©cup√©r√©:', price);
            return price;
          }
        }
      } catch (e) {
        debugLogger.warn('CoinGecko fetch failed, trying fallback:', e.message);
      }

      // Fallback: essayer via le store (qui peut avoir des donn√©es r√©centes)
      try {
        const state = window.store?.snapshot();
        const btcPrice = state?.prices?.BTC;
        if (typeof btcPrice === 'number' && btcPrice > 0) {
          console.debug('‚úÖ Prix BTC depuis store:', btcPrice);
          return btcPrice;
        }
      } catch (e) {
        debugLogger.warn('Store price fetch failed:', e.message);
      }

      // Dernier fallback: estimation raisonnable bas√©e sur la date
      const defaultPrice = 100000; // Estimation conservatrice jan 2026
      console.debug('‚ö†Ô∏è Prix BTC par d√©faut utilis√©:', defaultPrice);
      return defaultPrice;
    }

    function parseISODateStrict(value) {
      if (value instanceof Date) return value;
      if (typeof value === 'string') {
        // Parse YYYY-MM-DD de fa√ßon robuste (UTC) pour √©viter les √©carts de locale
        const m = value.trim().match(/^(\d{4})-(\d{2})-(\d{2})$/);
        if (m) {
          const y = Number(m[1]);
          const mo = Number(m[2]);
          const d = Number(m[3]);
          return new Date(Date.UTC(y, mo - 1, d));
        }
      }
      // Fallback parsing
      const dt = new Date(value);
      return isNaN(dt.getTime()) ? null : dt;
    }

    function monthsBetween(dateA, dateB) {
      const a = parseISODateStrict(dateA);
      const b = parseISODateStrict(dateB);
      if (!a || !b) {
        debugLogger.warn('monthsBetween: invalid date(s)', { dateA, dateB });
        return NaN;
      }

      // Calcul pr√©cis des mois entre deux dates
      const years = b.getUTCFullYear() - a.getUTCFullYear();
      const months = b.getUTCMonth() - a.getUTCMonth();
      const days = b.getUTCDate() - a.getUTCDate();

      let totalMonths = years * 12 + months;

      // Ajuster pour les jours
      if (days > 0) {
        totalMonths += days / 30.44; // Moyenne des jours par mois
      } else if (days < 0) {
        totalMonths -= Math.abs(days) / 30.44;
      }

      return totalMonths;
    }

    function addResult(title, content, type = 'info') {
      const results = document.getElementById('analysis-results');
      const div = document.createElement('div');
      div.className = `metric ${type}`;
      div.innerHTML = `<strong>${title}:</strong> ${content}`;
      results.appendChild(div);
    }

    // Calcul des m√©triques de pr√©cision
    function calculatePrecisionMetrics() {
      if (!moduleLoaded || !cycleScoreFromMonths) {
        debugLogger.error('cycleScoreFromMonths function not available');
        return { avgPeakError: 0, avgBottomError: 0, overallAccuracy: 0, completedCycles: [] };
      }

      const completedCycles = HISTORICAL_CYCLES.filter(c => c.peak && c.bottom);
      let totalError = 0;
      let peakErrors = [];
      let bottomErrors = [];

      const metrics = document.getElementById('precision-metrics');
      if (!metrics) {
        debugLogger.error('precision-metrics element not found');
        return { avgPeakError: 0, avgBottomError: 0, overallAccuracy: 0, completedCycles: [] };
      }

      metrics.innerHTML = '';

      completedCycles.forEach(cycle => {
        const monthsToPeak = monthsBetween(cycle.halving, cycle.peak);
        const monthsToBottom = monthsBetween(cycle.halving, cycle.bottom);

        const predictedPeakScore = cycleScoreFromMonths(monthsToPeak);
        const predictedBottomScore = cycleScoreFromMonths(monthsToBottom);

        // On s'attend √† peak ‚âà 100, bottom ‚âà 10
        const peakError = Math.abs(100 - predictedPeakScore);
        const bottomError = Math.abs(10 - predictedBottomScore);

        peakErrors.push(peakError);
        bottomErrors.push(bottomError);
        totalError += peakError + bottomError;
      });

      // M√©triques globales
      const avgPeakError = peakErrors.reduce((a, b) => a + b, 0) / peakErrors.length;
      const avgBottomError = bottomErrors.reduce((a, b) => a + b, 0) / bottomErrors.length;
      const overallAccuracy = Math.max(0, 100 - (totalError / completedCycles.length / 2));

      // Calculer le score actuel (aujourd'hui)
      const currentCycleData = getCurrentCycleMonths();
      const currentMonths = typeof currentCycleData === 'object' ? currentCycleData.months : currentCycleData;
      const currentScore = cycleScoreFromMonths(currentMonths);
      const today = new Date().toLocaleDateString('fr-FR');

      // Affichage des m√©triques
      metrics.innerHTML = `
        <div class="metric good" style="background: linear-gradient(135deg, var(--success-bg) 0%, var(--info-bg) 100%); border: 2px solid var(--success);">
          <span style="font-weight: 700;">Score Actuel (${today}):</span>
          <span style="font-size: 1.3em; font-weight: 800;">${currentScore.toFixed(1)}/100</span>
        </div>
        <div class="metric good" style="border-left: 4px solid var(--info);">
          <span>Mois depuis Halving:</span>
          <span>${currentMonths.toFixed(1)} mois (depuis 20 avril 2024)</span>
        </div>
        <div class="metric ${avgPeakError < 15 ? 'good' : avgPeakError < 30 ? 'warning' : 'error'}">
          <span>Erreur Moyenne Pics:</span>
          <span>${avgPeakError.toFixed(1)} points</span>
        </div>
        <div class="metric ${avgBottomError < 20 ? 'good' : avgBottomError < 35 ? 'warning' : 'error'}">
          <span>Erreur Moyenne Creux:</span>
          <span>${avgBottomError.toFixed(1)} points</span>
        </div>
        <div class="metric ${overallAccuracy > 80 ? 'good' : overallAccuracy > 60 ? 'warning' : 'error'}">
          <span>Pr√©cision Globale:</span>
          <span>${overallAccuracy.toFixed(1)}%</span>
        </div>
        <div class="metric good">
          <span>Cycles Analys√©s:</span>
          <span>${completedCycles.length}/3 cycles complets</span>
        </div>
      `;

      return { avgPeakError, avgBottomError, overallAccuracy, completedCycles };
    }

    // Graphique de validation
    function createValidationChart() {
      if (!moduleLoaded || !cycleScoreFromMonths) {
        debugLogger.error('cycleScoreFromMonths function not available');
        return;
      }

      const canvas = document.getElementById('validation-chart');
      const ctx = canvas.getContext('2d');

      // V√©rifier que Chart.js est charg√©
      if (typeof Chart === 'undefined') {
        debugLogger.error('Chart.js not loaded');
        return;
      }

      // G√©n√©rer les donn√©es du mod√®le
      const modelData = [];
      for (let months = 0; months <= 48; months++) {
        modelData.push({
          x: months,
          y: cycleScoreFromMonths(months)
        });
      }

      // Points historiques r√©els
      const historicalPoints = [];
      HISTORICAL_CYCLES.forEach(cycle => {
        if (cycle.peak) {
          const monthsToPeak = monthsBetween(cycle.halving, cycle.peak);
          if (Number.isFinite(monthsToPeak)) historicalPoints.push({
            x: Number(monthsToPeak),
            y: 100, // On consid√®re le pic comme score 100
            label: `Cycle ${cycle.id} Peak`,
            color: '#dc2626'
          });
        }
        if (cycle.bottom) {
          const monthsToBottom = monthsBetween(cycle.halving, cycle.bottom);
          if (Number.isFinite(monthsToBottom)) historicalPoints.push({
            x: Number(monthsToBottom),
            y: 10, // On consid√®re le creux comme score 10
            label: `Cycle ${cycle.id} Bottom`,
            color: '#059669'
          });
        }
      });

      // Point courant (mois depuis le dernier halving)
      try {
        const currentCycle = HISTORICAL_CYCLES.find(c => c.id === 4);
        if (currentCycle && currentCycle.halving) {
          const now = new Date();
          const mNow = monthsBetween(currentCycle.halving, now);
          if (Number.isFinite(mNow)) {
            historicalPoints.push({
              x: Number(mNow),
              y: cycleScoreFromMonths(Number(mNow)),
              label: 'Cycle 4 Actuel',
              color: '#0ea5e9'
            });
          }
        }
      } catch (_) { /* ignore */ }

      // D√©truire chart existant si n√©cessaire
      const existingChart = Chart.getChart(ctx);
      if (existingChart) {
        existingChart.destroy();
      }

      const chart = new Chart(ctx, {
        type: 'line',
        data: {
          datasets: [
            {
              label: 'Mod√®le Sigmo√Øde',
              data: modelData,
              borderColor: '#3b82f6',
              backgroundColor: 'rgba(59, 130, 246, 0.1)',
              borderWidth: 3,
              fill: false,
              pointRadius: 0
            },
            {
              label: 'Points Historiques R√©els',
              data: historicalPoints,
              pointBackgroundColor: historicalPoints.map(p => p.color),
              pointBorderColor: historicalPoints.map(p => p.color),
              pointRadius: 8,
              pointHoverRadius: 10,
              showLine: false
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              type: 'linear',
              title: { display: true, text: 'Mois apr√®s Halving' },
              min: 0,
              max: 48,
              ticks: { stepSize: 6 }
            },
            y: {
              title: { display: true, text: 'Score de Cycle (0-100)' },
              min: 0,
              max: 100
            }
          },
          plugins: {
            tooltip: {
              callbacks: {
                label: function (context) {
                  const point = context.raw;
                  return point.label || `Score: ${context.parsed.y}`;
                }
              }
            }
          }
        }
      });
    }

    // Tableau d'analyse des erreurs
    function populateErrorTable() {
      if (!moduleLoaded || !cycleScoreFromMonths) {
        debugLogger.error('cycleScoreFromMonths function not available');
        return;
      }

      const tbody = document.getElementById('error-table-body');
      if (!tbody) {
        debugLogger.error('error-table-body element not found');
        return;
      }

      tbody.innerHTML = '';

      HISTORICAL_CYCLES.forEach(cycle => {
        if (!cycle.peak) return;

        const monthsToPeak = monthsBetween(cycle.halving, cycle.peak);
        const predictedScore = cycleScoreFromMonths(monthsToPeak);
        const error = Math.abs(100 - predictedScore);
        const accuracy = Math.max(0, 100 - error);

        const row = document.createElement('tr');
        row.innerHTML = `
          <td>Cycle ${cycle.id}</td>
          <td>${new Date(cycle.halving).toLocaleDateString('fr-FR')}</td>
          <td>${new Date(cycle.peak).toLocaleDateString('fr-FR')}</td>
          <td>${monthsToPeak.toFixed(1)} mois</td>
          <td class="score-cell ${error < 15 ? 'good' : error < 30 ? 'warning' : 'error'}">${error.toFixed(1)}</td>
          <td>100 (pic)</td>
          <td>${predictedScore.toFixed(1)}</td>
          <td class="score-cell ${accuracy > 80 ? 'good' : accuracy > 60 ? 'warning' : 'error'}">${accuracy.toFixed(1)}%</td>
        `;
        tbody.appendChild(row);
      });
    }

    // Suggestions d'indicateurs on-chain
    function showIndicatorsSuggestions() {
      const container = document.getElementById('indicators-suggestions');

      const indicators = [
        {
          name: "MVRV Ratio",
          description: "Market Value to Realized Value - D√©tecte la sur/sous-√©valuation",
          api: "Glassnode, CoinMetrics",
          priority: "üî• Haute",
          reason: "Corr√®le fortement avec les cycles de march√©"
        },
        {
          name: "NVT Ratio",
          description: "Network Value to Transactions - P/E ratio du Bitcoin",
          api: "Blockchain.info, Messari",
          priority: "üî• Haute",
          reason: "Indique l'utilisation r√©elle vs sp√©culation"
        },
        {
          name: "Puell Multiple",
          description: "Revenus miniers vs moyenne 365j - Timing historique pr√©cis",
          api: "Glassnode",
          priority: "üü° Moyenne",
          reason: "R√©v√®le les zones d'accumulation/distribution"
        },
        {
          name: "RHODL Ratio",
          description: "Realized HODL Ratio - Comportement des HODLers",
          api: "Glassnode",
          priority: "üî• Haute",
          reason: "Pr√©dit les mouvements de march√© via analyse de cohortes"
        },
        {
          name: "Stock-to-Flow Deviation",
          description: "√âcart entre prix r√©el et mod√®le S2F",
          api: "Custom calculation",
          priority: "üü° Moyenne",
          reason: "Compl√©ment au mod√®le de raret√©"
        },
        {
          name: "Fear & Greed Index",
          description: "Sentiment de march√© agr√©g√©",
          api: "Alternative.me",
          priority: "üü¢ Faible",
          reason: "Indicateur contrarian pour les extr√™mes"
        }
      ];

      container.innerHTML = indicators.map(ind => `
        <div class="metric good" style="display: block;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
            <strong>${ind.name}</strong>
            <span style="font-size: 0.9em;">${ind.priority}</span>
          </div>
          <div style="font-size: 0.9em; margin: 0.3rem 0;">
            üìä ${ind.description}
          </div>
          <div style="font-size: 0.8em; color: #666;">
            üîó API: ${ind.api} | üí° ${ind.reason}
          </div>
        </div>
      `).join('');
    }

    // Fonctions principales
    window.runFullAnalysis = async function () {
      document.getElementById('analysis-results').innerHTML = '<div class="metric good"><strong>üöÄ Lancement de l\'analyse compl√®te...</strong></div>';

      // Charger les modules si pas encore fait
      if (!moduleLoaded) {
        const loaded = await loadModules();
        if (!loaded) return;
      }

      setTimeout(() => {
        try {
          const metrics = calculatePrecisionMetrics();
          // Persist overall precision for other modules (0..1)
          try {
            const prec = Math.max(0, Math.min(100, metrics.overallAccuracy || 0)) / 100;
            localStorage.setItem('cycle_model_precision', String(prec.toFixed(3)));
            addResult('üíæ Pr√©cision Cycle Sauvegard√©e', `${(prec * 100).toFixed(1)}%`, 'good');
          } catch (e) {
            debugLogger.warn('Failed to persist cycle_model_precision:', e);
          }
          createValidationChart();
          populateErrorTable();
          showIndicatorsSuggestions();

          addResult('‚úÖ Analyse Termin√©e', 'Toutes les m√©triques calcul√©es', 'good');
          addResult('üéØ Pr√©cision Globale', `${metrics.overallAccuracy.toFixed(1)}%`,
            metrics.overallAccuracy > 75 ? 'good' : 'warning');
          addResult('üìä Cycles Valid√©s', `${metrics.completedCycles.length} cycles historiques analys√©s`, 'good');

          if (metrics.overallAccuracy < 70) {
            addResult('‚ö†Ô∏è Recommandation', 'Pr√©cision faible - Consid√©rer une recalibration', 'warning');
          }
        } catch (error) {
          debugLogger.error('Error in runFullAnalysis:', error);
          addResult('‚ùå Erreur', `Erreur d'analyse: ${error.message}`, 'error');
        }
      }, 500);
    };

    window.calibrateModel = async function () {
      addResult('‚öôÔ∏è Calibration', 'Recalibration du mod√®le en cours...', 'warning');

      if (!moduleLoaded) {
        const loaded = await loadModules();
        if (!loaded) return;
      }

      setTimeout(() => {
        try {
          const result = calibrateCycleParams();
          addResult('‚úÖ Calibration OK', `Score d'erreur: ${result.score.toFixed(2)}`, 'good');

          // Sauvegarder les nouveaux param√®tres
          saveCalibrationParams(result.params);
          addResult('üíæ Sauvegarde', 'Param√®tres calibr√©s sauvegard√©s automatiquement', 'good');

          // Recalculer les m√©triques apr√®s calibration
          const metrics = calculatePrecisionMetrics();
          addResult('üìà Nouvelle Pr√©cision', `${metrics.overallAccuracy.toFixed(1)}%`, 'good');
          // Mettre √† jour la pr√©cision persist√©e
          try {
            const prec = Math.max(0, Math.min(100, metrics.overallAccuracy || 0)) / 100;
            localStorage.setItem('cycle_model_precision', String(prec.toFixed(3)));
            addResult('üíæ Pr√©cision Cycle Mise √† Jour', `${(prec * 100).toFixed(1)}%`, 'good');
          } catch (e) {
            debugLogger.warn('Failed to persist cycle_model_precision after calibration:', e);
          }

          // Recr√©er le graphique
          createValidationChart();
          populateErrorTable();

          // Notifier les autres pages (si ouvertes)
          window.postMessage({
            type: 'CYCLE_PARAMS_UPDATED',
            params: result.params,
            timestamp: Date.now()
          }, '*');

        } catch (error) {
          addResult('‚ùå Erreur', `Erreur de calibration: ${error.message}`, 'error');
        }
      }, 1000);
    };

    window.testAlternatives = function () {
      addResult('üß™ Test Alternatives', 'Test de fonctions alternatives en cours...', 'warning');

      // Simuler le test d'alternatives (Gompertz, Logistique modifi√©e, etc.)
      setTimeout(() => {
        const alternatives = [
          { name: 'Gompertz', precision: 78.5, params: 'a=100, b=0.8, c=0.15' },
          { name: 'Logistique Double', precision: 82.1, params: 'k1=1.2, k2=0.9, x0=18' },
          { name: 'Weibull Modifi√©e', precision: 79.3, params: 'Œ±=2.1, Œ≤=24, Œ≥=0.1' },
          { name: 'Sigmo√Øde Actuel', precision: moduleLoaded ? calculatePrecisionMetrics().overallAccuracy : 75.0, params: 'Param√®tres actuels' }
        ];

        const best = alternatives.reduce((a, b) => a.precision > b.precision ? a : b);

        alternatives.forEach(alt => {
          addResult(`üìä ${alt.name}`, `Pr√©cision: ${alt.precision.toFixed(1)}% (${alt.params})`,
            alt === best ? 'good' : 'info');
        });

        addResult('üèÜ Meilleur Mod√®le', `${best.name} avec ${best.precision.toFixed(1)}% de pr√©cision`, 'good');
      }, 1500);
    };

    window.generateReport = function () {
      const metrics = moduleLoaded ? calculatePrecisionMetrics() : { overallAccuracy: 0, completedCycles: [], avgPeakError: 0, avgBottomError: 0 };
      const report = `
# üìä Rapport d'Analyse Bitcoin Cycle Model

## R√©sum√© Ex√©cutif
- **Pr√©cision Globale**: ${metrics.overallAccuracy.toFixed(1)}%
- **Cycles Analys√©s**: ${metrics.completedCycles.length}/3 cycles complets
- **Erreur Moyenne Pics**: ${metrics.avgPeakError.toFixed(1)} points
- **Erreur Moyenne Creux**: ${metrics.avgBottomError.toFixed(1)} points

## Recommandations
${metrics.overallAccuracy > 80 ? '‚úÖ Mod√®le performant - Maintenir param√®tres actuels' : '‚ö†Ô∏è Pr√©cision insuffisante - Recalibration recommand√©e'}

## Indicateurs Compl√©mentaires Sugg√©r√©s
1. MVRV Ratio (Haute priorit√©)
2. NVT Ratio (Haute priorit√©) 
3. RHODL Ratio (Haute priorit√©)

Rapport g√©n√©r√© le ${new Date().toLocaleString('fr-FR')}
      `;

      // Cr√©er et t√©l√©charger le rapport
      const blob = new Blob([report], { type: 'text/markdown' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `bitcoin-cycle-analysis-${Date.now()}.md`;
      a.click();
      URL.revokeObjectURL(url);

      addResult('üìã Rapport G√©n√©r√©', 'Rapport t√©l√©charg√© avec succ√®s', 'good');
    };

    // Initialisation
    document.addEventListener('DOMContentLoaded', async () => {
      // R√©cup√©rer le prix BTC actuel en arri√®re-plan
      fetchCurrentBTCPrice().then(price => {
        const cycle4 = HISTORICAL_CYCLES.find(c => c.id === 4);
        if (cycle4) {
          cycle4.currentPrice = price;
          console.debug('‚úÖ Cycle 4 mis √† jour avec prix actuel:', price);
        }
      }).catch(e => debugLogger.warn('Failed to fetch BTC price:', e));

      // Charger les modules d'abord
      await loadModules();

      // CRITICAL: Force cache invalidation after loading modules
      // This ensures fresh cycle calculations on every page load
      try {
        const { estimateCyclePosition } = await import('./modules/cycle-navigator.js');
        // Force recalculation by calling it once (will cache fresh data)
        const cyclePos = estimateCyclePosition();
        console.debug('üîÑ Cycle position recalculated on page load:', cyclePos);
      } catch (e) {
        console.warn('Failed to recalculate cycle position:', e);
      }

      // Initialiser le graphique Bitcoin historique
      initBitcoinCycleChart();

      // Puis lancer l'analyse si les modules sont charg√©s
      if (moduleLoaded) {
        setTimeout(runFullAnalysis, 1000);
      }
    });
  </script>

  <script>
    // Initialisation automatique de la navigation simple et du th√®me
    document.addEventListener('DOMContentLoaded', function () {
      // Initialiser le th√®me
      if (window.globalConfig && window.globalConfig.applyTheme) {
        window.globalConfig.applyTheme();
      }
      if (window.applyAppearance) {
        window.applyAppearance();
      }

      // Initialiser la navigation simple
      /* unified nav enabled via components/nav.js; legacy init removed */
    });
  </script>
</body>

</html>