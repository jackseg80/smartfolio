<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Simulator - SmartFolio</title>
  <link rel="stylesheet" href="css/tokens.css">
  <link rel="stylesheet" href="shared-theme.css">
  <link rel="stylesheet" href="theme-compat.css">
  <link rel="stylesheet" href="css/view-modes.css">
  <link rel="stylesheet" href="css/simulations.css">
  <!-- Decision Index Panel CSS (unifi√© avec analytics-unified.html) -->
  <link rel="stylesheet" href="components/decision-index-panel.css?v=20251015fixed">
  <link rel="stylesheet" href="analytics-unified-theme.css?v=20260129v1">
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>
  <script>
    // ‚úÖ Enregistrement datalabels (idempotent)
    if (window.Chart && window.ChartDataLabels && !window.__di_dl_registered__) {
      window.Chart.register(window.ChartDataLabels);
      // ‚úÖ Disable globally, then reactivate only on stacked bar
      window.Chart.defaults.set('plugins.datalabels', { display: false });
      window.__di_dl_registered__ = true;
      console.debug('‚úÖ chartjs-plugin-datalabels registered (global display: false)');
    }
  </script>
  <script src="debug-logger.js"></script>
    <script src="components/toast.js" type="module"></script>
  <script src="global-config.js"></script>
  <script src="appearance.js"></script>
  <script type="module" src="components/nav.js"></script>
  <script type="module" src="components/view-toggle.js"></script>
  <script type="module" src="components/domain-nav.js"></script>
  <script type="module">
    // ===== AUTH GUARD (Dec 2025) =====
    import { checkAuth } from './core/auth-guard.js';
    await checkAuth();  // V√©rifie authentification + redirect si n√©cessaire
    // =================================

    // ===== VIEW MODE MANAGER (Feb 2026) =====
    import { ViewModeManager } from './core/view-mode-manager.js';
    ViewModeManager.init();
    // ========================================

    import { initDeepLinks } from './components/deep-links.js';
    // Anchors for simulations.html: #controls #results #inspector
    initDeepLinks({
      'controls': 'Controls',
      'results': 'Results',
      'inspector': 'Inspector'
    });
  </script>
  <!-- Styles extracted to css/simulations.css (Feb 2026) -->
</head>

<body>
  <div class="wrap">
    <!-- En-t√™te principal -->
    <div class="sim-header">
      <div>
        <h1>üé≠ Simulateur de Rebalancing</h1>
        <p style="color: var(--theme-text-muted); margin: 0;">
          Testez le pipeline complet en temps r√©el sans √©criture backend
        </p>
      </div>

      <div class="source-controls">
        <view-toggle></view-toggle>
        <a href="analytics-unified.html" class="btn secondary" style="padding: 6px 12px; font-size: 0.85rem; text-decoration: none;">
          üìä Voir les Donn√©es Live
        </a>

        <div style="display: flex; align-items: center; gap: 8px;">
          <label for="sim-source-select" style="font-size: 0.9rem; color: var(--theme-text-muted);">Source:</label>
          <select id="sim-source-select" style="padding: 6px 10px; border-radius: 6px; border: 1px solid var(--theme-border); background: var(--theme-surface); color: var(--theme-text); font-size: 0.9rem;">
            <option value="">Charger...</option>
          </select>
          <button id="test-source-btn" class="btn secondary" style="padding: 6px 12px; font-size: 0.85rem;">üß™ Test</button>
        </div>

      </div>
    </div>

    <!-- Navigation contextuelle Analytics Domain (Feb 2026) -->
    <domain-nav domain="analytics"></domain-nav>

    <!-- Contr√¥les flottants -->
    <div id="controls" class="controls-flyout" role="complementary" aria-label="Contr√¥les de simulation" tabindex="-1">
      <div class="flyout-handle">üéõÔ∏è Contr√¥les</div>
      <div class="flyout-header">
        <h2>üéõÔ∏è Contr√¥les</h2>
        <div class="flyout-actions">
          <button id="controls-pin-btn" class="btn secondary pin-btn" type="button" aria-pressed="false" title="√âpingler le panneau">
            üìå √âpingler
          </button>
        </div>
      </div>
      <div class="flyout-content">
        <div id="sim-controls" class="controls-content">
          <!-- Contr√¥les g√©n√©r√©s par SimControls.js -->
        </div>
      </div>
    </div>

    <!-- Disposition principale -->
    <div class="sim-layout">
      <!-- R√©sultats -->
      <div id="results" class="sim-panel">
        <div class="sim-header">
          <h3>üìä R√©sultats de Simulation</h3>
          <div style="display: flex; align-items: center; gap: var(--space-md);">
            <div id="simulation-status">
              <span class="status-badge info">Pr√™t</span>
            </div>
            <div id="badges-sim"></div>
          </div>
        </div>
        <div class="results-content">
          <!-- √âtats -->
          <div id="loading-state" class="loading-spinner">
            <div class="spinner"></div>
            <p>Simulation en cours...</p>
          </div>

          <div id="error-state" class="error-state">
            <div style="font-size: 2rem;">‚ö†Ô∏è</div>
            <h4>Erreur de Simulation</h4>
            <p id="error-message">Une erreur s'est produite</p>
            <button id="retry-btn" class="btn secondary">üîÑ R√©essayer</button>
          </div>

          <div id="empty-state" class="empty-state">
            <div class="empty-icon">üé≠</div>
            <h4>Simulateur Pr√™t</h4>
            <p>Ajustez les contr√¥les pour lancer la simulation</p>
          </div>

          <!-- R√©sultats -->
          <div id="results-grid" class="results-grid" style="display: none;">
            <!-- Decision Index -->
            <div class="result-card">
              <h4>üéØ Decision Index</h4>
              <div id="di-panel-sim"></div>
              <div id="sim-selected-preset" class="di-preset" style="margin-top: var(--space-sm);">Preset: Custom</div>
            </div>

            <!-- Risk Budget -->
            <div class="result-card">
              <h4>üí∞ Risk Budget</h4>
              <div class="budget-bars">
                <div class="budget-bar">
                  <div id="sim-stables-bar" class="budget-bar-fill stables-bar">
                    <span id="sim-stables-pct">--%</span>
                  </div>
                  <div style="font-size: 0.9rem; color: var(--theme-text-muted);">Stables</div>
                </div>
                <div class="budget-bar">
                  <div id="sim-risky-bar" class="budget-bar-fill risky-bar">
                    <span id="sim-risky-pct">--%</span>
                  </div>
                  <div style="font-size: 0.9rem; color: var(--theme-text-muted);">Risky</div>
                </div>
              </div>
              <div style="text-align: center; font-size: 0.8rem; color: var(--theme-text-muted);">
                Courbe: <span id="sim-risk-curve">--</span> |
                Clamps: <span id="sim-risk-clamps">--</span>
              </div>
            </div>

            <!-- Allocation Targets -->
            <div class="result-card">
              <h4>üéØ Allocation par Groupes</h4>
              <div id="sim-allocation-chart" class="allocation-chart">
                Chargement de l'allocation...
              </div>
            </div>

            <!-- Plan d'Ex√©cution -->
            <div class="result-card">
              <h4>‚ö° Plan d'Ex√©cution</h4>
              <div style="margin-bottom: var(--space-md);">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: var(--space-sm);">
                  <span>Delta Total:</span>
                  <span id="sim-total-delta" style="font-family: monospace; font-weight: 600;">--%</span>
                </div>
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: var(--space-sm);">
                  <span>Seuil:</span>
                  <span id="sim-exec-threshold" style="font-family: monospace;">--%</span>
                </div>
                <div style="display: flex; justify-content: space-between; align-items: center;">
                  <span>Statut:</span>
                  <span id="sim-exec-status" class="status-badge">--</span>
                </div>
              </div>
              <div id="sim-orders-list" class="orders-list">
                <!-- Ordres g√©n√©r√©s dynamiquement -->
              </div>
            </div>

            <!-- R√©sum√© NL -->
            <div class="result-card">
              <h4>üìù R√©sum√©</h4>
              <div id="sim-summary-nl" style="line-height: 1.6; color: var(--theme-text);">
                R√©sum√© en langage naturel...
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Inspecteur -->
      <div id="inspector" class="sim-panel sim-panel-inspector">
        <div class="sim-header">
          <h3>üîç Inspecteur</h3>
        </div>
        <div id="sim-inspector" class="results-content">
          <!-- Inspecteur g√©n√©r√© par SimInspector.js -->
        </div>
      </div>
    </div>

  </div>

  <!-- Scripts -->
  <script type="module">
    import { SimControls } from './components/SimControls.js';
    import { SimInspector } from './components/SimInspector.js';
    import * as SimEngine from './modules/simulation-engine.js';

    // S√©lecteurs & policy
    import { selectContradictionPct, selectContradiction01, selectCapPercent } from './selectors/governance.js';
    import { classifyContradiction } from './governance/contradiction-policy.js';

    // Badges UI
    import { renderBadges } from './components/Badges.js';

    // Decision Index Panel
    import { renderDecisionIndexPanel } from './components/decision-index-panel.js';

    // CSV parsing functions (from dashboard.html)
    function parseCSVBalancesAuto(csvText, { thresholdUSD = 1.0 } = {}) {
      if (typeof window.parseCSVBalances === 'function') {
        return window.parseCSVBalances(csvText);
      }
      return parseCSVBalancesLocal(csvText, { thresholdUSD });
    }

    function parseCSVBalancesLocal(csvText, { thresholdUSD = 1.0 } = {}) {
      const cleanedText = csvText.replace(/^\ufeff/, '');
      const lines = cleanedText.split(/\r?\n/);
      const balances = [];
      const minThreshold = (window.globalConfig && window.globalConfig.get('min_usd_threshold')) || thresholdUSD || 1.0;

      for (let i = 1; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) continue;

        try {
          const columns = parseCSVLineLocal(line);
          if (columns.length >= 5) {
            const ticker = columns[0];
            const norm = s => parseFloat(String(s).replace(/[,\u00A0]/g, ''));
            const amount = norm(columns[3]);
            const valueUSD = norm(columns[4]);

            if (ticker && !isNaN(amount) && !isNaN(valueUSD) && valueUSD >= minThreshold) {
              balances.push({
                symbol: ticker.toUpperCase(),
                balance: amount,
                value_usd: valueUSD
              });
            }
          }
        } catch (error) {
          debugLogger.warn('Erreur parsing ligne CSV:', error.message);
        }
      }

      return balances;
    }

    function parseCSVLineLocal(line) {
      const cols = [];
      let current = '';
      let inQuotes = false;

      for (let i = 0; i < line.length; i++) {
        const char = line[i];
        if (char === '"') {
          inQuotes = !inQuotes;
        } else if (char === ',' && !inQuotes) {
          cols.push(current.trim());
          current = '';
        } else {
          current += char;
        }
      }
      cols.push(current.trim());
      return cols;
    }

    // Fallback functions for missing modules
    function smoothContradiction(value, prevValue, config, state) {
      return { value01: value, level: 'medium', persistCount: 0 };
    }

    function getEffectiveContradiction01(opts) {
      return {
        value01: opts.state?.governance?.contradiction_index ?? 0.5,
        stale: false,
        useBaseWeights: false
      };
    }

    function calculateAdaptiveWeights(base, state) {
      return base;
    }

    function applyContradictionCaps(policy, state) {
      return policy;
    }

    // √âtat local de smoothing (persistance) + config par d√©faut
    let smoothState = { prevLevel: undefined, prevValue: undefined, persistCount: 0 };
    const SMOOTHING_CFG = { ema_alpha: 0.25, deadband: 2, persistence: 3 }; // deadband en %
    const STALE_TTL_MIN = 30;

    // √âtat global de l'application
    let appState = {
      mode: 'simulation', // Mode simulation uniquement (Live supprim√© - utiliser analytics-unified.html)
      sourceId: null, // Sera initialis√© depuis globalConfig
      controls: null,
      inspector: null,
      lastSimulation: null,
      isRunning: false
    };

    // Fonction pour r√©cup√©rer la source active depuis globalConfig
    function getActiveSource() {
      return window.globalConfig?.get('data_source') || 'stub_balanced';
    }

    // Debounce pour √©viter d'inonder le moteur
    let controlsUpdateTimeout = null;

    // Charger les sources disponibles depuis l'API
    async function loadAvailableSources() {
      try {
        const apiBase = window.globalConfig?.get('api_base_url') || window.location.origin;
        const activeUser = localStorage.getItem('activeUser') || 'demo';
        const response = await fetch(`${apiBase}/api/users/sources`, {
          headers: { 'X-User': activeUser }
        });

        if (!response.ok) {
          debugLogger.warn('Failed to load sources');
          return;
        }

        const data = await response.json();
        const select = document.getElementById('sim-source-select');

        if (!select) return;

        // Peupler le select
        select.innerHTML = '';
        (data.sources || []).forEach(source => {
          const option = document.createElement('option');
          option.value = source.key;
          option.textContent = source.label;
          select.appendChild(option);
        });

        // S√©lectionner la source active
        const activeSource = getActiveSource();
        select.value = activeSource;

        debugLogger.debug('üé≠ SIM: Loaded sources:', data.sources?.length || 0, '| Active:', activeSource);
      } catch (error) {
        debugLogger.error('Failed to load sources:', error);
      }
    }

    // Tester la source s√©lectionn√©e
    async function testSelectedSource() {
      const select = document.getElementById('sim-source-select');
      const source = select?.value || getActiveSource();
      const userId = localStorage.getItem('activeUser') || 'demo';

      debugLogger.debug(`üß™ Testing source: ${source} for user: ${userId}`);

      try {
        // ‚úÖ USE UNIFIED loadBalanceData() which handles user_id correctly via X-User header
        // Temporarily set data_source to test the selected source
        const originalSource = window.globalConfig.get('data_source');
        window.globalConfig.set('data_source', source);

        const balanceResult = await window.loadBalanceData(true); // forceRefresh=true

        // Restore original source
        window.globalConfig.set('data_source', originalSource);

        if (!balanceResult || !balanceResult.success) {
          throw new Error('Failed to load balance data');
        }

        debugLogger.debug('üß™ Balance result:', balanceResult);

        // Parse balances (same logic as dashboard.html)
        let balances;
        if (balanceResult.csvText) {
          // CSV source
          const minThreshold = (window.globalConfig && window.globalConfig.get('min_usd_threshold')) || 1.0;
          balances = parseCSVBalancesAuto(balanceResult.csvText, { thresholdUSD: minThreshold });
        } else if (balanceResult.data && Array.isArray(balanceResult.data.items)) {
          // API source
          balances = balanceResult.data.items;
        } else {
          throw new Error('Invalid data format');
        }

        const sourceUsed = balanceResult.source || source;

        if (balances.length > 0) {
          const totalValue = balances.reduce((sum, item) => {
            return sum + (item.value_usd || item.valueUsd || item.total_usd || 0);
          }, 0);

          alert(`‚úÖ Source "${sourceUsed}" OK\n\n` +
                `${balances.length} assets trouv√©s\n` +
                `Valeur totale: $${totalValue.toFixed(2)}\n` +
                `User: ${userId}`);
        } else {
          alert(`‚ö†Ô∏è Source "${sourceUsed}" accessible mais vide\n\n` +
                `Aucun asset trouv√©.\n` +
                `V√©rifiez que la source contient des donn√©es pour l'utilisateur ${userId}.`);
        }
      } catch (error) {
        debugLogger.error('üß™ Test source failed:', error);
        alert(`‚ùå Erreur test source "${source}":\n${error.message}`);
      }
    }


    // Initialisation
    document.addEventListener('DOMContentLoaded', async () => {
      debugLogger.debug('üé≠ SIM: Simulator page initialized');

      try {
        await loadAvailableSources();
        await initializeSimulator();
        attachEventListeners();
        setInitialState();
      } catch (error) {
        debugLogger.error('üé≠ SIM: Initialization failed:', error);
        showError('√âchec de l\'initialisation du simulateur: ' + error.message);
      }
    });

    async function initializeSimulator() {
      // Initialiser les composants
      appState.controls = new SimControls('sim-controls', onControlsUpdate);
      appState.inspector = new SimInspector('sim-inspector');

      // Initialiser le moteur de simulation
      const initResult = await SimEngine.initSimulation({ sourceId: appState.sourceId });
      if (!initResult.success) {
        throw new Error(initResult.error);
      }

      debugLogger.debug('üé≠ SIM: Simulator components initialized');
    }

    function setControlsPinned(pinned) {
      const controlsPanel = document.getElementById('controls');
      const pinButton = document.getElementById('controls-pin-btn');

      if (!controlsPanel || !pinButton) {
        return;
      }

      controlsPanel.classList.toggle('is-pinned', pinned);
      pinButton.setAttribute('aria-pressed', String(pinned));
      pinButton.textContent = pinned ? 'üìå √âpingl√©' : 'üìå √âpingler';
    }

    function attachEventListeners() {
      const pinButton = document.getElementById('controls-pin-btn');
      setControlsPinned(false);

      // Source selector
      document.getElementById('sim-source-select')?.addEventListener('change', (e) => {
        const newSource = e.target.value;
        debugLogger.debug('üé≠ SIM: Source changed to:', newSource);
        // Mettre √† jour globalConfig pour coh√©rence
        if (window.globalConfig) {
          window.globalConfig.set('data_source', newSource);
        }
      });

      // Test source button
      document.getElementById('test-source-btn')?.addEventListener('click', testSelectedSource);

      pinButton?.addEventListener('click', () => {
        const controlsPanel = document.getElementById('controls');
        const isPinned = controlsPanel?.classList.contains('is-pinned');
        setControlsPinned(!isPinned);
      });

      // Retry button
      document.getElementById('retry-btn')?.addEventListener('click', () => {
        if (appState.lastSimulation) {
          runSimulation(appState.lastSimulation);
        }
      });

      // URL hash pour restaurer √©tat
      window.addEventListener('hashchange', () => {
        restoreStateFromHash();
        if (window.location.hash === '#controls') {
          setControlsPinned(true);
          document.getElementById('controls')?.focus({ preventScroll: true });
        }
      });
    }

    function setInitialState() {
      // V√©rifier URL hash
      const hashState = SimEngine.stateFromUrlHash();
      if (hashState) {
        appState.controls.setState(hashState);
      }

      // Initialiser le mode simulation
      initializeMode();

      // √âtat initial empty (si pas de hash state)
      if (!hashState) {
        showEmptyState();
      }

      if (window.location.hash === '#controls') {
        setControlsPinned(true);
        document.getElementById('controls')?.focus({ preventScroll: true });
      }
    }

    function initializeMode() {
      // Mode simulation uniquement (Live supprim√© - utiliser analytics-unified.html)
      appState.mode = 'simulation';

      // Mettre √† jour le statut
      const statusEl = document.getElementById('simulation-status');
      if (statusEl) {
        const badge = statusEl.querySelector('.status-badge');
        badge.textContent = 'Mode Simulation';
        badge.className = 'status-badge info';
      }

      debugLogger.debug('üé≠ SIM: Mode initialized: simulation');

      // Lancer simulation si des contr√¥les existent
      if (appState.controls) {
        const state = appState.controls.getState();
        onControlsUpdate(state);
      }
    }

    async function onControlsUpdate(controlsState) {
      if (appState.mode !== 'simulation' || appState.isRunning) {
        return;
      }

      // Debounce pour √©viter d'inonder le moteur quand l'utilisateur bouge un slider rapidement
      if (controlsUpdateTimeout) {
        clearTimeout(controlsUpdateTimeout);
      }

      controlsUpdateTimeout = setTimeout(async () => {
        debugLogger.debug('üé≠ SIM: Controls updated, running simulation');
        appState.lastSimulation = controlsState;

        // Mettre √† jour URL hash
        const hash = SimEngine.stateToUrlHash(controlsState);
        if (hash !== window.location.hash) {
          history.replaceState(null, null, hash);
        }

        await runSimulation(controlsState);
      }, 250); // 250ms debounce
    }

    async function runSimulation(controlsState) {
      if (appState.isRunning) return;

      appState.isRunning = true;
      showLoadingState();

      try {
        // Lancer la simulation compl√®te
        const result = await SimEngine.simulateFullPipeline(controlsState);
        debugLogger.debug('üé≠ SIM: Simulation completed:', result);

        // Afficher les r√©sultats
        displayResults(result);
        appState.inspector.updateInspector(result);

        showResultsState();

      } catch (error) {
        debugLogger.error('üé≠ SIM: Simulation failed:', error);
        showError('Erreur de simulation: ' + error.message);
      } finally {
        appState.isRunning = false;
      }
    }


    function displayResults(result) {
      const { di, riskBudget, cappedTargets, orders, explanation } = result;

      // Mode simulation uniquement
      const isLiveMode = false;

      // Affichage badges dans le header des r√©sultats
      const stateForEngine = result?.ui?.stateForEngine ?? null;
      const capPercent = stateForEngine ? selectCapPercent(stateForEngine) : null;
      try {
        const badgeProps = {};
        if (capPercent != null) {
          badgeProps.cap = capPercent;
        }
        renderBadges(document.querySelector('#badges-sim'), {
          state: stateForEngine || {},
          ...badgeProps
        });
      } catch (e) {
        debugLogger.warn('Badges render skipped:', e?.message);
      }

      // Decision Index - Nouveau panneau visuel
      const activeUser = localStorage.getItem('activeUser') || 'demo';
      const dataSource = window.globalConfig?.get('data_source') || 'unknown';
      const historyKey = `di_history_${activeUser}_${dataSource}_simulation`;

      // Buffer historique (m√©moire, max 100 points, cl√© scind√©e)
      if (!window.diHistoryBuffers) window.diHistoryBuffers = {};
      if (!window.diHistoryBuffers[historyKey]) window.diHistoryBuffers[historyKey] = [];

      // Ajouter DI actuel √† l'historique (clamped [0, 100])
      const diClamped = Math.max(0, Math.min(100, di.di));
      window.diHistoryBuffers[historyKey].push(diClamped);
      if (window.diHistoryBuffers[historyKey].length > 100) {
        window.diHistoryBuffers[historyKey].shift();
      }

      // Valider unit√© cap (0-1 ‚Üí √ó100, NaN ‚Üí null)
      let diCapPercent = result.ui?.capPercent;
      if (typeof diCapPercent === 'number' && diCapPercent <= 1) {
        diCapPercent = Math.round(diCapPercent * 100);
      }
      if (typeof diCapPercent !== 'number' || !Number.isFinite(diCapPercent)) {
        diCapPercent = null;
      }

      // Pr√©parer data pour panneau DI (align√© avec analytics-unified-main-controller.js)
      const cycleScore = result.context?.scores?.cycle || 0;
      const onchainScore = result.context?.scores?.onchain || 0;
      const riskScore = result.context?.scores?.risk || 0;
      const cyclePhase = result.context?.cycle?.phase || (cycleScore >= 70 ? 'bull' : (cycleScore <= 30 ? 'bear' : 'neutral'));

      const diPanelData = {
        di: diClamped,
        scores: { cycle: cycleScore, onchain: onchainScore, risk: riskScore },
        weights: di.weights || { cycle: 0.33, onchain: 0.39, risk: 0.28 },
        meta: {
          // Champs align√©s avec analytics-unified-main-controller.js
          phase: cyclePhase,
          source: di.source || 'simulation_engine',
          live: isLiveMode,
          backend: false,  // Simulation = pas de backend live
          signals: false,
          governance_mode: result.ui?.stateForEngine?.governance?.current_state || 'SIMULATION',
          cap: diCapPercent,
          mode: result.ui?.mode || 'Normal',
          confidence: di.confidence || 0,
          contradiction: result.ui?.stateForEngine?.governance?.contradiction_index || 0,
          cycle_confidence: 0.8,  // Valeur par d√©faut pour simulation
          updated: result.timestamp || new Date().toISOString(),
          signals_status: 'simulation',
          alpha: null,

          // Donn√©es pour tuiles
          blended_score: diClamped,
          regime_score: diClamped,
          cycle_phase: cyclePhase,
          cycle_months: result.context?.cycle?.months || null,
          onchain_critiques: 0,
          onchain_confidence: null,
          risk_var95: null,
          volatility_annualized: null,
          sharpe: null,
          risk_budget: riskBudget ? {
            risky: 100 - riskBudget.target_stables_pct,
            stables: riskBudget.target_stables_pct
          } : null,
          regime_emoji: cycleScore >= 70 ? 'üêÇ' : (cycleScore <= 30 ? 'üêª' : 'üòê'),
          sentiment_fg: result.context?.sentimentScore || null,
          sentiment_interpretation: null
        },
        history: [...window.diHistoryBuffers[historyKey]],
        regimeHistory: [],
        allocation: result.cappedTargets ? {
          BTC: result.cappedTargets.BTC || 0,
          ETH: result.cappedTargets.ETH || 0,
          Stablecoins: result.cappedTargets.Stablecoins || 0,
          Alts: Object.entries(result.cappedTargets)
            .filter(([k]) => !['BTC', 'ETH', 'Stablecoins'].includes(k))
            .reduce((sum, [, v]) => sum + v, 0)
        } : null
      };

      // Render panneau DI
      renderDecisionIndexPanel(document.getElementById('di-panel-sim'), diPanelData);

      // Preset info (conserv√© pour affichage sous le panneau)
      const presetName = result?.presetInfo?.name || result?.context?.presetInfo?.name || 'Custom';
      const presetDesc = result?.presetInfo?.desc || result?.context?.presetInfo?.desc || '';
      const presetEl = document.getElementById('sim-selected-preset');
      if (presetEl) {
        presetEl.textContent = `${isLiveMode ? 'üìä Live' : 'üé≠ Simulation'}: ${presetName}`;
        if (presetDesc) {
          presetEl.setAttribute('title', presetDesc);
        } else {
          presetEl.removeAttribute('title');
        }
      }

      // Risk Budget
      const stablesPct = Math.round(riskBudget.target_stables_pct);
      const riskyPct = 100 - stablesPct;

      document.getElementById('sim-stables-pct').textContent = `${stablesPct}%`;
      document.getElementById('sim-risky-pct').textContent = `${riskyPct}%`;
      document.getElementById('sim-risk-curve').textContent = riskBudget.curve;
      document.getElementById('sim-risk-clamps').textContent =
        `${riskBudget.clamps.min_stables}-${riskBudget.clamps.max_stables}%`;

      // Ajuster la largeur des barres
      document.getElementById('sim-stables-bar').style.width = `${stablesPct}%`;
      document.getElementById('sim-risky-bar').style.width = `${riskyPct}%`;

      // Allocation chart: afficher les targets de simulation
      displayAllocationChart(cappedTargets);

      // Execution plan
      document.getElementById('sim-total-delta').textContent = `${orders.summary.totalDelta}%`;
      document.getElementById('sim-exec-threshold').textContent = `${orders.summary.globalThreshold}%`;

      const statusEl = document.getElementById('sim-exec-status');
      if (orders.summary.shouldExecute) {
        statusEl.textContent = 'Ex√©cuter';
        statusEl.className = 'status-badge success';
      } else {
        statusEl.textContent = 'Attendre';
        statusEl.className = 'status-badge warning';
      }

      // Orders list
      displayOrdersList(orders.orders);

      // R√©sum√© NL
      document.getElementById('sim-summary-nl').textContent = explanation.summaryNL;
    }

    function displayAllocationChart(targets) {
      const chartEl = document.getElementById('sim-allocation-chart');
      if (!chartEl || !targets) return;

      // Cr√©er un chart simple avec des barres
      const sortedTargets = Object.entries(targets)
        .sort(([,a], [,b]) => b - a)
        .filter(([, value]) => value >= 0.1); // Filtrer les tr√®s petites valeurs

      const chartTitle = 'üéØ Allocations Cibles (Simulation)';

      let html = `<div style="margin-bottom: 0.75rem; font-weight: 600; font-size: 0.95rem; color: var(--theme-text);">${chartTitle}</div>`;
      html += '<div style="display: flex; flex-direction: column; gap: 0.5rem;">';

      for (const [group, pct] of sortedTargets) {
        const width = Math.max(2, (pct / Math.max(...Object.values(targets))) * 100);
        const color = getGroupColor(group);

        html += `
          <div style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.85rem;">
            <div style="width: 100px; text-align: right; color: var(--theme-text-muted); overflow: hidden; text-overflow: ellipsis;" title="${group}">${group}:</div>
            <div style="flex: 1; background: var(--theme-border); height: 20px; border-radius: 10px; overflow: hidden;">
              <div style="width: ${width}%; height: 100%; background: ${color}; transition: width 0.3s ease;"></div>
            </div>
            <div style="width: 50px; text-align: right; font-family: monospace; font-weight: 600;">${pct.toFixed(1)}%</div>
          </div>
        `;
      }

      html += '</div>';
      chartEl.innerHTML = html;
    }

    function getGroupColor(group) {
      const colors = {
        'Stablecoins': '#10b981',
        'BTC': '#f59e0b',
        'ETH': '#3b82f6',
        'SOL': '#8b5cf6',
        'L1/L0 majors': '#06b6d4',
        'L2/Scaling': '#84cc16',
        'DeFi': '#ec4899',
        'AI/Data': '#f97316',
        'Gaming/NFT': '#ef4444',
        'Memecoins': '#6366f1',
        'Others': '#6b7280'
      };
      return colors[group] || '#9ca3af';
    }

    function displayOrdersList(orders) {
      const listEl = document.getElementById('sim-orders-list');
      if (!listEl) return;

      if (!orders || orders.length === 0) {
        listEl.innerHTML = '<div style="text-align: center; color: var(--theme-text-muted); padding: var(--space-md);">Aucun ordre g√©n√©r√©</div>';
        return;
      }

      let html = '';
      orders.forEach(order => {
        const actionClass = order.action.toLowerCase();
        const priorityIcon = order.priority === 'HIGH' ? 'üî•' : 'üìã';

        html += `
          <div class="order-item">
            <div>
              <span class="order-action ${actionClass}">${order.action}</span>
              <span style="margin-left: 0.5rem;">${order.group}</span>
            </div>
            <div style="text-align: right;">
              <div style="font-family: monospace; font-weight: 600;">${order.deltaPct > 0 ? '+' : ''}${order.deltaPct}%</div>
              <div style="font-size: 0.8rem; color: var(--theme-text-muted);">${priorityIcon} ${order.estimatedLot}‚Ç¨</div>
            </div>
          </div>
        `;
      });

      listEl.innerHTML = html;
    }

    async function reinitializeWithNewSource() {
      debugLogger.debug('üé≠ SIM: Reinitializing with new source:', appState.sourceId);

      showLoadingState();

      try {
        const initResult = await SimEngine.initSimulation({ sourceId: appState.sourceId });
        if (!initResult.success) {
          throw new Error(initResult.error);
        }

        // Relancer simulation si en mode simulation
        if (appState.mode === 'simulation' && appState.controls) {
          const state = appState.controls.getState();
          await runSimulation(state);
        } else {
          showEmptyState();
        }

      } catch (error) {
        debugLogger.error('üé≠ SIM: Reinitialization failed:', error);
        showError('√âchec du changement de source: ' + error.message);
      }
    }

    function restoreStateFromHash() {
      const hashState = SimEngine.stateFromUrlHash();
      if (hashState && appState.controls) {
        appState.controls.setState(hashState);
        initializeMode();
      }
    }

    // √âtats d'affichage
    function showLoadingState() {
      document.getElementById('loading-state')?.classList.add('active');
      document.getElementById('error-state')?.classList.remove('active');
      document.getElementById('empty-state')?.style.setProperty('display', 'none');
      document.getElementById('results-grid')?.style.setProperty('display', 'none');
    }

    function showResultsState() {
      document.getElementById('loading-state')?.classList.remove('active');
      document.getElementById('error-state')?.classList.remove('active');
      document.getElementById('empty-state')?.style.setProperty('display', 'none');
      document.getElementById('results-grid')?.style.setProperty('display', 'grid');
    }

    function showEmptyState() {
      document.getElementById('loading-state')?.classList.remove('active');
      document.getElementById('error-state')?.classList.remove('active');
      document.getElementById('empty-state')?.style.setProperty('display', 'block');
      document.getElementById('results-grid')?.style.setProperty('display', 'none');
    }

    function showError(message) {
      document.getElementById('loading-state')?.classList.remove('active');
      document.getElementById('error-state')?.classList.add('active');
      document.getElementById('error-message').textContent = message;
      document.getElementById('empty-state')?.style.setProperty('display', 'none');
      document.getElementById('results-grid')?.style.setProperty('display', 'none');
    }

    // Export global pour debug
    window.simApp = {
      state: appState,
      engine: SimEngine,
      runSimulation
    };
  </script>
</body>

</html>


